<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"spground.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Spground Blog">
<meta property="og:url" content="https://spground.github.io/index.html">
<meta property="og:site_name" content="Spground Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Spground">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://spground.github.io/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Spground Blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Spground Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">77</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">11</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">41</span></a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Spground</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">41</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">77</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://spground.github.io/2019/01/24/awk/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Spground">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spground Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Spground Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/01/24/awk/" class="post-title-link" itemprop="url">awk</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-01-24 00:00:00" itemprop="dateCreated datePublished" datetime="2019-01-24T00:00:00+08:00">2019-01-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-24 23:37:51" itemprop="dateModified" datetime="2025-09-24T23:37:51+08:00">2025-09-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Misc/" itemprop="url" rel="index"><span itemprop="name">Misc</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h1><p>awk是最有用的shell工具之一，名字的来源是三位工程师的名字首字母。</p>
<h1 id=""><a href="#" class="headerlink" title=""></a><img src="/images/awk.png"></h1><h1 id="awk-introduction"><a href="#awk-introduction" class="headerlink" title="awk introduction"></a>awk introduction</h1><blockquote>
<p>awk主要被用在文字和字符处理领域，作为一个通用的可编程过滤器。</p>
</blockquote>
<p>awk面向域（field）而sed面向行（line），awk支持以文件、重定向、管道和标准输入作为程序的输入。<br />更准确的来讲，awk是一种仅需几行代码就能够处理复杂任务的编程语言，和sed一样，它是一种pattern-action语言，看起来和C语言类似，但是比C语言简单，它能够自动处理输入、域分割、初始化和内存管理等。</p>
<p>awk相比较于sed的特色：</p>
<ul>
<li>方便的数字处理</li>
<li>在action中的变量和控制流</li>
<li>更便于访问行中的域</li>
<li>灵活的输出</li>
<li>内置丰富的算术和字符串函数</li>
<li>类C风格</li>
</ul>
<p>awk的程序结构</p>
<p>一段awk程序包括：</p>
<ul>
<li>一段可选的BEGIN语句块（主要用于做一些预处理）</li>
<li>一些pattern-action组合</li>
<li>一段可选的END语句块（主要用于做一些后处理）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BEGIN &#123;action&#125;</span><br><span class="line">pattern &#123;action&#125;</span><br><span class="line">...</span><br><span class="line">pattern &#123;action&#125;</span><br><span class="line">END &#123;action&#125;</span><br></pre></td></tr></table></figure>

<p>有几种方式运行一段awk程序：<br />a. awk ‘program’ input_files<br />b. awk ‘program’ 标准输入作为程序输入<br />c. awk -f ‘program_files’ input_files</p>
<h1 id="pattern-action"><a href="#pattern-action" class="headerlink" title="pattern &amp; action"></a>pattern &amp; action</h1><p>awk从一系列输入文件中去搜索指定的pattern，然后执行特定的action当在遇到包含特定pattern的行或者域。<br />awk不会修改输入文件，一次只处理一行。</p>
<p>一个awk程序至少有一个pattern或者action</p>
<ul>
<li>默认的pattern是匹配所有的lines</li>
<li>默认的action是打印当前的record</li>
<li>action包含在{}内，而pattern直接列出。</li>
</ul>
<h3 id="patterns"><a href="#patterns" class="headerlink" title="patterns"></a>patterns</h3><p>pattern是一个决定是否后面action是否被执行的选择器。<br />pattern可以是：</p>
<ul>
<li>特殊测token，例如BEGIN和END</li>
<li>正则表达式 包含在&#x2F;&#x2F;里面 例如 &#x2F;[a-z]&#x2F;</li>
<li>字符串匹配表达式</li>
<li>!表达式取反</li>
<li>以及通过&amp;&amp; 、|| 链接符连接的上述任意表达式<ul>
<li>&#x2F;NYU&#x2F;</li>
<li>x &gt; 0</li>
<li>&#x2F;NYU&#x2F; &amp;&amp; (name &#x3D;&#x3D; ‘UNIX Tools’)</li>
</ul>
</li>
</ul>
<p>特殊的pattern token</p>
<ul>
<li>BEGIN：预处理，常用于初始化一些内置变量例如FS、RS等；</li>
<li>END：后处理</li>
</ul>
<h3 id="actions"><a href="#actions" class="headerlink" title="actions"></a>actions</h3><p>action可能包含一系列的类C的代码语句，执行一些类似算术、字符串表达式、声明以及输出。<br />action当<strong>每一行</strong>匹配一个pattern就会被执行，如果不指定pattern，action无条件执行，如果action不被指定，默认action是输出到标准设备。</p>
<p>例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span>|awk <span class="string">&#x27;BEGIN &#123;print &quot;List all C language source files.&quot;&#125;</span></span><br><span class="line"><span class="string">/\.c$/ &#123;print&#125;</span></span><br><span class="line"><span class="string">END &#123;print &quot;List has been done!&quot;&#125;</span></span><br><span class="line"><span class="string">&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="varaibles"><a href="#varaibles" class="headerlink" title="varaibles"></a>varaibles</h3><p>作为一门语言，那么awk脚本当然可以定义和使用变量。<br />例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BEGIN &#123;<span class="built_in">sum</span> = 0&#125;</span><br><span class="line">&#123;<span class="built_in">sum</span> ++&#125;</span><br><span class="line">END &#123;<span class="built_in">print</span> <span class="built_in">sum</span>&#125;</span><br></pre></td></tr></table></figure>

<p>后面会介绍到，awk预定义了一些有用变量。</p>
<h3 id="records"><a href="#records" class="headerlink" title="records"></a>records</h3><p>预定义变量：</p>
<ul>
<li>RS Record Separator</li>
<li>NR Number of Records</li>
</ul>
<p>默认record seprator是newline，默认的awk一次处理一行。<br />RS可以是任意正则表达式，可以在BEGIN action中更改。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> temp.txt|awk <span class="string">&#x27;&#123;print &quot;#&quot;NR, $0&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上面的$0表示该记录的第0个域，$开头的数字变量都表示域编号。</p>
<h3 id="fields"><a href="#fields" class="headerlink" title="fields"></a>fields</h3><p>预定义变量：</p>
<ul>
<li>NF：Number of Field</li>
<li>FS：Filed Separator</li>
</ul>
<p>输入中的每一行都按域分隔符被拆分。</p>
<ul>
<li>awk预定义变量FS Filed Separator默认是空格（一个或多个空格或者tab）</li>
<li>awk -Fc可以设置FS为字符c</li>
<li>$0是当前所有行</li>
<li>$1是第一个域….，$NF是最后一个域，以此类推<ul>
<li>{print $(NF-2)} 倒数第三个域</li>
</ul>
</li>
<li>计算和打印<ul>
<li>{print $1, $2*$3}</li>
</ul>
</li>
</ul>
<p>默认的由”,”连接的项会被print打印为由单个空格连接的项。</p>
<p>格式化输出：</p>
<ul>
<li>printf(fmt, val1, val2, …)</li>
<li>{printf(“%-8s %6.2f\n”, $1, $2)}</li>
</ul>
<h4 id="selectoins"><a href="#selectoins" class="headerlink" title="selectoins"></a>selectoins</h4><p>前面提到awk是用作一个可编程的过滤器，用于处理文本和字符串。<br />除了前面提到的pattern（正则、begin&amp;end等），更有用的的awk pattern还可以是如下这样的表达式pattern：</p>
<ul>
<li>比较: $2 &gt;&#x3D; 50 {print}</li>
<li>计算: $2 * $3 &gt; 50 {printf(“%6.2f “, $1)}</li>
<li>文本内容:<ul>
<li>$1 &#x3D;&#x3D; “NYU”</li>
<li>$2 ~ &#x2F;NYU&#x2F;</li>
</ul>
</li>
<li>模式组合: $2 &gt;&#x3D; 4 || $3 &gt;&#x3D; 20</li>
<li>行号 NR &gt;&#x3D; 10 &amp;&amp; NR &lt;&#x3D; 20</li>
<li>….</li>
</ul>
<h5 id="computings"><a href="#computings" class="headerlink" title="computings"></a>computings</h5><p>awk可以方便的对域进行一些基本的计算，例如：</p>
<ul>
<li>counting</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$3</span> &gt; 15 &#123;emp = emp + 1&#125;</span><br><span class="line">END &#123;<span class="built_in">printf</span>(<span class="string">&quot;%d empoyess worked more than 15 hours.&quot;</span>, emp)&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>average and sum</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;pay = pay + <span class="variable">$2</span> * <span class="variable">$3</span>&#125;</span><br><span class="line">END &#123;<span class="built_in">print</span> NR, <span class="string">&quot;employes&quot;</span></span><br><span class="line">		 <span class="built_in">print</span> <span class="string">&quot;total pay is &quot;</span>, pay</span><br><span class="line">     <span class="built_in">print</span> <span class="string">&quot;average pay is &quot;</span>, pay / NR&#125;</span><br></pre></td></tr></table></figure>

<h4 id="strings-manipulation"><a href="#strings-manipulation" class="headerlink" title="strings manipulation"></a>strings manipulation</h4><p>awk内置一些函数，用于处理字符串。</p>
<ul>
<li>length(s)</li>
<li>substr(s,m,n)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;nc = nc + length(<span class="variable">$0</span>) + 1</span><br><span class="line">nw = nw + NF&#125;</span><br><span class="line">END &#123;</span><br><span class="line"><span class="built_in">print</span> NR, <span class="string">&quot;lines&quot;</span></span><br><span class="line"><span class="built_in">print</span> nc, <span class="string">&quot;chars&quot;</span></span><br><span class="line"><span class="built_in">print</span> nw, <span class="string">&quot;words&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<h1 id="control-flow"><a href="#control-flow" class="headerlink" title="control flow"></a>control flow</h1><p>awk作为一门编程语言，提供几种基本的类C的流程控制结构。</p>
<ul>
<li>IF THEN ELSE结构</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$2</span> &gt; 6 &#123; n = n + 1&#125;</span><br><span class="line">END &#123;</span><br><span class="line"><span class="keyword">if</span> (n &gt; 0 &#125; </span><br><span class="line">	<span class="built_in">print</span> n</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">	<span class="built_in">print</span> <span class="string">&quot;no employes.&quot;</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>WHILE </li>
<li>DO WHILE</li>
<li>FOR</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = 1; i &lt; 10; i = i + 1)</span><br><span class="line">	<span class="built_in">print</span> i</span><br></pre></td></tr></table></figure>

<h2 id="array"><a href="#array" class="headerlink" title="array"></a>array</h2><ul>
<li>array下标可以是数字和字符串，当下标是字符串的时候，可以当一个map使用</li>
<li>example：a[“tom”] &#x3D; 0.3</li>
</ul>
<p>数组遍历：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (k <span class="keyword">in</span> array) &#123;</span><br><span class="line"><span class="built_in">print</span> k, <span class="string">&quot;==&gt;&quot;</span>, array[k]&#125;</span><br></pre></td></tr></table></figure>
<h2 id="awk-predefined-variales"><a href="#awk-predefined-variales" class="headerlink" title="awk predefined variales"></a>awk predefined variales</h2><ul>
<li>$0 $1 $2 $NF</li>
<li>NF NR NF</li>
<li>FS RS</li>
<li>FILENAME</li>
<li>OFS:output field separator default is single space</li>
</ul>
<h2 id="built-in-functions"><a href="#built-in-functions" class="headerlink" title="built-in functions"></a>built-in functions</h2><ul>
<li>arithmetic<ul>
<li>sin, cos, tan, exp, log, sqrt</li>
</ul>
</li>
<li>strings<ul>
<li>length, substr, split</li>
</ul>
</li>
<li>output<ul>
<li>print, printf</li>
</ul>
</li>
<li>special<ul>
<li>system(“cmd”) eg: system(“clear”)</li>
<li>exit -直接跳转到ENDpattern-action块</li>
</ul>
</li>
</ul>
<h1 id="code-snippets"><a href="#code-snippets" class="headerlink" title="code snippets"></a>code snippets</h1><ol>
<li>filter blank lines while you want to count your code</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /path/to/yourcode/*.py | awk NF | <span class="built_in">wc</span> -l</span><br></pre></td></tr></table></figure>

<p>因为NF表示Number of Filed，默认的FS为空格，当awk遇见空行的时候，作为pattern的NF值为0，因此该行不会被输出。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://spground.github.io/2019/01/14/Notes%EF%BC%9ATemporal%20Relational%20Reasoning%20in%20Videos/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Spground">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spground Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Spground Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/01/14/Notes%EF%BC%9ATemporal%20Relational%20Reasoning%20in%20Videos/" class="post-title-link" itemprop="url">Notes：Temporal Relational Reasoning in Videos</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-01-14 20:00:00" itemprop="dateCreated datePublished" datetime="2019-01-14T20:00:00+08:00">2019-01-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-24 22:30:21" itemprop="dateModified" datetime="2025-09-24T22:30:21+08:00">2025-09-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/deep-learning/" itemprop="url" rel="index"><span itemprop="name">deep learning</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Notes：Temporal-Relational-Reasoning-in-Videos"><a href="#Notes：Temporal-Relational-Reasoning-in-Videos" class="headerlink" title="Notes：Temporal Relational Reasoning in Videos"></a>Notes：Temporal Relational Reasoning in Videos</h1><p>Notes：Temporal Relational Reasoning in Videos</p>
<h1 id="Abstract："><a href="#Abstract：" class="headerlink" title="Abstract："></a>Abstract：</h1><p>时序关系推理能够关联物体随时间的变化，而时序关系推理是完成一些重要的视频识别任务的关键。<br />该文提出了一个被称为Temporal Relation Network（TRN）的网络模块，可以用来在多时间尺度上学习和推理时序关系。该文在Something-Something，Jester和Charades三个数据集做了实验，得到了SOTA的结果。TRN模块是一个可插拔的模块，可以基于常见的CNN架构，在Charades数据集上，采用TRN模块的网络比双流、3D卷积取得了更好的结果。</p>
<h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h1><p>该文一开始突出介绍了时序推理能力是智能决策的关键能力，具有时序推理的物种能够结合当下情形对过去和未来作出推理和预测。文章举了一个简单的例子说明人类具有这种时序推理能力，而常见的模型似乎很难学会。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/168795/1547450333881-c4b46004-da02-41f9-986b-2fac4712e89f.png#align=left&display=inline&height=316&linkTarget=_blank&name=image.png&originHeight=632&originWidth=1392&size=654365&width=696" alt="image.png"></p>
<p>人类很容易通过观察一件事情的始末状态，可以推理中间发生的过程，而对于普通的神经网络模型却有点困难。在CV领域视频的行为识别是一个核心的研究领域，一些常见的数据集例如UCF101，Sport1M和THUMOS等，包含许多人类行为，这些行为不需要通过长范围的时序推理就能够被识别出来（基于外观和光流等特征），例如常见的双流卷积网络和I3D等网络。</p>
<p>然而，当视频的长度有限以及某些需要通过物体的变换和时序关系而非外观来刻画的视频，这时候上述的那些网络往往不能够很好的工作。例如上面的图片的例子，每一组的两张图片在apperance差距不大，也很难仅仅根据外观来判断发生了什么，因此需要网络能够基于光流和图像里面物体的外观等因素，去发现一种<strong>视觉常识</strong>。</p>
<p>TRN模块描述了视频采样的数帧之间的时序关系，且TRN能够学习和发现多尺度的时序关系。TRN是一个很容易被结合到现有的成熟的网络结构上，因此在使用上也是低成本的。</p>
<h2 id="1-1-Related-Work"><a href="#1-1-Related-Work" class="headerlink" title="1.1 Related Work"></a>1.1 Related Work</h2><p>该文回顾总结了常见用于行为识别的方案，双流卷积、CNN+LSTM、3D卷积以及最近的I3D网络。然后该文基本上指出了这些网络结构常见的问题：</p>
<ul>
<li>双流网络基本就是光流的计算耗时，效率低下；</li>
<li>3D卷积计算复杂度高，3D卷积在连续的图像帧上做卷积有些冗余；</li>
<li>这些网络的输入通常是20到30帧，因此很难学习到长范围的时序关系；</li>
</ul>
<p>为了解决这些问题，TRN稀疏采样帧，然后学习他们之间的因果关系，这相比于密集采样然后对他们做卷积运算要有效率得多。</p>
<p>下图是TRN对一个video的表示。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/168795/1547452677104-fcfd5a64-292b-4113-9d3d-9878019f834d.png#align=left&display=inline&height=352&linkTarget=_blank&name=image.png&originHeight=704&originWidth=1428&size=513012&width=714" alt="image.png"></p>
<h1 id="2-Temporal-Relation-Network"><a href="#2-Temporal-Relation-Network" class="headerlink" title="2. Temporal Relation Network"></a>2. Temporal Relation Network</h1><p>该文后续的实验表明：装配有TRN模块的网络能够发现可解释的视觉常识。</p>
<h2 id="2-1-时序关系定义"><a href="#2-1-时序关系定义" class="headerlink" title="2.1 时序关系定义"></a>2.1 时序关系定义</h2><p>pair-wise的时序关系定义如下：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/168795/1547452848395-e0460887-b3be-4aff-9c64-f6236e982a19.png#align=left&display=inline&height=64&linkTarget=_blank&name=image.png&originHeight=128&originWidth=1446&size=19940&width=723" alt="image.png"><br />其中输入<img src="https://cdn.nlark.com/yuque/__latex/ba0a51925da61fe95a29b0e5d1cc5503.svg#card=math&code=V%20%3D%20%5C%7Bf_1%2Cf_2%2C...%2Cf_n%5C%7D&height=24&width=148">是原始视频采样的有序帧的特征表示，例如一些CNN架构的某层的activation。函数<img src="https://cdn.nlark.com/yuque/__latex/a67984081d583fd61448b307f11b87a9.svg#card=math&code=h_%5Cphi&height=24&width=19">和函数<img src="https://cdn.nlark.com/yuque/__latex/c90100d47c5c29dd569044c82af79abb.svg#card=math&code=g_%5Ctheta&height=24&width=16">融合不同的pair-wise帧的时序关系，文章中提出的TRN仅仅使用了MLP来表示两个函数。另外，为了计算的有效性，文章中并没有全部计算采样的n个帧特征的pair-wise时序关系，而是随机选择（均匀采样）了<img src="https://cdn.nlark.com/yuque/__latex/8ce4b16b22b58894aa86c421e8759df3.svg#card=math&code=k&height=24&width=9">个pair-wise关系来计算。<br /><br /><br />上面考虑的是2-frame的关系，其中还有3-frame，4-frame，……，n-frame的时序关系。<br />对于3-frame的时序关系：<br /><img src="https://cdn.nlark.com/yuque/0/2019/png/168795/1547464334500-e1ba2a0b-1051-452d-9dbc-2cfec0921366.png#align=left&display=inline&height=67&linkTarget=_blank&name=image.png&originHeight=134&originWidth=1374&size=22654&width=687" alt="image.png"><br />以此类推计算其他d-frame的时序关系。</p>
<h2 id="2-2-多尺度时序关系"><a href="#2-2-多尺度时序关系" class="headerlink" title="2.2 多尺度时序关系"></a>2.2 多尺度时序关系</h2><p>为了捕获多尺度的时序关系，文章将上诉的d-frame的时序关系简单的组合起来。<br /><img src="https://cdn.nlark.com/yuque/0/2019/png/168795/1547464448424-4008bc97-d459-4042-b484-12c5bccdebb4.png#align=left&display=inline&height=49&linkTarget=_blank&name=image.png&originHeight=98&originWidth=1384&size=12610&width=692" alt="image.png"><br />每个时序关系项<img src="https://cdn.nlark.com/yuque/__latex/6c30b387200ac188eef7192b5bd15eeb.svg#card=math&code=T_d%28V%29&height=24&width=44">都表示了d张有序的frame的时序关系，其中每一个时序关系项<img src="https://cdn.nlark.com/yuque/__latex/6c30b387200ac188eef7192b5bd15eeb.svg#card=math&code=T_d%28V%29&height=24&width=44">都对应两个函数<img src="https://cdn.nlark.com/yuque/__latex/c0992f072c25ce1f1b6c199fb4a35dc2.svg#card=math&code=h%5E%7B%28d%29%7D_%7B%5Cphi%7D&height=29&width=27">和<img src="https://cdn.nlark.com/yuque/__latex/1c7b7902483a78c63a356cea2e3b09a0.svg#card=math&code=g%5E%7B%28d%29%7D_%7B%5Ctheta%7D&height=27&width=26">。<br /><br /></p>
<h2 id="2-3-采样规则"><a href="#2-3-采样规则" class="headerlink" title="2.3 采样规则"></a>2.3 采样规则</h2><p>为了有效的训练，降低计算复杂度，文章提出了一个有效的采样策略。给定均匀采样的N帧，对于d-frame关系的计算，当<img src="https://cdn.nlark.com/yuque/__latex/8bfe79b323657f98ed9cecf63b5e1651.svg#card=math&code=d%20%3D%20N&height=24&width=47">时，直接计算<img src="https://cdn.nlark.com/yuque/__latex/3d6d5a9edaef60b4c04cdc5666619466.svg#card=math&code=T_N%28V%29&height=24&width=49">。当<img src="https://cdn.nlark.com/yuque/__latex/6ce174e00354bef2513bb189bf6af7c3.svg#card=math&code=d%20%3C%20N&height=24&width=47">时，则在所有可能的d-frame的排列中均匀选择<img src="https://cdn.nlark.com/yuque/__latex/8ce4b16b22b58894aa86c421e8759df3.svg#card=math&code=k&height=24&width=9">个排列，按照公式计算，将其表示d-frame的时序关系。这样在给定<img src="https://cdn.nlark.com/yuque/__latex/8d9c307cb7f3c4a32822a51922d1ceaa.svg#card=math&code=N&height=24&width=15">张frame的情况下，可以计算<img src="https://cdn.nlark.com/yuque/__latex/ec521827e2328e4fa094b3d78032181c.svg#card=math&code=1%20%2B%EF%BC%88N-2%EF%BC%89%2A%20k&height=26&width=131">个多尺度的时序关系。</p>
<h1 id="3-实验"><a href="#3-实验" class="headerlink" title="3. 实验"></a>3. 实验</h1><p>因为文章想说明TRN模块的有效性，因此文章所有用来对比的模型均采用BN-Inception作为基础的CNN网络结构，唯一不同的就是是否使用TRN模块。文章的<img src="https://cdn.nlark.com/yuque/__latex/c90100d47c5c29dd569044c82af79abb.svg#card=math&code=g_%5Ctheta&height=24&width=16">函数是一个每层256神经元的两层MLP，而<img src="https://cdn.nlark.com/yuque/__latex/a67984081d583fd61448b307f11b87a9.svg#card=math&code=h_%5Cphi&height=24&width=19">则是一层MLP。文章设置k&#x3D;3，d&#x3D;8。文章和TSN模型在Something-V1和Something-V2数据集上做了对比，结果如下：<br /><br /><br /><img src="https://cdn.nlark.com/yuque/0/2019/png/168795/1547466536656-d99c8f0e-eb52-4a96-bf7f-fdda29310078.png#align=left&display=inline&height=324&linkTarget=_blank&name=image.png&originHeight=648&originWidth=1444&size=156727&width=722" alt="image.png"><br /><br /><br />可以看出TRN模型确实outperform TSN模型，但是用single-frame作为base-line来对比说明TRN模型的有效性有点难以服众，毕竟base-line只利用了single frame的信息。</p>
<p>另外文章还在Jester和Charades上做了实验：</p>
<ul>
<li>Jester数据集</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/168795/1547466676029-e83c73c8-eeeb-4b8f-b04d-98d68cfaace0.png#align=left&display=inline&height=265&linkTarget=_blank&name=image.png&originHeight=530&originWidth=1404&size=107405&width=702" alt="image.png"></p>
<ul>
<li>Charades数据集</li>
</ul>
<p>在该数据集上，TRN模型打败了2-stream卷积网络和C3D网络，以及最近的Asyn-chronous Temporal Field方法。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/168795/1547466777022-f64ce276-8c96-4dfa-83a6-0bb4ca2e7aec.png#align=left&display=inline&height=86&linkTarget=_blank&name=image.png&originHeight=172&originWidth=1148&size=41266&width=574" alt="image.png"></p>
<h2 id="TRN中的可解释的视觉常识"><a href="#TRN中的可解释的视觉常识" class="headerlink" title="TRN中的可解释的视觉常识"></a>TRN中的可解释的视觉常识</h2><h3 id="TRN模块选择最能表示视频的帧（Representative-Frame）"><a href="#TRN模块选择最能表示视频的帧（Representative-Frame）" class="headerlink" title="TRN模块选择最能表示视频的帧（Representative Frame）"></a>TRN模块选择最能表示视频的帧（Representative Frame）</h3><p>首先计算不同的视频帧排列的经过TRN模块的时序关系response，然后将这些response排序，选择最高response的视频帧排列。这些视频帧在TRN模块下，是该视频的表示帧。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/168795/1547467489189-c50e93ee-0151-4758-a32a-7fb03161c8f3.png#align=left&display=inline&height=457&linkTarget=_blank&name=image.png&originHeight=914&originWidth=1758&size=982124&width=879" alt="image.png"></p>
<h3 id="视频的时序对齐"><a href="#视频的时序对齐" class="headerlink" title="视频的时序对齐"></a>视频的时序对齐</h3><p>基于上面的representative frame，TRN可以用于对于同一个action类别的不同视频进行时序对齐。首先利用TRN找出这些representative frame的index作为该视频时序上的landmark，然后调整采样率，使得每一个视频同时到达每一个landmark。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/168795/1547467710082-32cc3cbe-a51f-469d-b790-582a383ca3ed.png#align=left&display=inline&height=568&linkTarget=_blank&name=image.png&originHeight=1136&originWidth=1744&size=1713335&width=872" alt="image.png"></p>
<h3 id="时序对于行为识别的重要性"><a href="#时序对于行为识别的重要性" class="headerlink" title="时序对于行为识别的重要性"></a>时序对于行为识别的重要性</h3><p>文章为了表明时序的重要性，在Something和UCF101数据集进行了一个对比实验，一组是按原始顺序输入视频帧，一组是shuffle顺序输入视频帧。结果比较有意思：在Something数据集上来看，原始顺序输入的实验结果明显好于shuffle顺序输入，而对于UCF101，视频帧的输入顺序对结果影响不大。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/168795/1547468093076-bfec8d4f-51cd-497c-ae89-5f0e8a36f17a.png#align=left&display=inline&height=225&linkTarget=_blank&name=image.png&originHeight=450&originWidth=1030&size=51935&width=515" alt="image.png"></p>
<p>文章给出的解释是对于视频中持续的行为过程，时序关系对于UCF-101数据集的行为识别用处不大。为了进一步分析这种差异，文章画出了两种顺序输入后准确度有显著差异和没有显著差异的活动分类。</p>
<p>对于一些有很强的方向性的、大的动作，保留时序顺序对于准确识别行为类别是重要的，这也和我们的直觉相符，而对于一些看起来似乎静止的活动，例如“将一个不会滚动的球放在桌上”这个行为准确的识别不太需要motion，而是需要一些物品的co-occurence信息即可。</p>
<h3 id="早期行为识别"><a href="#早期行为识别" class="headerlink" title="早期行为识别"></a>早期行为识别</h3><p>文章认为TRN模块可以在给定少量的帧的情况下，利用帧之间的关系可以预测出该活动的类别。<br />这样在训练好模型后，在实际预测的时候，就可以在早期就给出行为类别的预测。<br /><img src="https://cdn.nlark.com/yuque/0/2019/png/168795/1547469065209-04481775-b6c6-4a0d-b112-47b64070a759.png#align=left&display=inline&height=269&linkTarget=_blank&name=image.png&originHeight=538&originWidth=1788&size=128390&width=894" alt="image.png"></p>
<h1 id="4-结论"><a href="#4-结论" class="headerlink" title="4. 结论"></a>4. 结论</h1><p>文章认为TRN可以让神经网络对视频的时序关系进行推理，并且在几个数据集上取得了competitive的效果。同时，通过一系列的分析，文章认为TRN发现了视频中的一些可解释的视觉常识。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://spground.github.io/2018/12/04/Notes-Learning%20Spatiotemporal%20Features%20with%203D%20Convolutional%20Networks/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Spground">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spground Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Spground Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/12/04/Notes-Learning%20Spatiotemporal%20Features%20with%203D%20Convolutional%20Networks/" class="post-title-link" itemprop="url">Notes：Learning Spatiotemporal Features with 3D Convolutional Networks</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-12-04 20:00:00" itemprop="dateCreated datePublished" datetime="2018-12-04T20:00:00+08:00">2018-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-24 22:30:21" itemprop="dateModified" datetime="2025-09-24T22:30:21+08:00">2025-09-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/deep-learning/" itemprop="url" rel="index"><span itemprop="name">deep learning</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Notes：Learning Spatiotemporal Features with 3D Convolutional Networks</p>
<h1 id="Abstract："><a href="#Abstract：" class="headerlink" title="Abstract："></a>Abstract：</h1><p>本文提出了一个简单有效的方案，使用3D卷积在大规模视频中来学习空间时序(<strong>Spatiotemporal</strong>)特征，本文的贡献如下：</p>
<ul>
<li>相比于2D卷积，3D卷积更加适合学习空间时序特征；</li>
<li>作者通过实验不同的网络结构，发现3*3*3的卷积核是最好的网络结构；</li>
<li>作者通过学习到的C3D特征去作为视频的描述子，采用简单的线性分类器，在4个benchmarks上，取得了比SOTA好的结果，同时在另外2个benchmarks上取得了和SOTA相当的结果；</li>
<li>C3D学习到特征是压缩的、具有判别性的，通过PCA降维到10维，也能在UCF101上达到52.8%的准确度，相比于其他方法学到的特征，C3D特征更加压缩和具有判别性，在现实环境中可以更容易提高准确度和计算复杂度的trade-off；</li>
</ul>
<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>作者表明虽然在不同的视频任务领域，存在很多好的解决方案，但是仍然需要一个__通用的视频描述子(generic video desciptor)__，这样会以一种统一的方式去解决大规模视频任务中的问题。</p>
<p>对于一个通用的视频描述子，以下简称GVD，作者认为有效的GVD应该具有如下四个性质：</p>
<ol>
<li>通用性，这样才能才具有判别性的同时可以表示不同类型的视频，例如自然风景、体育运动、电视节目、电影等；</li>
<li>压缩性，因为当处理数百万个视频时，压缩的特征可以跟有效的处理、存储和检索；</li>
<li>计算有效性，在现实系统中，我们需要每分钟处理数千个视频；</li>
<li>易于实现，经过该描述子提取的特征，即使采用简单的分类器，例如线性分类器，也应该能取得不错的效果；</li>
</ol>
<p>使用深度学习提取的图像特征不能直接适用于视频任务，因为这些图像特征缺乏对动作的建模。</p>
<p>作者人为本文的贡献如下：</p>
<ul>
<li>作者做了一系列实验，包括视频分类、动作识别、场景识别和对象检测等，<strong>表明了3d深度卷积网络是好的模型来对外观（apperance）和动作（motion）同时建模；</strong></li>
<li>作者通过有限的实验探索了各种不同的3d卷积网络的结构（kernel的大小不同），<strong>最终发现3*3*3的kernel是经验最优的结构</strong>，这一点和2D卷积中kernel的选取经验相似；</li>
<li>使用作者提出的C3D网络结构提取的特征，使用简单的线性SVM分类器，在4个不同的任务和6个不同的benchmark中取得了最优的效果；</li>
</ul>
<h1 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h1><p>作者回顾了一些传统的视频描述子的方法，重点提到了目前最好的称为iDT的方法，并指出这个方法计算量大，难以扩展到大规模视频的任务中。</p>
<p>随着机器的计算力提高和数据量的增多，卷积神经网络在很多任务中有所突破。有些人利用深度学习学习到Image特征，通过迁移学习的方式在一些任务上取得了不错的效果，但是这些方法都是不适用于视频特征学习的。</p>
<p>在作者这篇文章之前，有几篇文章已经开始或多或少的提到了利用3D卷积去进行视频特征的学习，其中一篇文章是2013年的 *<strong>3d convolutional neural networks for human action recognition，文章</strong>*利用预处理的方式将视频中的头和身体进行分割，然后将分割后的视频送入3d卷积网络中做动作识别；另一篇是2014年__Karpathy__等人训练了深度网络去进行视频分类。</p>
<h1 id="Learning-features-with-3D-ConvNets"><a href="#Learning-features-with-3D-ConvNets" class="headerlink" title="Learning features with 3D ConvNets"></a>Learning features with 3D ConvNets</h1><h2 id="3D-Convolution、3D-Pooling、search-for-Network-Architecture"><a href="#3D-Convolution、3D-Pooling、search-for-Network-Architecture" class="headerlink" title="3D Convolution、3D Pooling、search for Network Architecture"></a>3D Convolution、3D Pooling、search for Network Architecture</h2><h3 id="3D-Convolution-VS-2D-Convolution"><a href="#3D-Convolution-VS-2D-Convolution" class="headerlink" title="3D Convolution VS 2D Convolution"></a>3D Convolution VS 2D Convolution</h3><p>和2D卷积不同，3D卷积有能力通过3D卷积和3D池化对时间信息进行建模。</p>
<p>2D卷积和3D卷积的区别</p>
<p><img src="https://cdn.nlark.com/yuque/0/2018/png/168795/1543926034473-47500c66-976a-4f31-8e4f-c4ba02800ebd.png" alt="image.png | left | 747x170"></p>
<p>在一张图片上进行一次2D卷积，输出是一张图片（Feature Map），在一个视频进行一次2D卷积，输出同样是一张图片（Feature Map），在一个视频上进行一次3D卷积，输出则是另一个立方体，这个立方体保留了输入信号的时序信息。</p>
<p><strong>总结： 2D卷积在每次卷积和池化和都丢失了时序信息，而3D卷积和池化则保留了时序信息。</strong></p>
<h3 id="search-for-Network-Architecture"><a href="#search-for-Network-Architecture" class="headerlink" title="search for Network Architecture"></a>search for Network Architecture</h3><p>因为训练这种大型的网络是十分耗费时间的，因此作者根据2D卷积的经验，空间维度的卷积核采用3*3，而时间维度的卷积深度则通过不同的实验来选择，因此3D卷积核的大小为d*3*3。</p>
<p>为了找到时间维度上最优的卷积深度d，作者在中等规模的UCF101数据集上进行了3类实验：</p>
<ul>
<li>全局采用一致的时间维度卷积深度d；</li>
<li>从前往后，时间维度卷积深度d逐层递增，3-3-5-5-7；</li>
<li>从前往后，时间维度卷积深度d逐层递减，7-5-5-3-3；</li>
</ul>
<p>作者在搜索最优的时间卷积深度的时候，由于是在中等规模数据集上进行的，网络结构为：5层卷积和2层全连接。<br>卷积层的配置逐层如下：</p>
<ul>
<li>64 kernels</li>
<li>128 kernels</li>
<li>256 kernels</li>
<li>256 kernels</li>
<li>256 kernels</li>
</ul>
<p>所有的卷积层在空间和时间维度都采用SAME padding，因此卷积前后的size是不变的。每一层卷积后都接一层3D pooling层，除了第一层池化层的核为1*2*2外，其余池化层全部为2*2*2，因此经过池化层的size会缩小为原来的1&#x2F;8。</p>
<p><strong>说明：作者强调了第一层池化层在时间维度不进行池化有两个目的：</strong></p>
<ul>
<li>不想过早的合并时序信息；</li>
<li>输入是16帧图像，因此时间维度最多进行4次池化；</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2018/png/168795/1543926692559-3ab35db1-52e9-4410-b288-4aa4dbde51f4.png" alt="image.png | left | 400x220"></p>
<p>最终作者发现时间维度的卷积深度为3的时候，网络性能最佳，因此3*3*3是经验最优的3D卷积核，这也和2D卷积的3*3卷积核是统一的。</p>
<h2 id="Spatiotemporal-Feature-learning"><a href="#Spatiotemporal-Feature-learning" class="headerlink" title="Spatiotemporal Feature learning"></a>Spatiotemporal Feature learning</h2><p>为了进行空间时序特征的学习，作者在一个大规模的数据集Sport-1M上进行了训练。Sport-1M包含100万个视频，每个视频属于487种运行类别种的一种，和UCF101相比，Sports-1M的视频数量是它的100倍，类别数目是它的5倍。因此作者也设计了容量更大的网络结构，如下所示：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2018/png/168795/1543926857864-0d3a3cce-d9f2-4381-8d78-e7a6f8aeef25.png" alt="image.png | left | 747x127"></p>
<p>网络一共8层卷积层，每一层紧接一个池化层，最后两个全连接层。<br>作者的实验结果如下：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2018/png/168795/1543928718199-20336e5c-7a20-4ebb-8495-ce1c6c9b6eab.png" alt="image.png | left | 747x139"></p>
<ul>
<li><strong>C3D视频描述子：在Sport-1M上训练过的网络可以用来作为视频分析任务的特征提取器，因为该c3d视频描述子具有很多优良的性质；</strong></li>
<li><strong>C3D网络学习到了什么？</strong><ul>
<li><strong>作者通过反卷积可视化技术，观察到对于视频的前几帧，网络学习到了外观apperance，在接下来的图像帧中，网络重点学习到了显著的动作。这表明和2D卷积网络不同，3D卷积网络选择性的学习到了动作和外观特征，而这些特征对于视频分类等问题，具有很好的判别性。</strong></li>
</ul>
</li>
</ul>
<h1 id="Experiment"><a href="#Experiment" class="headerlink" title="Experiment"></a>Experiment</h1><p>作者后续又先后在</p>
<ul>
<li>Action Recognition</li>
<li>Action Similarity Labeling</li>
<li>Scene and Object Recognition<br>等任务中进行了实验，实验结果几乎都是属于SOTA结果，这也证明了C3D网络是一种优秀的网络结构用于处理视频任务。</li>
</ul>
<p>作者其中还通过可视化技术t-SNE，将C3D学习到特征通过特征嵌入的方式，和ImageNet的特征进行了对比，表明了C3D学习到特征是压缩的。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2018/png/168795/1543929463034-2c1d28bc-f6f5-408f-a7fb-4fbfe95db712.png" alt="image.png | center | 401x295"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2018/png/168795/1543929431565-ced0c458-6062-4b53-a8dd-dc9872b95892.png" alt="image.png | center | 364x274"></p>
<h1 id="Runtime-Analysis"><a href="#Runtime-Analysis" class="headerlink" title="Runtime Analysis"></a>Runtime Analysis</h1><p>作者通过和传统方法iDT、深度学习方法Temporal Stream Network TSN方法的运行时间做了对比，表明c3d网络是高效的、计算成本低的方法。这也表明c3d可以很好的运行在现实系统中，因此具有很好的现实意义。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2018/png/168795/1543929638383-892c2b54-ae7f-4c98-9f9b-f7a53edb83ba.png" alt="image.png | center | 534x232"></p>
<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><ul>
<li>C3D能同时对空间和时间信息建模；</li>
<li>C3D特征是有效的、通用的、压缩的且易于实现的；</li>
<li>C3D网络中<ul>
<li>浅层的卷积层学习到了低层次的运动模式：例如颜色的改变、移动的边缘和边缘方向的改变；</li>
<li>中层的卷积层学习到了高层次、更大的运动模式：例如纹理的移动、身体躯干的移动、轨迹的移动等；</li>
<li>高层的卷积层学习到了更复杂的运行模式：例如移动的圆形物体、移动的自行车形状的物体；</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2018/png/168795/1543930139869-3057c701-fb0e-4546-a786-85da9f3ca583.png" alt="image.png | left | 747x644"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2018/png/168795/1543930176701-e36f2b39-c626-45b4-8f8c-8c3140b0b7dc.png" alt="image.png | left | 747x582"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://spground.github.io/2018/11/21/notes-of-stucture-your-machine-learning/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Spground">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spground Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Spground Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/11/21/notes-of-stucture-your-machine-learning/" class="post-title-link" itemprop="url">Notes：Deep Learning-structure your machine learning-week2</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-11-21 23:00:00" itemprop="dateCreated datePublished" datetime="2018-11-21T23:00:00+08:00">2018-11-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-24 22:30:21" itemprop="dateModified" datetime="2025-09-24T22:30:21+08:00">2025-09-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/machine-learning/" itemprop="url" rel="index"><span itemprop="name">machine learning</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-数据分布不一致"><a href="#1-数据分布不一致" class="headerlink" title="1. 数据分布不一致"></a>1. 数据分布不一致</h1><blockquote>
<p>训练集和测试集（包含开发集）数据分布不一致被称为Data Mismatch。</p>
</blockquote>
<p>我们知道机器学习模型会存在两种异常情况：</p>
<ul>
<li>高方差：过拟合</li>
<li>高偏差：欠拟合</li>
</ul>
<p>数据集一般划分为：train、dev、test。<br>其中当dev&#x2F;test 和 train的数据分布存在不一致（data mismatch）的时候，则模型的高方差可能来源于两个原因：</p>
<ul>
<li>过拟合</li>
<li>数据分布不一致</li>
</ul>
<h2 id="1-1-如何判断高方差来源于data-mismatch呢？"><a href="#1-1-如何判断高方差来源于data-mismatch呢？" class="headerlink" title="1.1 如何判断高方差来源于data mismatch呢？"></a>1.1 如何判断高方差来源于data mismatch呢？</h2><p>将train划分一部分作为train-dev，并在train-dev上对模型进行评价。这样我们可以得到：</p>
<ul>
<li>train</li>
<li>train-dev</li>
<li>dev</li>
<li>test</li>
</ul>
<p>如果高方差问题主要源于data mismatch，就错误率来讲，train 约等于 train-dev，而train则远小于 dev&#x2F;test。</p>
<h2 id="1-2-如何解决Data-Mismatch问题？"><a href="#1-2-如何解决Data-Mismatch问题？" class="headerlink" title="1.2 如何解决Data Mismatch问题？"></a>1.2 如何解决Data Mismatch问题？</h2><p>Data Mismatch的解决方法自然是让train和dev&#x2F;test的分布一致。<br>首先进行错误分析，观察dev&#x2F;test上错误的样本和训练集上的样本的差别，然后采用人工合成数据来尽量让训练集与dev&#x2F;test集合相似，保持相同或相似的分布。</p>
<p>例如对于一个图像分类任务中，被错误分类的dev&#x2F;test的图像大多都有雾气背景，则可以将train中的一些样本进行雾气背景的人工合成。</p>
<h1 id="2-迁移学习"><a href="#2-迁移学习" class="headerlink" title="2. 迁移学习"></a>2. 迁移学习</h1><blockquote>
<p>将在数据集A上训练的模型运用在数据集B上的过程叫做迁移学习。</p>
</blockquote>
<p>迁移学习包含两个重要的概念：</p>
<ul>
<li>pre-training：预先在某个数据集上进行模型的训练。</li>
<li>fine-tuning：在目标数据集上对预训练模型进行训练，微微调整其模型参数。</li>
</ul>
<p>迁移学习的目的是为了让一些任务相关的模型可以共享一些低层次的特征，这样即减少了模型的训练时间，也降低了对海量数据集的要求。</p>
<blockquote>
<p>ps：马克思主义中国化历程其实可以看做是一次迁移学习，中国共产党人将得到验证的马克思主义理论（pre-training）运用到中国，并对其改革创新、继承发展（fine-tuning），最终创造了毛泽东思想，中国特色社会主义理论体系，习近平新时代中国特色社会主义思想等理论成果。</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2018/png/168795/1542806599420-46ed2a52-d315-4b8e-9066-472e6ce3c9cb.png" alt="transfer-learning.png | center | 747x166"></p>
<p>对于一个预训练模型，如上图所示，对其进行迁移学习和微调的做法不拘一格。</p>
<ul>
<li>固定前面n-1层权重不变，将输出层替换为满足自己任务需求的输出层，然后在自己的数据集上进行训练，只调整替换的输出层的权重。</li>
<li>前面的n-1层的权重作为新模型的初始化权重，并对新模型的n层网络进行训练。</li>
</ul>
<p>选择保留哪些网络层，新增多少网络层以及权重的更新策略等都是视具体任务而定的。</p>
<p>迁移学习的应用场景：</p>
<ul>
<li>任务A和任务B有相同的输入，例如输入都是图像、文本等；</li>
<li>任务A的数据集大于任务B的数据集；</li>
<li>任务A的低层次的特征对提升任务B的性能大有帮助；</li>
</ul>
<p>例子：一个在海量红绿灯数据集上训练的__识别红绿灯__的模型，可以采用迁移学习去训练一个__识别黄灯__的模型，因为都是交通灯，仅仅是颜色不同，这两个任务非常相近。</p>
<h1 id="3-多任务学习"><a href="#3-多任务学习" class="headerlink" title="3. 多任务学习"></a>3. 多任务学习</h1><p>多任务学习和迁移学习不一样，多任务学习不是先学习一个模型，然后再去训练另一个模型，而是同时进行多个模型的训练（多个任务的学习）。</p>
<p>例如：检测一个图片中是否有行人、汽车、停止标志和红绿灯，在一个神经网络中，这些任务都可以同时进行学习。不像softmax作为输出层，该任务的预测结果不是每张图片具有多个label，而是是否存在该label。同时，对于一些标注样本，如果某个样本在某个label上缺失，也不影响整个训练，其同样可以作为有效的样本存在于训练集中。</p>
<p>多任务学习的使用场景没有迁移学习常见，适合多任务学习的场景主要是：在一系列相关的任务中，这些任务有共享的低层次的特征，例如计算机视觉领域的对象检测。</p>
<h1 id="4-端到端学习"><a href="#4-端到端学习" class="headerlink" title="4. 端到端学习"></a>4. 端到端学习</h1><p>传统的一些计算机任务例如语音识别，需要手动的设计特征（hand-craft feature），例如MFCC，然后人为的划分很多个步骤，每个步骤都有特定的研究者在该领域耕耘数十年。我们在采用这种pipline的方式进行机器学习的时候，很多时候我们强迫算法去学习我们人为定义的概念，例如语音识别中的音素。</p>
<p>端到端的学习则不是采用这一套pipline的方式，而是利用原始的数据去学习原始输入和输出之间复杂的映射。端到端的学习没有引入人类的一些强迫的概念，而是从数据本身去发现潜在的输入和输出的关系。端到端的学习的成功很大部分取决于海量的数据，而传统的方法并不是一无是处，在一些数据量小的情况下，传统方法具有明显的优势。</p>
<p>在数据量小的时候，传统的方法可能更适合，在数据量巨大的时候，端到端的学习方法更可取，然而，现实世界中，没有足够的数据去进行端到端的学习，因此在数据量适中的情况下，我们通常将端到端的学习拆分为多个步骤，并同时采用一些传统的方法，相当于除了数据之外，我们还为模型注入一些人类的知识，这样整个模型表达知识的能力才会到达最优。</p>
<p>例如：人脸识别门禁。</p>
<ul>
<li>端到端的方案：输入是一张站着的人的图片，输出是这个人的id，显然站着的人的脸的大小会随着人距离摄像头的远近不同，还有角度等因素，因此采集海量的数据是十分困难的，因此端到端的学习在这不太实用。</li>
<li>多步骤分开建模方案：首先利用成熟的模型将人脸抠出来，然后再resize的固定的大小进行人脸识别，这样就将人脸识别的大问题拆分为两个易于解决的子问题，而每个子问题可利用的数据集也是巨大的，可以单独的采用端到端的方案去学习。</li>
</ul>
<p>端到端学习的优缺点：</p>
<ul>
<li>优点<ul>
<li>充分发挥数据的价值</li>
<li>花费很少的精力去设计特征</li>
</ul>
</li>
<li>缺点<ul>
<li>要求海量数据</li>
<li>对于一些很有用的人工特征没有充分利用</li>
</ul>
</li>
</ul>
<blockquote>
<p>端到端的学习不是万能的，传统方法并不是一无是处。</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://spground.github.io/2018/11/12/hexo-backup-config/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Spground">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spground Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Spground Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/11/12/hexo-backup-config/" class="post-title-link" itemprop="url">配置MacBook Pro Hexo博客源文件备份</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-11-12 21:58:00" itemprop="dateCreated datePublished" datetime="2018-11-12T21:58:00+08:00">2018-11-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-24 22:30:21" itemprop="dateModified" datetime="2025-09-24T22:30:21+08:00">2025-09-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Misc/" itemprop="url" rel="index"><span itemprop="name">Misc</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>前段时间实验室的电脑磁盘卡盘彻底报废，最近想用github.io上的博客恢复之前的hexo环境，但不幸的发现托管在<code>github.io</code>上的代码仅仅是hexo渲染过后的html css javascript等静态文件，而原始的<code>MarkDown</code>文件和一些hexo site的配置文件却没有同步到github上。在打算从头开始配置一个的时候，意外发现之前的一个备份。为了不吃二次亏，我决定将博客的原始markdown文件也上传到github上。于是我的需求是：在每一次同步hexo渲染后的静态文件后，自动备份原始markdown等文件到github的另一个repo。</p>
<h1 id="1-新建一个blog-repo"><a href="#1-新建一个blog-repo" class="headerlink" title="1. 新建一个blog repo"></a>1. 新建一个blog repo</h1><p>在github上新建一个blog repo来保存博客原始的markdown等文件。然后在本地电脑的hexo博客目录下，运行：</p>
<p><img src="/images/blog-repo.jpg"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin your_blog_git_url</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master --allow-unrelated-hostories</span><br></pre></td></tr></table></figure>



<p>到这里就将本地的markdown文件和git blog repo关联起来了。</p>
<h1 id="2-配置git免密提交"><a href="#2-配置git免密提交" class="headerlink" title="2. 配置git免密提交"></a>2. 配置git免密提交</h1><p>这个可以参考其他资料，此处略。</p>
<h1 id="3-修改当前用户目录下-bashrc-中的alias"><a href="#3-修改当前用户目录下-bashrc-中的alias" class="headerlink" title="3. 修改当前用户目录下.bashrc 中的alias"></a>3. 修改当前用户目录下.bashrc 中的alias</h1><p>如果终端使用的是bash，就修改.bashrc，是zsh则修改.zshrc文件，下面以.zshrc举例。</p>
<p>在.zshrc加上一行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> hexod = <span class="string">&quot;hexo g --deploy &amp;&amp; git add --all &amp;&amp; git commit -m&#x27;Update&#x27; &amp;&amp; git push origin HEAD&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> .zshrc <span class="comment">#生效</span></span><br></pre></td></tr></table></figure>



<p>写完博客，运行hexod：</p>
<p><img src="/images/blog-deploy.jpg"></p>
<p>可以看到每次部署博客都进行了两个git repo的push。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://spground.github.io/2018/11/11/lost%20+%20found/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Spground">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spground Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Spground Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/11/11/lost%20+%20found/" class="post-title-link" itemprop="url">博客失而复得</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-11-11 18:07:00" itemprop="dateCreated datePublished" datetime="2018-11-11T18:07:00+08:00">2018-11-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-24 22:30:21" itemprop="dateModified" datetime="2025-09-24T22:30:21+08:00">2025-09-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Misc/" itemprop="url" rel="index"><span itemprop="name">Misc</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>由于之前没有备份hexo博客源码，实验室电脑硬盘卡盘报废后，一度以为博客gg了。今天打开之前的笔记本意外发现9月1日做过一次备份，失而复得的喜悦溢于言表，就此写一篇博文来纪念一下，同时也告诫自己重要的东西要经常备份，做好高可用性。</p>
<p><img src="/images/2017-10-28.jpg"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://spground.github.io/2018/10/15/docker-guide-06-Deploy%20your%20app/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Spground">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spground Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Spground Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/10/15/docker-guide-06-Deploy%20your%20app/" class="post-title-link" itemprop="url">6. Deploy your app</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-10-15 20:00:00" itemprop="dateCreated datePublished" datetime="2018-10-15T20:00:00+08:00">2018-10-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-24 22:30:21" itemprop="dateModified" datetime="2025-09-24T22:30:21+08:00">2025-09-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/docker/" itemprop="url" rel="index"><span itemprop="name">docker</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="6-Deploy-your-app"><a href="#6-Deploy-your-app" class="headerlink" title="6. Deploy your app"></a>6. Deploy your app</h1><p>迭代和删除</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stack deploy -c docker-compose.yml getstartedlab</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stack <span class="built_in">rm</span> getstartedlab</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://spground.github.io/2018/10/15/docker-guide-05-Stacks/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Spground">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spground Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Spground Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/10/15/docker-guide-05-Stacks/" class="post-title-link" itemprop="url">5. Stacks</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-10-15 19:00:00" itemprop="dateCreated datePublished" datetime="2018-10-15T19:00:00+08:00">2018-10-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-24 22:30:21" itemprop="dateModified" datetime="2025-09-24T22:30:21+08:00">2025-09-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/docker/" itemprop="url" rel="index"><span itemprop="name">docker</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="5-Stacks"><a href="#5-Stacks" class="headerlink" title="5. Stacks"></a>5. Stacks</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在第4部分，你已经学会如何配置一个蜂群，蜂群是一个运行着docker的集群，然后你将app部署到这个蜂群上，容器运行在多个机器上。</p>
<p>在第5部分，我们马上介绍分布式应用层级的最上层的概念stack。一个stack是一组共享依赖的内部相关的服务，这些服务能够被一起编排和伸缩。单独的一个stack能够定义和协调整个应用的功能，一些复杂的应用可能需要定义多个stack。</p>
<p>不要慌，从第3部分开始，我们就已经接触到了stack，前面我们创建compose文件，然后运行docker stack deploy，这些都是和stack相关的内容。但是前面我们接触的都是运行在单台机器上的包含单个服务的stack，这个在生产环境中不常见。接下来，运用之前学到的知识，我们来创建多个相关的服务，然后运行在多台机器上。</p>
<h2 id="增加一个Service-重新部署"><a href="#增加一个Service-重新部署" class="headerlink" title="增加一个Service 重新部署"></a>增加一个Service 重新部署</h2><p>修改docker-compose.yml文件很容易添加一个服务。首先我们增加一个免费的可视化服务，这个服务可以让我们看我们的蜂群是如何调度我们的容器的。</p>
<ol>
<li>打开docker-compose.yml文件，修改为如下内容：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&quot;3&quot;</span></span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    <span class="comment"># replace username/repo:tag with your name and image details</span></span><br><span class="line">    image: dockerjie/get-started:part2</span><br><span class="line">    deploy:</span><br><span class="line">      replicas: 5</span><br><span class="line">      resources:</span><br><span class="line">        limits:</span><br><span class="line">          cpus: <span class="string">&quot;0.1&quot;</span></span><br><span class="line">          memory: 50M</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;4000:80&quot;</span></span><br><span class="line">    networks:</span><br><span class="line">      - webnet</span><br><span class="line">  visualizer:</span><br><span class="line">    image: dockersamples/visualizer:stable</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;8080:8080&quot;</span></span><br><span class="line">    volumes:</span><br><span class="line">      - <span class="string">&quot;/var/run/docker.sock:/var/run/docker.sock&quot;</span></span><br><span class="line">    deploy:</span><br><span class="line">      placement:</span><br><span class="line">        constraints: [node.role == manager]</span><br><span class="line">    networks:</span><br><span class="line">      - webnet  </span><br><span class="line">networks:</span><br><span class="line">  webnet:</span><br></pre></td></tr></table></figure>

<p>注意上面有两个新的配置项，volumes，运行可视化服务访问宿主机的Docker的socket文件，placement则确保服务被部署在蜂群管理器swarm manager上面，而不是worker上，因为可视化服务是显示蜂群概览信息的，仅仅管理器才有权限获取到这些信息。</p>
<ol>
<li>确保你的shell连接到myvm1机器上。docker-machine start $(docker-machine ls -q)启动所有机器<ol>
<li>运行docker-machine ls确保你连接到myvm1上。如果出现ip地址对应的cert不对应，则重新运行命令生成cert，docker-machine regenerate-certs $(docker-machine ls -q)</li>
</ol>
</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2018/png/168795/1539420836418-9e3fa932-e4ce-44fa-8372-1d3a8ffa9b85.png" alt="image.png | left | 625x59"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2. 如有必要运行 eval \$(docker-machine env myvm1)</span><br></pre></td></tr></table></figure>



<p><img src="https://cdn.nlark.com/yuque/0/2018/png/168795/1539421054678-b9ed74ba-f5a9-48df-a7f9-cdec97eb1f84.png" alt="image.png | left | 625x72"></p>
<ol>
<li>在蜂窝管理器上重新运行 docker stack deploy</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stack deploy -c docker-compose-yml getstartedlab</span><br></pre></td></tr></table></figure>

<p>部署完成后查看服务：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2018/png/168795/1539423680343-888c4a8e-b9a2-4191-b71e-48dccd8d6889.png" alt="image.png | left | 681x47"></p>
<p>访问可视化服务：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2018/png/168795/1539423713437-0db8df27-530f-4c70-8379-44dd578f126f.png" alt="image.png | left | 681x666"></p>
<p>可以看到两个服务：visualizer和web均已经启动，且web服务的副本数量为5，分布为：</p>
<ul>
<li>myvm1*1</li>
<li>myvm2*2</li>
<li>myvm3*2</li>
</ul>
<p>也可以使用docker命令查看：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stack ps getstartedlab</span><br></pre></td></tr></table></figure>



<p><img src="https://cdn.nlark.com/yuque/0/2018/png/168795/1539423864155-f892f899-dd76-4610-8d1b-4f57001c0b74.png" alt="image.png | left | 681x75"></p>
<h2 id="持久化数据"><a href="#持久化数据" class="headerlink" title="持久化数据"></a>持久化数据</h2><p>到现在为止，我们的web服务中依赖的redis服务还没有配置。</p>
<ol>
<li>修改docker-compose文件，增加redis服务</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&quot;3&quot;</span></span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    <span class="comment"># replace username/repo:tag with your name and image details</span></span><br><span class="line">    image: dockerjie/get-started:part2</span><br><span class="line">    deploy:</span><br><span class="line">      replicas: 5</span><br><span class="line">      resources:</span><br><span class="line">        limits:</span><br><span class="line">          cpus: <span class="string">&quot;0.1&quot;</span></span><br><span class="line">          memory: 50M</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;4000:80&quot;</span></span><br><span class="line">    networks:</span><br><span class="line">      - webnet</span><br><span class="line">  visualizer:</span><br><span class="line">    image: dockersamples/visualizer:stable</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;8080:8080&quot;</span></span><br><span class="line">    volumes:</span><br><span class="line">      - <span class="string">&quot;/var/run/docker.sock:/var/run/docker.sock&quot;</span></span><br><span class="line">    deploy:</span><br><span class="line">      placement:</span><br><span class="line">        constraints: [node.role == manager]</span><br><span class="line">    networks:</span><br><span class="line">      - webnet  </span><br><span class="line">  redis:</span><br><span class="line">    image: redis</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;6379:6379&quot;</span></span><br><span class="line">    volumes:</span><br><span class="line">      - <span class="string">&quot;/home/docker/data:/data&quot;</span></span><br><span class="line">    deploy:</span><br><span class="line">      placement:</span><br><span class="line">        constraints: [node.role == manager]</span><br><span class="line">    <span class="built_in">command</span>: redis-server --appendonly <span class="built_in">yes</span></span><br><span class="line">    networks:</span><br><span class="line">      - webnet</span><br><span class="line">networks:</span><br><span class="line">  webnet:</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>redis有官方的镜像，因此具有一个short name redis。6379是redis容器预先配置的端口，需要对外暴露的，我们也暴露这个端口给宿主机。有两个额外的配置只得注意：</p>
<ul>
<li>redis一直运行在manager上，因此它一直运行在相同的文件系统上，因为是同一个宿主机。</li>
<li>redis访问宿主机上的文件夹作为&#x2F;data目录，redis将数据存储到这里。</li>
</ul>
<p>redis需要持久化数据到容器里的&#x2F;data目录，而容器启动， 停止后，里面的数据都没有了。因此为了持久化数据，需要将容器的某些目录映射到宿主机上，这样数据才会被真正的持久化。</p>
<ol>
<li>在manager宿主机上创建data目录</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine ssh myvm1 <span class="string">&quot;mkdir ./data&quot;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>部署</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stack deploy -c docker-compose.yml getstartedlab</span><br></pre></td></tr></table></figure>



<p><img src="https://cdn.nlark.com/yuque/0/2018/png/168795/1539425828919-4cf6c4b4-9e42-40cc-bfd8-1f9a6575f698.png" alt="image.png | left | 681x61"></p>
<p>查看浏览器验证：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2018/png/168795/1539425867050-37028b3d-04a9-406d-a57c-e9386afef266.png" alt="image.png | left | 747x698"></p>
<p>查看持久化生效：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2018/png/168795/1539425911437-ba23e171-b8b9-4e4b-86a5-6902ba874082.png" alt="image.png | left | 681x214"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://spground.github.io/2018/10/15/docker-guide-04-Swarms/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Spground">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spground Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Spground Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/10/15/docker-guide-04-Swarms/" class="post-title-link" itemprop="url">4. Swarms</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-10-15 18:00:00" itemprop="dateCreated datePublished" datetime="2018-10-15T18:00:00+08:00">2018-10-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-24 22:30:21" itemprop="dateModified" datetime="2025-09-24T22:30:21+08:00">2025-09-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/docker/" itemprop="url" rel="index"><span itemprop="name">docker</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="4-Swarms"><a href="#4-Swarms" class="headerlink" title="4. Swarms"></a>4. Swarms</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在前面的部分，你知道了如何写一个应用以及如何运行在生产环境中，然后将它变为一个服务，在同一个进程中将服务能力伸缩到原来的5倍。</p>
<p>在本部分，你将在集群上部署一个应用，运行在多台机器上。通过将多个机器加入到docker化的集群中，多容器多机器的应用是可能的，这个docker化的集群被称为蜂群。</p>
<h2 id="理解蜂群"><a href="#理解蜂群" class="headerlink" title="理解蜂群"></a>理解蜂群</h2><p>一个蜂群是一组运行docker的机器，组合成了一个集群。在蜂群上，你也可以运行docker命令，但是在集群上，docker命令是被蜂群管理器(swarm manager)执行的。蜂群中的机器可以是物理机，也可以是虚拟机。这些机器加入某个蜂群后，他们被称做节点(node)。</p>
<p>蜂群能使用多种策略来运行容器，例如“emptiest node”，这个策略将首先在资源利用最小的机器上运行容器，还有“global”策略，这个确保每个机器都恰好有一个容器运行。通过Compose文件，你可以指定swarm manager使用何种策略。</p>
<p>蜂群管理器是蜂群中唯一能执行你命令或者授权其他机器加入蜂群的机器。works是那些提供资源但是没有能力指挥其他机器的机器。</p>
<p>到目前为止，你使用docker还都是停留在单机模式。docker也可以切换到swarm模式，该模式下可以组建蜂群。启用swarm模式使得你当前的机器变为一个swarm manager。接下来，Docker将会在整个蜂群上执行你的docker命令，而非你当前的机器上。</p>
<h2 id="设置蜂群"><a href="#设置蜂群" class="headerlink" title="设置蜂群"></a>设置蜂群</h2><p>一个蜂群是由多个节点组成的，这些节点要么是物理的或者虚拟的。使用以下命令启用swarm模式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm init</span><br></pre></td></tr></table></figure>

<p>该命令启用了swarm模式，并把当前机器设置为了swarm manager。<br>对去其他机器，你可以运行如下命令来加入到某个蜂群成为里面的一个worker。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm <span class="built_in">join</span></span><br></pre></td></tr></table></figure>

<p>下面我们使用虚拟机来创建一个包含两个机器的集群，以此来组建一个蜂群。</p>
<h2 id="创建集群"><a href="#创建集群" class="headerlink" title="创建集群"></a>创建集群</h2><p>我们需要一个hypervisor来创建虚拟机，因此安装Oracal VirtualBox。</p>
<p>安装完毕后，我们使用docker-machine来创建3个虚拟机。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker-machine create --driver virtualbox myvm1</span><br><span class="line">docker-machine create --driver virtualbox myvm2</span><br><span class="line">docker-machine create --driver virtualbox myvm3</span><br></pre></td></tr></table></figure>



<p><img src="https://cdn.nlark.com/yuque/0/2018/png/168795/1539073846185-db51f229-5c56-49a8-8977-4be48bbbbd5a.png" alt="image.png | left | 681x463"></p>
<h3 id="列出虚拟机查看对应的IP地址"><a href="#列出虚拟机查看对应的IP地址" class="headerlink" title="列出虚拟机查看对应的IP地址"></a>列出虚拟机查看对应的IP地址</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine <span class="built_in">ls</span></span><br></pre></td></tr></table></figure>



<p><img src="https://cdn.nlark.com/yuque/0/2018/png/168795/1539073913130-21c71a35-7a9f-40c0-9b30-7931883c5e39.png" alt="image.png | left | 681x82"></p>
<p>2376是虚拟机上docker守护进程的端口号。</p>
<h3 id="初始化蜂群，然后增加节点"><a href="#初始化蜂群，然后增加节点" class="headerlink" title="初始化蜂群，然后增加节点"></a>初始化蜂群，然后增加节点</h3><p>我们选择第一台虚拟机作为swarm manager，这台机器执行docker命令和授权其他worker加入到这个蜂群，剩下的两台虚拟机作为worker。</p>
<p>我们可以使用docker-machine ssh到虚拟机上执行shell命令。<br>先连上myvm1虚拟机：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine ssh myvm1 <span class="string">&quot;docker swarm init --advertise-addr 192.168.99.100&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面的命令ssh连接到myvm1，然后执行初始化蜂群的命令。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2018/png/168795/1539074266055-ebc35167-b8a8-46bb-a1a1-f918a3170d4a.png" alt="image.png | left | 681x99"></p>
<p>可以看到myvm1上初始化蜂群成功，且作为了swarm manager，暴露了2377端口用于其他机器与其通信加入蜂群。</p>
<p>接下来我们需要将剩余两台虚拟机作为worker加入到蜂群中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker-machine ssh myvm2 <span class="string">&quot;docker swarm join --token \</span></span><br><span class="line"><span class="string">SWMTKN-1-623gp73gn96xqhjclwob4lipvuis34lnshb0g5c7uu31s5c2sx-f3ux24m2vqdecn29oxurs2kim \</span></span><br><span class="line"><span class="string">192.168.99.100:2377&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker-machine ssh myvm3 <span class="string">&quot;docker swarm join --token \</span></span><br><span class="line"><span class="string">SWMTKN-1-623gp73gn96xqhjclwob4lipvuis34lnshb0g5c7uu31s5c2sx-f3ux24m2vqdecn29oxurs2kim \</span></span><br><span class="line"><span class="string">192.168.99.100:2377&quot;</span></span><br></pre></td></tr></table></figure>



<p><img src="https://cdn.nlark.com/yuque/0/2018/png/168795/1539074535606-c9ade431-b046-49f7-8876-3001b70df865.png" alt="image.png | left | 681x194"></p>
<p>ssh到swarm manager上使用docker node ls查看节点概况，只有是swarm manager才可以使用该命令查看节点概况。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine ssh myvm1 <span class="string">&quot;docker node ls&quot;</span></span><br></pre></td></tr></table></figure>



<p><img src="https://cdn.nlark.com/yuque/0/2018/png/168795/1539074691219-6b60a42e-b1e0-4e3d-8f14-90c3e3368889.png" alt="image.png | left | 681x59"></p>
<h2 id="在蜂群上部署app"><a href="#在蜂群上部署app" class="headerlink" title="在蜂群上部署app"></a>在蜂群上部署app</h2><p>接下来的部署和前面在单机上部署service类似。</p>
<p>上面我们一致通过docker-machine ssh到远程虚拟机上执行shell命令，因此不太方便，现在我们先配置一个docker-machine shell到swarm manager这个远程虚拟机。这样配置好后，就运训使用本地的docker-compose.yml文件来远程部署app了，而不用把这个文件拷贝来拷贝去。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine <span class="built_in">env</span> myvm1</span><br></pre></td></tr></table></figure>



<p><img src="https://cdn.nlark.com/yuque/0/2018/png/168795/1539075290873-80e2bd12-9ada-4441-b8f3-0608a0014deb.png" alt="image.png | left | 681x151"></p>
<p>运行命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span> $(docker-machine <span class="built_in">env</span> myvm1) <span class="comment">#这一步在设置当前shell的环境变量</span></span><br></pre></td></tr></table></figure>

<p>运行docker-machine ls验证一下当前的shell确实是连接到myvm1上的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine <span class="built_in">ls</span></span><br></pre></td></tr></table></figure>



<p><img src="https://cdn.nlark.com/yuque/0/2018/png/168795/1539075432098-08247c2a-61e2-4a7e-82f7-d4e44dcd3e85.png" alt="image.png | left | 681x82"></p>
<h2 id="在swarm-manager上部署app"><a href="#在swarm-manager上部署app" class="headerlink" title="在swarm manager上部署app"></a>在swarm manager上部署app</h2><p>和之前的内容一样，使用docker stack deploy进行部署：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stack deploy -c docker-compose.yml getstartedlab</span><br></pre></td></tr></table></figure>



<p><img src="https://cdn.nlark.com/yuque/0/2018/png/168795/1539075750740-9f2cefe5-23f2-40ae-86c6-c58128e3451a.png" alt="image.png | left | 681x62"></p>
<p>查看部署的结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stack ps getstartedlab</span><br></pre></td></tr></table></figure>



<p><img src="https://cdn.nlark.com/yuque/0/2018/png/168795/1539076046177-4b85d04c-de22-4346-8ff0-534d0099d03c.png" alt="image.png | left | 681x60"></p>
<p>可以看到5个容器实例分散在蜂群中的不同节点上。</p>
<h3 id="访问集群"><a href="#访问集群" class="headerlink" title="访问集群"></a>访问集群</h3><p>web访问一下试试：</p>
<p>使用3个虚拟机的IP地址访问服务：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2018/png/168795/1539076340159-17560546-77a7-45b2-82f0-cf528ef4f027.png" alt="image.png | left | 681x150"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2018/png/168795/1539076373938-619468ed-afc6-464a-860f-87870f9e1d4a.png" alt="image.png | left | 681x162"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2018/png/168795/1539076395411-62135ed3-01d6-4ae8-9030-5d54282611e0.png" alt="image.png | left | 681x170"></p>
<p>不同的IP地址随机出现不同的主机名，表明多容器、多机器集群部署完成。</p>
<p>所有IP地址都能访问部署的app的原因是蜂群中的节点组成了一个ingress网络，构建了一个路由网络。这个保证了部署蜂群上的某个端口上的某个服务，蜂群上的节点都要保留这个端口，无论哪个节点运行容器。下面是一个暴露8080端口的蜂群的网络路由示意图：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2018/png/168795/1539076616110-8a9df5d6-486f-459e-97aa-d21bff33bced.png" alt="image.png | left | 681x303"></p>
<h3 id="迭代和扩容app"><a href="#迭代和扩容app" class="headerlink" title="迭代和扩容app"></a>迭代和扩容app</h3><p>如果需要扩缩容，只需要修改docker-compose文件即可完成。<br>如果需要对app的功能进行迭代，那么需要编码、重新构建、发布新的镜像。最后只需要重新运行docker stack deploy重新部署即可。</p>
<h2 id="清理和重启"><a href="#清理和重启" class="headerlink" title="清理和重启"></a>清理和重启</h2><h3 id="Stacks和Swarms"><a href="#Stacks和Swarms" class="headerlink" title="Stacks和Swarms"></a>Stacks和Swarms</h3><p>拆除部署的stack</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stack <span class="built_in">rm</span> getstartedlab</span><br></pre></td></tr></table></figure>

<h3 id="重置docker-machine-shell变量"><a href="#重置docker-machine-shell变量" class="headerlink" title="重置docker-machine shell变量"></a>重置docker-machine shell变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span> $(docker-machine <span class="built_in">env</span> -u)</span><br></pre></td></tr></table></figure>

<p>重启机器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine start &lt;machine-name&gt;</span><br></pre></td></tr></table></figure>

<h2 id="cheet-sheet"><a href="#cheet-sheet" class="headerlink" title="cheet sheet"></a>cheet sheet</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">docker-machine create --driver virtualbox myvm1 <span class="comment"># Create a VM (Mac, Win7, Linux)</span></span><br><span class="line">docker-machine create -d hyperv --hyperv-virtual-switch <span class="string">&quot;myswitch&quot;</span> myvm1 <span class="comment"># Win10</span></span><br><span class="line">docker-machine <span class="built_in">env</span> myvm1                <span class="comment"># View basic information about your node</span></span><br><span class="line">docker-machine ssh myvm1 <span class="string">&quot;docker node ls&quot;</span>         <span class="comment"># List the nodes in your swarm</span></span><br><span class="line">docker-machine ssh myvm1 <span class="string">&quot;docker node inspect &lt;node ID&gt;&quot;</span>        <span class="comment"># Inspect a node</span></span><br><span class="line">docker-machine ssh myvm1 <span class="string">&quot;docker swarm join-token -q worker&quot;</span>   <span class="comment"># View join token</span></span><br><span class="line">docker-machine ssh myvm1   <span class="comment"># Open an SSH session with the VM; type &quot;exit&quot; to end</span></span><br><span class="line">docker node <span class="built_in">ls</span>                <span class="comment"># View nodes in swarm (while logged on to manager)</span></span><br><span class="line">docker-machine ssh myvm2 <span class="string">&quot;docker swarm leave&quot;</span>  <span class="comment"># Make the worker leave the swarm</span></span><br><span class="line">docker-machine ssh myvm1 <span class="string">&quot;docker swarm leave -f&quot;</span> <span class="comment"># Make master leave, kill swarm</span></span><br><span class="line">docker-machine <span class="built_in">ls</span> <span class="comment"># list VMs, asterisk shows which VM this shell is talking to</span></span><br><span class="line">docker-machine start myvm1            <span class="comment"># Start a VM that is currently not running</span></span><br><span class="line">docker-machine <span class="built_in">env</span> myvm1      <span class="comment"># show environment variables and command for myvm1</span></span><br><span class="line"><span class="built_in">eval</span> $(docker-machine <span class="built_in">env</span> myvm1)         <span class="comment"># Mac command to connect shell to myvm1</span></span><br><span class="line">&amp; <span class="string">&quot;C:\Program Files\Docker\Docker\Resources\bin\docker-machine.exe&quot;</span> <span class="built_in">env</span> myvm1 | Invoke-Expression   <span class="comment"># Windows command to connect shell to myvm1</span></span><br><span class="line">docker stack deploy -c &lt;file&gt; &lt;app&gt;  <span class="comment"># Deploy an app; command shell must be set to talk to manager (myvm1), uses local Compose file</span></span><br><span class="line">docker-machine scp docker-compose.yml myvm1:~ <span class="comment"># Copy file to node&#x27;s home dir (only required if you use ssh to connect to manager and deploy the app)</span></span><br><span class="line">docker-machine ssh myvm1 <span class="string">&quot;docker stack deploy -c &lt;file&gt; &lt;app&gt;&quot;</span>   <span class="comment"># Deploy an app using ssh (you must have first copied the Compose file to myvm1)</span></span><br><span class="line"><span class="built_in">eval</span> $(docker-machine <span class="built_in">env</span> -u)     <span class="comment"># Disconnect shell from VMs, use native docker</span></span><br><span class="line">docker-machine stop $(docker-machine <span class="built_in">ls</span> -q)               <span class="comment"># Stop all running VMs</span></span><br><span class="line">docker-machine <span class="built_in">rm</span> $(docker-machine <span class="built_in">ls</span> -q) <span class="comment"># Delete all VMs and their disk images</span></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://spground.github.io/2018/10/15/docker-guide-03-Services/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Spground">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spground Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Spground Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/10/15/docker-guide-03-Services/" class="post-title-link" itemprop="url">3. Services</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-10-15 17:00:00" itemprop="dateCreated datePublished" datetime="2018-10-15T17:00:00+08:00">2018-10-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-24 22:30:21" itemprop="dateModified" datetime="2025-09-24T22:30:21+08:00">2025-09-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/docker/" itemprop="url" rel="index"><span itemprop="name">docker</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="3-Services"><a href="#3-Services" class="headerlink" title="3. Services"></a>3. Services</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在本部分，我们伸缩我们的应用，并且完成负载均衡功能。为了完成这个，我们必须在前面提到的层级结构中上移一层：service。</p>
<ul>
<li>stack</li>
<li><strong>service</strong></li>
<li>container</li>
</ul>
<h2 id="什么是服务？"><a href="#什么是服务？" class="headerlink" title="什么是服务？"></a>什么是服务？</h2><p>在一个分布式应用中，应用的不同功能部分被称为服务。例如如果你想像一个视频分享网站，它可能包含存储数据在数据库的服务，视频转码的后台服务以及前段用户上传视频的服务。</p>
<p>在docker情景中，简单来说__服务就是生产环境中运行的容器__。一个服务仅仅运行一个镜像，但是它组织镜像如何运行，使用哪个端口，运行多少个副本等等。伸缩一个服务，仅仅需要指定更多的计算资源到每个进程中的服务，从而改变容器实例的数量。</p>
<p>在docker平台上，很容易定义、运行和伸缩服务，通过使用docker-compose.yml文件。</p>
<h2 id="docker-compose-ymls文件"><a href="#docker-compose-ymls文件" class="headerlink" title="docker-compose.ymls文件"></a>docker-compose.ymls文件</h2><p>一个docker-compose.yml文件是一个YAML文件，用来定义生产环境中容器的运行方式。</p>
<p>新建一个docker-compose.yml文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&quot;3&quot;</span></span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    <span class="comment"># replace username/repo:tag with your name and image details</span></span><br><span class="line">    image: dockerjie/get-started:part2</span><br><span class="line">    deploy:</span><br><span class="line">      replicas: 5</span><br><span class="line">      resources:</span><br><span class="line">        limits:</span><br><span class="line">          cpus: <span class="string">&quot;0.1&quot;</span></span><br><span class="line">          memory: 50M</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;4000:80&quot;</span></span><br><span class="line">    networks:</span><br><span class="line">      - webnet</span><br><span class="line">networks:</span><br><span class="line">  webnet:</span><br></pre></td></tr></table></figure>

<p>上面的docker-compose.yml文件描述了：</p>
<ul>
<li>从什么地方去拉取需要的镜像文件</li>
<li>运行含有5个实例的镜像作为一个web服务，限制每个实例使用的cpu比例和内存大小</li>
<li>重启策略：如果容器fail，立即重启该容器。</li>
<li>端口映射：宿主机的4000端口到容器的80端口</li>
<li>构建web服务的容器们共享80端口，通过一个被称为webnet的负载均衡的网络。</li>
<li>使用默认配置定义webnet网络。</li>
</ul>
<h2 id="运行可负载均衡的app"><a href="#运行可负载均衡的app" class="headerlink" title="运行可负载均衡的app"></a>运行可负载均衡的app</h2><p>在使用docker stack deploy命令之前，先运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm init</span><br></pre></td></tr></table></figure>



<p><img src="https://cdn.nlark.com/yuque/0/2018/png/168795/1538980074729-2c871eb7-db40-4d71-a89a-19da7f241fa7.png" alt="image.png | left | 681x102"></p>
<p>现在运行app</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stack deploy -c docker-compose.yml getstartedlab</span><br></pre></td></tr></table></figure>

<p>这个服务stack正在一个宿主机上运行我们部署的镜像的5个容器实例。</p>
<p>查看服务列表：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service <span class="built_in">ls</span></span><br></pre></td></tr></table></figure>



<p><img src="https://cdn.nlark.com/yuque/0/2018/png/168795/1538980316450-4c4d2db1-81c8-4f55-9790-9fb9c03d4a12.png" alt="image.png | left | 681x39"></p>
<p>上面的输出是关于web服务的信息，分别是服务ID，服务名字，模式，副本的数量，镜像以及暴露的端口信息。</p>
<p>运行服务里面的单个容器叫做task。每一个task有一个递增的数字ID。</p>
<p>列出服务包含的tasks。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service ps getstarted_web</span><br></pre></td></tr></table></figure>



<p><img src="https://cdn.nlark.com/yuque/0/2018/png/168795/1538980594067-63659640-6942-4e54-8da7-c8c57626de3b.png" alt="image.png | left | 681x60"></p>
<p>同样的查看容器列表也能观察到web服务包m含的task：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container <span class="built_in">ls</span></span><br></pre></td></tr></table></figure>



<p><img src="https://cdn.nlark.com/yuque/0/2018/png/168795/1538980825620-7503aa0b-85d9-4e3e-8935-beec61199d8c.png" alt="image.png | left | 681x65"></p>
<p>测试效果：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2018/png/168795/1538980859826-af72a019-f5b9-4d33-a8ad-d9accffe8e72.png" alt="image.png | left | 681x192"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2018/png/168795/1538980899519-398a54ef-c42e-43de-adc3-dacad9e96dad.png" alt="image.png | left | 681x171"></p>
<p>可以看到每次访问对应的hostname都不相同，因此部署的web服务已经具有负载均衡的能力。</p>
<h2 id="扩容on-the-fly"><a href="#扩容on-the-fly" class="headerlink" title="扩容on-the-fly"></a>扩容on-the-fly</h2><p>修改docker-compose.yml文件中的replicas的值，重新运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stack deploy -c docker-compose.yml getstartedlab</span><br></pre></td></tr></table></figure>



<p><img src="https://cdn.nlark.com/yuque/0/2018/png/168795/1538981277225-4bf4a4f2-ecf1-4803-89fe-675c140558c6.png" alt="image.png | left | 681x49"></p>
<p>docker执行一个in-place的更新，没必要停止stack或者停止任何容器。</p>
<p>现在重新查看容器列表：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container <span class="built_in">ls</span> -q</span><br></pre></td></tr></table></figure>



<p><img src="https://cdn.nlark.com/yuque/0/2018/png/168795/1538981383650-c138e2bf-2815-4e9c-955f-27ba7ddb5d28.png" alt="image.png | left | 681x203"></p>
<p>同样的，如果我们扩容了，除了容器增加了，服务包含的task也会相应的增加。</p>
<h2 id="停止app和swarm"><a href="#停止app和swarm" class="headerlink" title="停止app和swarm"></a>停止app和swarm</h2><ul>
<li>停止app</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stack  <span class="built_in">rm</span> getstartedlab</span><br></pre></td></tr></table></figure>



<p><img src="https://cdn.nlark.com/yuque/0/2018/png/168795/1538983037754-0e482b9d-ae9a-41ba-a740-2de0eb808c57.png" alt="image.png | left | 636x108"></p>
<ul>
<li>停止swarm</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm leave --force</span><br></pre></td></tr></table></figure>



<p><img src="https://cdn.nlark.com/yuque/0/2018/png/168795/1538983076164-3c943142-e378-48d7-b78d-fe023ee9de7e.png" alt="image.png | left | 576x76"></p>
<p>使用Docker很容易构建app和扩缩容。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker stack <span class="built_in">ls</span>                                            <span class="comment"># List stacks or apps</span></span><br><span class="line">docker stack deploy -c &lt;composefile&gt; &lt;appname&gt;  <span class="comment"># Run the specified Compose file</span></span><br><span class="line">docker service <span class="built_in">ls</span>                 <span class="comment"># List running services associated with an app</span></span><br><span class="line">docker service ps &lt;service&gt;                  <span class="comment"># List tasks associated with an app</span></span><br><span class="line">docker inspect &lt;task or container&gt;                   <span class="comment"># Inspect task or container</span></span><br><span class="line">docker container <span class="built_in">ls</span> -q                                      <span class="comment"># List container IDs</span></span><br><span class="line">docker stack <span class="built_in">rm</span> &lt;appname&gt;                             <span class="comment"># Tear down an application</span></span><br><span class="line">docker swarm leave --force      <span class="comment"># Take down a single node swarm from the manager</span></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Spground</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
