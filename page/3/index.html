<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"spground.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Spground Blog">
<meta property="og:url" content="https://spground.github.io/page/3/index.html">
<meta property="og:site_name" content="Spground Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Spground">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://spground.github.io/page/3/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Spground Blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Spground Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">77</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">11</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">41</span></a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Spground</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">41</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">77</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://spground.github.io/2017/12/03/JVM%20Memory%20Area%20II/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Spground">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spground Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Spground Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/12/03/JVM%20Memory%20Area%20II/" class="post-title-link" itemprop="url">JVM内存区域（二）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-12-03 00:00:00" itemprop="dateCreated datePublished" datetime="2017-12-03T00:00:00+08:00">2017-12-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-24 22:30:21" itemprop="dateModified" datetime="2025-09-24T22:30:21+08:00">2025-09-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="JVM内存区域（二）"><a href="#JVM内存区域（二）" class="headerlink" title="JVM内存区域（二）"></a><code>JVM</code>内存区域（二）</h2><h3 id="1-对象的创建"><a href="#1-对象的创建" class="headerlink" title="1. 对象的创建"></a>1. 对象的创建</h3><h4 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h4><p><code>Java</code>是一种面向对象的语言，在使用<code>java</code>的日常，我们常常和对象打交道。在<code>JVM</code>内存区域中也存在专门的堆内存来存储管理对象。因此就堆内存和对象之间的关系，做简单的阐述。</p>
<p>虚拟机遇到一条<code>new</code>指令后，虚拟机就会新建一个对象，整个过程虚拟机大致会做如下工作：</p>
<ul>
<li>检查对象对应的类是否被加载、解析和初始化过</li>
<li>为对象在堆内存上分配内存</li>
<li>初始化新分配的内存为零值</li>
<li>虚拟机对对象进行必要的设置（信息存放对象头）</li>
</ul>
<p>在上面的工作都完成之后，从虚拟机的角度来看，一个新的对象已经产生了。但从java程序角度来看，对象创建才刚刚开始——<code>&lt;init&gt;</code>方法还没执行，所有的字段都还为零。执行完new指令后接着执行<code>init</code>方法，把对象按照程序员的意图进行初始化，这样一个真正可用对象才算完全产生出来。</p>
<h4 id="1-2"><a href="#1-2" class="headerlink" title="1.2"></a>1.2</h4><p>虚拟机遇到一条<code>new</code>指令后，首先会去检查该对象对应的类是否被加载、解析和初始化过（通常称为类加载过程），如果类没有加载进来，则首先进行类加载。类加载也是一个重要的过程，后面的博客会详细介绍。</p>
<p>在类加载通过虚拟机的检查后，虚拟机会首先在堆内存中为新生对象分配空间。值得注意的是，对象所需要的内存空间大小在类加载后是可以完全确定的（如何确定的本文第2节会介绍）。</p>
<p>在为对象分配堆上内存空间的时候，存在两个主要的问题：</p>
<ul>
<li>a. 内存块连续性的问题</li>
<li>b. 多线程同步的问题</li>
</ul>
<p>a. 线程运行过程中，需要经常向堆内存申请内存分配，但是通常来讲申请的内存需要是连续的（例如新建数组）。内存中有<strong>空闲区</strong>和<strong>占用区</strong>。根据空闲区和占用区的位置之间的不同，可以分为两种内存分配方式：</p>
<ul>
<li>指针碰撞 bump the pointer: 堆内存是规整的，一边是占用区，另一边是空闲区；中间采用指针指示，需要申请新的内存时候，只需要将指示器指针移动一定的距离即可</li>
<li>空闲列表：如果堆内存不是规整的，即占用区和空闲去交错分布；因此通操作系统的存储管理一样，虚拟机需要维护一个空闲去列表记录哪些空闲区可用；在申请内存分配的时候，从空闲区寻找到一个大小合适的区域分配出去。</li>
</ul>
<p>采用何种方式进行内存分配取决于堆内存的规整性；而堆内存的规整性取决于虚拟机采用的垃圾回收算法是否带有压缩整理功能决定的。因此在使用<code>Serial</code>，<code>ParNew</code>等带<code>Compact</code>过程的垃圾回收器，虚拟机内存分配采用<code>bump the pointer</code>;而在使用<code>CMS</code>这种基于<code>Mark-Sweep</code>算法的垃圾回收器时，通常采用空闲列表这种方式。</p>
<p>b. 除了以何种方式从堆内存空间分配空间以外，还存在另一个线程安全的问题；当多个线程申请内存分配的时候，可能虚拟机正在使用内存指针给线程A分配内存的时候，线程B用采用原来的内存指针来进行内存分配了。这是典型的多线程问题，解决方法有两种：</p>
<ul>
<li>对分配内存空间进行同步处理，保证分配操作是线程安全的、原子性的；实际上虚拟机采用的是W<code>CAS</code>（Compare and Set）配上失败重试的方法保证指针更新操作的原子性；</li>
<li>线程封闭的方式；把内存分配的动作按照线程划分在不同的空间中进行，即每个线程在堆中预先分配一小块内存称为本地线程分配缓冲（Thread Local Allocation Buffer TLAB）。哪个线程需要分配内存，就在对应的TLAB上分配，只有TLAB用完并分配新的TLAB的时候，才需要同步锁定。同步需要额外的花销。</li>
</ul>
<h4 id="1-3"><a href="#1-3" class="headerlink" title="1.3"></a>1.3</h4><p>以下代码片段来自于<a href="http://hg.openjdk.java.net/jdk7/jdk7/hotspot/archive/9b0ca45cd756.zip/src/">http://hg.openjdk.java.net/jdk7/jdk7/hotspot/archive/9b0ca45cd756.zip/src/</a>上下载<code>openjdk7</code>的源代码中的<code>bytecodeInterpreter.cpp</code>文件。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">CASE</span>(_new): &#123;<span class="comment">//遇到new指令</span></span><br><span class="line">      u2 index = Bytes::<span class="built_in">get_Java_u2</span>(pc<span class="number">+1</span>);<span class="comment">//根据下一个pc找到一个index，其实就是new SomeClass()中的SomeClass</span></span><br><span class="line">      constantPoolOop constants = istate-&gt;<span class="built_in">method</span>()-&gt;<span class="built_in">constants</span>();<span class="comment">//获取方法区的常量池</span></span><br><span class="line">      <span class="keyword">if</span> (!constants-&gt;<span class="built_in">tag_at</span>(index).<span class="built_in">is_unresolved_klass</span>()) &#123;<span class="comment">//如果需要新建对象的类被解析过</span></span><br><span class="line">        <span class="comment">// Make sure klass is initialized and doesn&#x27;t have a finalizer</span></span><br><span class="line">        oop entry = constants-&gt;<span class="built_in">slot_at</span>(index).<span class="built_in">get_oop</span>();<span class="comment">//根据index在常量池中找到对应oop(ordinary object pointer),oop指向加载解析过的类对象的指针</span></span><br><span class="line">        <span class="built_in">assert</span>(entry-&gt;<span class="built_in">is_klass</span>(), <span class="string">&quot;Should be resolved klass&quot;</span>);</span><br><span class="line">        klassOop k_entry = (klassOop) entry;</span><br><span class="line">        <span class="built_in">assert</span>(k_entry-&gt;<span class="built_in">klass_part</span>()-&gt;<span class="built_in">oop_is_instance</span>(), <span class="string">&quot;Should be instanceKlass&quot;</span>);</span><br><span class="line">        instanceKlass* ik = (instanceKlass*) k_entry-&gt;<span class="built_in">klass_part</span>();</span><br><span class="line">        <span class="keyword">if</span> ( ik-&gt;<span class="built_in">is_initialized</span>() &amp;&amp; ik-&gt;<span class="built_in">can_be_fastpath_allocated</span>() ) &#123;</span><br><span class="line">          <span class="type">size_t</span> obj_size = ik-&gt;<span class="built_in">size_helper</span>();<span class="comment">//确定对象的大小的；第2节会介绍；</span></span><br><span class="line">          oop result = <span class="literal">NULL</span>;</span><br><span class="line">          <span class="comment">// If the TLAB isn&#x27;t pre-zeroed then we&#x27;ll have to do it</span></span><br><span class="line">          <span class="type">bool</span> need_zero = !ZeroTLAB;<span class="comment">//是否需要将内存区域0值化</span></span><br><span class="line">          <span class="keyword">if</span> (UseTLAB) &#123;<span class="comment">//判断是否是TLAB的方式</span></span><br><span class="line">            result = (oop) THREAD-&gt;<span class="built_in">tlab</span>().<span class="built_in">allocate</span>(obj_size);</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">//以下是内存分配多线程同步的CAS加失败重试的方案</span></span><br><span class="line">          <span class="keyword">if</span> (result == <span class="literal">NULL</span>) &#123;<span class="comment">//result为NULl，表示不是采用TLAB解决内存分配多线程的问题</span></span><br><span class="line">            need_zero = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// Try allocate in shared eden</span></span><br><span class="line">            <span class="comment">//直接在堆内存中的eden代中分配</span></span><br><span class="line">      retry:</span><br><span class="line">            HeapWord* compare_to = *Universe::<span class="built_in">heap</span>()-&gt;<span class="built_in">top_addr</span>();</span><br><span class="line">            HeapWord* new_top = compare_to + obj_size;</span><br><span class="line">            <span class="keyword">if</span> (new_top &lt;= *Universe::<span class="built_in">heap</span>()-&gt;<span class="built_in">end_addr</span>()) &#123;</span><br><span class="line">              <span class="comment">//Atomic::cmpxchg_ptr是一个采用CAS的原子操作，用于将compare_to指针更新；</span></span><br><span class="line">              <span class="keyword">if</span> (Atomic::<span class="built_in">cmpxchg_ptr</span>(new_top, Universe::<span class="built_in">heap</span>()-&gt;<span class="built_in">top_addr</span>(), compare_to) != compare_to) &#123;</span><br><span class="line">                <span class="keyword">goto</span> retry;</span><br><span class="line">              &#125;</span><br><span class="line">              result = (oop) compare_to;<span class="comment">//内存分配成功</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (result != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// Initialize object (if nonzero size and need) and then the header</span></span><br><span class="line">            <span class="keyword">if</span> (need_zero ) &#123;</span><br><span class="line">              HeapWord* to_zero = (HeapWord*) result + <span class="built_in">sizeof</span>(oopDesc) / oopSize;</span><br><span class="line">              obj_size -= <span class="built_in">sizeof</span>(oopDesc) / oopSize;</span><br><span class="line">              <span class="keyword">if</span> (obj_size &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">                <span class="built_in">memset</span>(to_zero, <span class="number">0</span>, obj_size * HeapWordSize);<span class="comment">//内存初始化为零</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//以下在设置对象头</span></span><br><span class="line">            <span class="keyword">if</span> (UseBiasedLocking) &#123;<span class="comment">//根据是否启用偏向锁来设置Mark Word</span></span><br><span class="line">              result-&gt;<span class="built_in">set_mark</span>(ik-&gt;<span class="built_in">prototype_header</span>());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              result-&gt;<span class="built_in">set_mark</span>(markOopDesc::<span class="built_in">prototype</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            result-&gt;<span class="built_in">set_klass_gap</span>(<span class="number">0</span>);</span><br><span class="line">            result-&gt;<span class="built_in">set_klass</span>(k_entry);<span class="comment">//设置类信息</span></span><br><span class="line">            <span class="built_in">SET_STACK_OBJECT</span>(result, <span class="number">0</span>);<span class="comment">//将result指针如虚拟机栈中，保存在局部变量表中；</span></span><br><span class="line">            <span class="built_in">UPDATE_PC_AND_TOS_AND_CONTINUE</span>(<span class="number">3</span>, <span class="number">1</span>);<span class="comment">//更新程序计数器，继续下一个操作；</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  	<span class="comment">//如果类没有被解析；则会进行一系列复杂的类加载、内存分配等操作；这是一种较慢的情况；</span></span><br><span class="line">      <span class="comment">// Slow case allocation</span></span><br><span class="line">      <span class="built_in">CALL_VM</span>(InterpreterRuntime::_new(THREAD, METHOD-&gt;<span class="built_in">constants</span>(), index),</span><br><span class="line">              handle_exception);</span><br><span class="line">      <span class="built_in">SET_STACK_OBJECT</span>(THREAD-&gt;<span class="built_in">vm_result</span>(), <span class="number">0</span>);</span><br><span class="line">      THREAD-&gt;<span class="built_in">set_vm_result</span>(<span class="literal">NULL</span>);</span><br><span class="line">      <span class="built_in">UPDATE_PC_AND_TOS_AND_CONTINUE</span>(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="2-对象的内存布局"><a href="#2-对象的内存布局" class="headerlink" title="2. 对象的内存布局"></a>2. 对象的内存布局</h3><p>在<code>HotSpot</code>虚拟机中，对象在内存中存储的布局可以分为3个区域，对象头（Header）、实例数据(Instance Data)和对齐填充(Padding)。</p>
<p><strong>对象头</strong>包含两种信息：</p>
<ul>
<li><p>第一部分用于存储对象本身的运行时数据。如哈希码、<code>GC</code>分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等；这部分数据的长度在32bit(32位虚拟机)或者64bit(64位虚拟机)，被称为”Mark Word”。根据对象所处的状态不同，Mark Word存储的内容也不同；</p>
</li>
<li><p>第二部分是类型指针，即对象指向它的类元数据的指针，虚拟机可以通过这个来确定对象是那个类的实例。（并不是所有的虚拟机实现都必须在对象数据上保留类型指针，也就是查找对象的类元数据并非一定要经过对象本身，第3节介绍的基于句柄方式的对象定位，就不要通过对象而可以找到对应的类元数据） ​</p>
</li>
</ul>
<p>另外如果对象是一个<code>Java</code>数组的话，还需要在对象头必须有一块用于记录数组长度的数据，因为虚拟机需要通过对象的元数据信息确定对象的大小，而从类元数据中却无法确定数组的大小。</p>
<p><strong>实例数据</strong>存放了对象真正意义上的有效信息，也就是程序中定义的各类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录下来。</p>
<p><strong>对齐填充</strong>并不是必然存在的，由于<code>HotSpot</code>的自动内存管理系统要求对象的起始地址必须是8字节的整数倍，也就是说对象的大小必须是8字节的整数倍，因此当对象实例数据部分没有对齐的时候，就需要对其填充来补全。</p>
<h3 id="3-对象的访问定位"><a href="#3-对象的访问定位" class="headerlink" title="3. 对象的访问定位"></a>3. 对象的访问定位</h3><p>在<code>java</code>语言规范中，<code>java</code>需要通过虚拟机栈上的<code>reference</code>数据来操作堆上的具体对象。在虚拟机规范中，由于<code>reference</code>类型只是一个指向对象的引用，并没有定义如何通过这种引用去定位、方位堆上的对象的具体位置。目前主流的访问方式有使用<strong>句柄</strong>和<strong>直接指针</strong>两种</p>
<ul>
<li>句柄方式；堆上会划分一块内存作为句柄池，引用存储的是对象在句柄池中的句柄地址，而句柄中包含了对象和其对应的类型数据各具体信息的地址信息；</li>
<li>直接地址；引用存储的直接就是对象的堆内存地址，而采用这种方式的话，对象中必须要设置如何访问对应的类型数据的相关信息；</li>
</ul>
<p>各自的优缺点如下：</p>
<p>句柄方式</p>
<ul>
<li>优点：句柄方式在对象被移动时（GC时移动对象是非常普遍的）只改变句柄中的实例数据指针，而引用本身不用改变</li>
<li>缺点：中间加了一层，访问变慢；</li>
</ul>
<p>直接指针：</p>
<ul>
<li>优点：访问速度快</li>
<li>缺点：对象频繁移动，对引用的修改</li>
</ul>
<hr>
<p>参考：《深入理解Java虚拟机》</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://spground.github.io/2017/12/01/JVM%20Memory%20Area%20I/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Spground">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spground Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Spground Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/12/01/JVM%20Memory%20Area%20I/" class="post-title-link" itemprop="url">JVM 内存区域（一）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-12-01 00:00:00" itemprop="dateCreated datePublished" datetime="2017-12-01T00:00:00+08:00">2017-12-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-24 22:30:21" itemprop="dateModified" datetime="2025-09-24T22:30:21+08:00">2025-09-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="JVM内存区域（一）"><a href="#JVM内存区域（一）" class="headerlink" title="JVM内存区域（一）"></a><code>JVM</code>内存区域（一）</h1><h3 id="1-运行时内存区域分类"><a href="#1-运行时内存区域分类" class="headerlink" title="1. 运行时内存区域分类"></a>1. 运行时内存区域分类</h3><p><code>JVM</code>运行时内存区域主要包含：</p>
<ul>
<li>程序计数器</li>
<li>栈</li>
<li>堆</li>
<li>方法区<br>  其中属于线程私有的是<strong>程序计数器</strong>、<strong>栈</strong>；属于共享的是<strong>堆</strong>，<strong>方法区</strong>。</li>
</ul>
<h3 id="2-运行时内存区域含义"><a href="#2-运行时内存区域含义" class="headerlink" title="2. 运行时内存区域含义"></a>2. 运行时内存区域含义</h3><ul>
<li><p>程序计数器</p>
<p>程序计数器是一块较小的内存空间，他可以当做当前线程执行的字节码的行号指示器。</p>
</li>
<li><p>栈</p>
<ul>
<li><p><code>java</code>虚拟机栈    </p>
<p>和大多数程序语言一样，每个<code>java</code>方法在<code>jvm</code>解释执行时都会创建一个栈帧存储<strong>局部变量</strong>、<strong>操作数栈</strong>、<strong>动态链接</strong>、<strong>方法出口信息</strong>。 ​<br>每一个方法的调用到执行返回，都对应一个栈帧在虚拟机栈中入栈和出栈的过程。<br><strong>局部变量表</strong>存放了编译时期确定的各种<strong>基本数据类型</strong>（boolean、byte、char、short、int、float、long、double）、<strong>对象引用类型</strong>（reference类型）。其中long和double会占据两个局部变量槽（slot）,其余的占据一个slot</p>
</li>
<li><p>本地方法栈</p>
<p>本地方法调用形成的栈，类似于java虚拟机栈；</p>
</li>
</ul>
</li>
<li><p>堆</p>
<p>所有的对象实例以及数组都要在堆上分配。</p>
</li>
<li><p>方法区</p>
<p>和堆内存一样，是各个线程共享的内存区域，用于存储已经被虚拟机加载的<strong>类信息，常量，静态变量，即时编译器编译后的代码</strong>等数据。</p>
<ul>
<li><p>运行时常量池（runtime constant pool）</p>
<p>运行时常量池是方法区的一部分。<code>Class</code>文件里面除了包含类版本、字段、方法、接口等描述信息外，还有一项就是<strong>常量表（符号表 constant pool table）</strong>，用于存放<strong>编译时期</strong>（源码到字节码）产生的各种<strong>字面量和符号引用</strong>，例如 <code>public int a = 2</code>中的<code>a</code>，这部分内容在类加载后会进入方法区的<strong>运行时常量池</strong>。<br>运行时常量池相对于<code>class</code>文件的常量表的区别：</p>
<ul>
<li>常量表必须符合<code>class</code>文件严格的规范才会被虚拟机加载；而运行时常量池则是由不同的虚拟机厂商自由发挥实现的；</li>
<li>运行时常量池具有<strong>动态性</strong>，常量并非只有在编译时期产生，也就是并非置入class文件中常量表的内容才能进入方法区中的运行时常量池，运行期间也可能有新的常量进入池中，这种特性就是常用的<code>string.inter()</code>方法。</li>
</ul>
</li>
</ul>
</li>
<li><p>直接内存（Direct Memory）</p>
<p>直接内存不是虚拟机运行时数据的一部分，<code>java</code>语言提供一些接口能够使用<code>native</code>函数直接分配堆外内存（通常意义下虚拟机管理的内存以外的内存），参见<code>NIO</code>。</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://spground.github.io/2017/09/30/Union-Find%20algorithm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Spground">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spground Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Spground Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/09/30/Union-Find%20algorithm/" class="post-title-link" itemprop="url">Union-Find算法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-09-30 00:00:00" itemprop="dateCreated datePublished" datetime="2017-09-30T00:00:00+08:00">2017-09-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-24 22:30:21" itemprop="dateModified" datetime="2025-09-24T22:30:21+08:00">2025-09-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p><code>Union-Find</code>算法又称并查集算法，是一种作用于<code>并查集</code>数据结构的算法。包含两个主要的操作：</p>
<ul>
<li><code>Find</code> 用于查找某个元素属于哪个集合，可以用来确定两个元素是否在同一个集合中；</li>
<li><code>Union</code> 用于合并两个不同的集合；</li>
</ul>
<h2 id="2-原理"><a href="#2-原理" class="headerlink" title="2.原理"></a>2.原理</h2><p>并查集数据结构是一种树形结构，树形结构对于有规律的数据组织方式，进行修改和查找十分高效。<br>具体结构如下图一所示：</p>
<p align="center">
  <img src="http://img.blog.csdn.net/20171120115417274?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDUzMjkwMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/>
  <P align="center">图一</p>
</p>

<br/>

<p align="center">
  <img src="http://img.blog.csdn.net/20171120115447499?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDUzMjkwMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/>
  <P align="center">图二</p>
</p>

<p>图一展示了并查集的树形结构，每一棵独立的树都代表一个独立的集合，在同一棵树下的所有节点自然就是属于同一个集合。<br>图二表示了并查集的存储结构，并查集数据结构采用数据对树进行存储，元素<code>i</code>的值<code>id[i]</code>存储的是其在树形结构上对应的<strong>父节点</strong>的标号，而根节点元素<code>root</code>的值<code>id[root]</code>是本身的标号，即<code>root = id[root]</code>;</p>
<p>有了上述的树形结构和数据的组织形式后，一些基本的操作就变得简单了。</p>
<ul>
<li><code>root(x)</code> 返回元素<code>x</code>所在树的根节点，从当前元素<code>x</code>的父节点<code>id[i]</code>不断的向上递推求父节点，直到<code>id[i] == i</code>成立。</li>
<li><code>connected(x, y)</code>判断<code>x</code>和<code>y</code>元素是否是连通的（直接或间接）,只需要判断两个节点是否有相同的根节点（即是否在同一棵树中）；</li>
<li><code>count(x)</code> 获取元素<code>x</code>所在集合（树）的元素（节点）的个数,以根节点来分别统计每棵树的节点的数目；</li>
<li><code>find(x)</code> 返回元素<code>x</code>的根节点</li>
<li><code>union(x,y)</code> 将元素<code>x</code>和<code>y</code>连通，将<code>x</code>所在的树的拼接到<code>y</code>所在树种，（反之亦可）即将<code>x</code>的根节点父节点设置为<code>y</code>的根节点。</li>
</ul>
<p>上述的操作基本上覆盖了并查集数据结构以及算法中的大部分操作，由此可以写出一个基本的并查集算法雏形：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span>[] id;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">		id = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">			id[i] = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">connected</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> root(i) == root(j);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="title function_">root</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">		<span class="type">int</span> root;</span><br><span class="line">		<span class="keyword">while</span> ((root = id[i]) != i)</span><br><span class="line">			i = id[i];	</span><br><span class="line">		<span class="keyword">return</span> root;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> root(i);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">		<span class="type">int</span> rootI, rootJ;</span><br><span class="line">		<span class="keyword">if</span> ((rootI = root(i)) == (rootJ = root(j)))</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">     id[rootI] = rootJ;<span class="comment">//将i节点所在树移接到j节点所在树</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		Map&lt;Integer, List&lt;Integer&gt;&gt; group = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="built_in">this</span>.id.length; i++) &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">root</span> <span class="operator">=</span> root(i);</span><br><span class="line">			<span class="keyword">if</span> (group.get(root) == <span class="literal">null</span>) &#123;</span><br><span class="line">				List&lt;Integer&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">				tmp.add(i);</span><br><span class="line">				group.put(root, tmp);</span><br><span class="line">			&#125; <span class="keyword">else</span> </span><br><span class="line">				group.get(root).add(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> group.toString();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-改进"><a href="#3-改进" class="headerlink" title="3.改进"></a>3.改进</h2><p>对上述<code>Union-Find</code>的两个主要操作<code>find</code>和<code>union</code>的时间复杂度进行分析易得出</p>
<ul>
<li>union(i,j) — O(1)</li>
<li>find(i) — O(h) 其中h是节点<code>i</code>所在树的高度</li>
</ul>
<p>由于在进行对两个节点进行<code>union</code>操作的时候，我们总是不加选择的将节点<code>i</code>所在的树拼接到节点<code>j</code>所在的树下，这样可能会导致某一棵树特别的<strong>瘦高</strong>，即其<code>h</code>很大，几乎可以接近于<code>n</code>，从而可能导致<code>find</code>操作可能需要遍历整个集合。</p>
<p align="center">
  <img src="http://img.blog.csdn.net/20171120115528182?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDUzMjkwMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/>
  <P align="center">图三</p>
</p>

<p>由于这个原因，我们需要不断的调整树，使其变得稍微<strong>矮胖</strong>一些，如图四。</p>
<p align="center">
  <img src="http://img.blog.csdn.net/20171120115617437?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDUzMjkwMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/>
  <P align="center">图四</p>
</p>

<p>为了将树摊平，存在两个改进的地方：</p>
<ul>
<li><p>带权的<code>union</code>操作  即在进行<code>union</code>操作的时候，可以先判断节点所在树的大小，将size小的树接到size大的树；</p>
</li>
<li><p>路径压缩 即在进行<code>find</code>操作的时候，在找到根节点后，循环将该路径下的所有节点都拼接到根节点下，如图五所示；</p>
<p>​</p>
</li>
</ul>
<p align="center">
  <img src="http://img.blog.csdn.net/20171120115646901?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDUzMjkwMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/>
  <P align="center">图五</p>
</p>


<p align="center">
  <img src="http://img.blog.csdn.net/20171120115718144?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDUzMjkwMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/>
  <P align="center">图六</p>
</p>

<p>改进后<code>union-find</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> Map&lt;Integer, Integer&gt; memSize;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span>[] id;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">		memSize = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">		id = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">			id[i] = i;</span><br><span class="line">			memSize.put(i, <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">connected</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> root(i) == root(j);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="title function_">root</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">		<span class="type">int</span> root;</span><br><span class="line">		<span class="keyword">while</span> ((root = id[i]) != i) &#123;</span><br><span class="line">			<span class="comment">//优化二：路径压缩，将当前非root节点i 拼接到爷节点下面，将爷节点作为自己的父节点</span></span><br><span class="line">			<span class="comment">//这样为后续查找节点i的root节点压缩路径深度，节约了时间。</span></span><br><span class="line">			id[i] = id[id[i]];</span><br><span class="line">			i = id[i];	</span><br><span class="line">		&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//或者另一种路径压缩方式</span></span><br><span class="line">    <span class="comment">/* while (id[i] != i) &#123;</span></span><br><span class="line"><span class="comment">      id[i] = root;</span></span><br><span class="line"><span class="comment">      i = id[i];</span></span><br><span class="line"><span class="comment">    &#125; */</span></span><br><span class="line">    </span><br><span class="line">		<span class="keyword">return</span> root;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> root(i);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">		<span class="type">int</span> rootI, rootJ;</span><br><span class="line">		<span class="keyword">if</span> ((rootI = root(i)) == ( rootJ = root(j)))</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		<span class="type">int</span> iSize, jSize;</span><br><span class="line">		<span class="comment">//优化一：带权union, 小树接大树，避免新树过高；</span></span><br><span class="line">		<span class="keyword">if</span> ((iSize = memSize.get(rootI)) &gt; (jSize = memSize.get(rootJ))) &#123;</span><br><span class="line">			id[rootJ] = rootI;</span><br><span class="line">			memSize.put(rootI, iSize + jSize);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			id[rootI] = rootJ;</span><br><span class="line">			memSize.put(rootJ, iSize + jSize);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		Map&lt;Integer, List&lt;Integer&gt;&gt; group = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="built_in">this</span>.id.length; i++) &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">root</span> <span class="operator">=</span> root(i);</span><br><span class="line">			<span class="keyword">if</span> (group.get(root) == <span class="literal">null</span>) &#123;</span><br><span class="line">				List&lt;Integer&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">				tmp.add(i);</span><br><span class="line">				group.put(root, tmp);</span><br><span class="line">			&#125; <span class="keyword">else</span> </span><br><span class="line">				group.get(root).add(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> group.toString();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4-应用"><a href="#4-应用" class="headerlink" title="4.应用"></a>4.应用</h2><ul>
<li>Percolation.</li>
<li>Games (Go, Hex).</li>
<li>Dynamic connectivity.</li>
<li>Least common ancestor.</li>
<li>Equivalence of finite state automata.</li>
<li>Hoshen-Kopelman algorithm in physics.</li>
<li>Hinley-Milner polymorphic type inference.</li>
<li>Kruskal’s minimum spanning tree algorithm.</li>
<li>Compiling equivalence statements in Fortran.</li>
<li>Morphological attribute openings and closings.</li>
<li>Matlab’s bwlabel() function in image processing.</li>
</ul>
<h2 id="5-References"><a href="#5-References" class="headerlink" title="5.References"></a>5.References</h2><p>[1] Algorithms - Robert Sedgewick, Kevin Wayne</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://spground.github.io/2017/08/04/IO%20model/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Spground">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spground Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Spground Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/08/04/IO%20model/" class="post-title-link" itemprop="url">IO模型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-08-04 20:41:00" itemprop="dateCreated datePublished" datetime="2017-08-04T20:41:00+08:00">2017-08-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-24 22:30:21" itemprop="dateModified" datetime="2025-09-24T22:30:21+08:00">2025-09-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">编程基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-IO复用"><a href="#1-IO复用" class="headerlink" title="1. IO复用"></a>1. IO复用</h2><blockquote>
<p>进程需要这样一种功能：内核一旦发现进程指定的一个或多个IO条件（事件）就绪（输入准备好被读取或者输出准备好被输出），它通知进程，这个就叫做I&#x2F;O复用。</p>
</blockquote>
<p>IO复用的典型使用场景</p>
<ul>
<li><p>客户处理多个描述符号（通常是交互式输入和网络套接字）时候，必须使用I&#x2F;O复用，例如实际的网络聊天，进程既要等待用户的输入，又要处理来自网络套接字的输入，采用I&#x2F;O复用可以大幅度提高并发度和节省资源；</p>
</li>
<li><p>TCP服务器既要处理监听套接字，又要处理已经连接的套接字，这时候需要I&#x2F;O复用以提高并发性能；实际上常见的并发连接的客户数多，但是每个连接的任务轻（CPU时间短）比如多人在线聊天室；连接并发数多，但是每个连接不都是长期处于活跃状态，可能是偶尔I&#x2F;O一些数据，这时候需要I&#x2F;O复用，让系统别被这些Lazy的客户端拖垮；</p>
</li>
<li><p>如果一个服务器需要同时处理多个服务或协议，一般使用IO复用；</p>
</li>
</ul>
<p>其实，不难看出I&#x2F;O复用的目的是为了让计算机的资源得到尽可能最大化的利用，提高并行化程度达到这种目的的一种有效途径。</p>
<p>I&#x2F;O复用在某种程度上和操作系统的<strong>中断处理机制</strong>何其的相似。</p>
<p>操作系统作为计算机的核心软件，管理着众多的硬件设备，具有极大的并发性能，我们可以同时听音乐，同时拷文件，同时跑程序等等；如此高的并发能力得益与中断机制给操作系统带来的<strong>异步能力</strong>，当某个硬件设备特定的事件发生时（比如磁盘就绪），就引发一个硬件中断，操作系统能捕获到这些中断，将当前运行的进程挂起，然后转而执行该中断对应的中断处理程序。</p>
<p>这种机制有点<strong>贪心</strong>的思想，操作系统总是尽可能的少等待，有活就干，没活就离开；这种机制中，众多硬件设备就类似与IO复用里面的众多<strong>Lazy</strong>的客户，他们需要与服务器（这里是操作系统）保持连接（做到随叫随到），但是又总是需要操作系统。中断是操作系统运行的动力源泉，这是一个典型的异步模型。<strong>I&#x2F;O复用依赖于内核提供的异步能力</strong>，其抽象程度与操作系统和硬件设备的模型相似，这样能充分利用计算机的资源（<strong>软件充分利用操作系统，操作系统充分利用硬件</strong>）。</p>
<h2 id="2-I-O模型"><a href="#2-I-O模型" class="headerlink" title="2. I&#x2F;O模型"></a>2. I&#x2F;O模型</h2><ul>
<li>阻塞IO</li>
<li>非阻塞IO</li>
<li>IO复用</li>
<li>信号驱动IO</li>
<li>异步IO</li>
</ul>
<p>应用程序典型的I&#x2F;O包含<strong>两个不同的阶段：</strong></p>
<p>以输入为例</p>
<ol>
<li><strong>IO请求就绪阶段</strong> 应用程序向内核发出请求，检查硬件设备是否准备好数据（例如等待数据从网络到达、用户键盘敲击）；若硬件设备就绪，产生中断； </li>
<li><strong>IO实际读写阶段</strong> 内核捕获处理中断，然后内核空间将数据拷贝到用户的进程空间中，CPU切换到用户态；</li>
</ol>
<p>这两个阶段的产生主要是由于计算机目前的体系结构决定的（最顶层用户程序运行在用户态，中间层内核工作在内核态，最底层是硬件）；这两个阶段都有可能产生阻塞，在内核与硬件之间，应付这种阻塞采用了基于事件的中断机制以提高并发性；而在内核与用户进程之间，异步IO机制也将为用户进程并发程度提高带来曙光。</p>
<h3 id="2-1-阻塞IO"><a href="#2-1-阻塞IO" class="headerlink" title="2.1 阻塞IO"></a>2.1 阻塞IO</h3><p>最普遍的IO模型都是阻塞模型，这种模型在IO的的第一阶段（向内核发出I&#x2F;O请求的系统调用）时，被阻塞直到<strong>I&#x2F;O就绪</strong>，再执行实际<strong>I&#x2F;O操作</strong>；</p>
<h3 id="2-2-非阻塞IO"><a href="#2-2-非阻塞IO" class="headerlink" title="2.2 非阻塞IO"></a>2.2 非阻塞IO</h3><p>进程通知内核，进程所发起的<strong>IO请求</strong>在<strong>I&#x2F;O未就绪</strong>的条件下，也不能把进程阻塞（挂起），而是返回一个错误；该模型可能需要进程不断的去轮询某个<code>FD</code>是否<code>IO</code>就绪，这样的轮询模型比较少见，轮询会额外的浪费大量的<code>CPU</code>资源。</p>
<h3 id="2-3-IO复用"><a href="#2-3-IO复用" class="headerlink" title="2.3 IO复用"></a>2.3 IO复用</h3><p>该模型本质上属于非阻塞模型I&#x2F;O，常见的是<code>select</code>和<code>poll</code>机制。对于普通的非阻塞模型，一个进程或者线程始终轮询同一个<code>FD</code>，这样效率较低，特别是对于同时需要处理很多FD的程序；</p>
<p>而IO复用模型，可以让进程或者线程<strong>同时</strong>管理（轮询）<strong>多个FD</strong>，以<code>select</code>为例，<code>select</code>能够管理许多<code>FD</code>上的不同事件，<code>select</code>调用在所有<code>FD</code>都没有<code>IO</code>事件(就绪、可读、可写等)产生时会阻塞，虽然<code>select</code>调用会阻塞，但是其管理轮询的<code>FD</code>不是阻塞的，因此该模型依然算是<strong>非阻塞IO模型</strong>；</p>
<p>该模型通常和<strong>阻塞IO模型+多线程</strong>作对比，在典型的<code>socket</code>服务器端，该模型和<strong>阻塞IO模型+多线程</strong>可以实现相同的功能，大多数情况下效果性能也不会差太离谱；</p>
<p>但是考虑在某些特定的场景下，例如客户端连接数目众多，但是每个连接今次进行IO次数比较多，IO的数据比较少（典型的就是多人在线聊天，大量的客户端同服务器保持连接，但是每一个连接“走走停停”，隔一会来几个字节的数据），在<strong>阻塞IO模型+多线程</strong>模型中，每一个连接对应于一个线程，大量的长连接会很快<strong>消耗掉</strong>计算机中（也可能是<strong>线程池</strong>）中所有线程资源，从而拒绝了额外的新的客户连接请求，但是此时计算机的CPU却是闲置的，因为很多线程其实是在阻塞状态，因此这种场景下，该模型没有很好的提高系统的并发性；</p>
<p>而采用<strong>I&#x2F;O复用</strong>模型，用一个或多个线程去select或者poll检查多个连接上的IO事件，当IO事件(可读、可写等)发生，就利用新开线程池中的线程来处理IO，由于每一次的IO的任务很轻，并且IO数据已经来到了内核或者进程的缓冲区，这样新开的线程很快就会被线程池回收，这样当新来的客户连接请求进来，系统仍然有足够的线程资源来处理请求，极大的提高了该场景下系统的吞吐量，<strong>IO复用模型</strong>要远优于<strong>阻塞IO模型+多线程</strong>；</p>
<p>实际应用中，辨证的选择<strong>IO复用模型</strong>和<strong>阻塞IO模型+多线程</strong>。</p>
<h3 id="2-4-信号驱动IO"><a href="#2-4-信号驱动IO" class="headerlink" title="2.4 信号驱动IO"></a>2.4 信号驱动IO</h3><p>进程不会阻塞在第一阶段，当IO就绪时，内核会通过信号的形式通知进程；</p>
<h3 id="2-5-异步IO"><a href="#2-5-异步IO" class="headerlink" title="2.5 异步IO"></a>2.5 异步IO</h3><p>进程在整个IO过程（IO请求和IO读写阶段）都不会阻塞，而是在IO完成后由内核通知进程；</p>
<h3 id="2-6-同步IO与异步IO"><a href="#2-6-同步IO与异步IO" class="headerlink" title="2.6 同步IO与异步IO"></a>2.6 同步IO与异步IO</h3><p>在某些术语中，阻塞和非阻塞用于区分IO的第一个阶段，即IO的<strong>请求阶段</strong>；<br>同步和异步用于区分IO的第二个阶段，即IO的<strong>读写阶段</strong>；</p>
<p>因此，按照这个来重新分类上述五种IO模型，就可以分为</p>
<ul>
<li><p><strong>同步IO</strong></p>
<ul>
<li>阻塞IO <em>(最普遍的同步阻塞BIO)</em></li>
<li>非阻塞IO <em>（Java NIO， 需要轮询，不停的轮询某个FD是否就绪）</em></li>
<li>IO复用 <em>(Java NIO的Select机制，同时监听多个FD，虽然单个FD不阻塞，但是当所有FD都没有就绪时，select调用会阻塞；一个阻塞换来多个不阻塞)</em></li>
<li>信号驱动IO <em>(同同步非阻塞IO，不用轮询，而是直接接收内核发来的IO信号)</em></li>
</ul>
</li>
<li><p><strong>异步IO</strong>  <em>（Java AIO， IO的两个阶段都不会阻塞，进程只需要发起IO请求，在IO完成两个阶段后，由内核负责通知进程，期间进程都不会挂起）</em></p>
</li>
</ul>
<h3 id="2-7-5种IO模型的Java示例"><a href="#2-7-5种IO模型的Java示例" class="headerlink" title="2.7 5种IO模型的Java示例"></a>2.7 5种IO模型的Java示例</h3><ul>
<li>（1）阻塞IO + 多线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> iomodel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.Reader;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BIODemo</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="type">Executor</span> <span class="variable">pools</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="type">ServerSocket</span> <span class="variable">sS</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line">			<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">				<span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> sS.accept();<span class="comment">//blocking</span></span><br><span class="line">				pools.execute(<span class="keyword">new</span> <span class="title class_">BIOWorker</span>(s));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BIOWorker</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">	<span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">BIOWorker</span><span class="params">(Socket client)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.client = client;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="type">BufferedReader</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(client.getInputStream()));</span><br><span class="line">			<span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">			<span class="keyword">while</span> ((line = is.readLine()) != <span class="literal">null</span>)<span class="comment">//blocking</span></span><br><span class="line">				System.out.println(line);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>（2）非阻塞IO模型</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> iomodel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.CharsetDecoder;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NBIODemo</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="type">Charset</span> <span class="variable">ascii</span> <span class="operator">=</span> Charset.forName(<span class="string">&quot;us-ascii&quot;</span>);</span><br><span class="line">			<span class="type">CharsetDecoder</span> <span class="variable">decoder</span> <span class="operator">=</span> ascii.newDecoder();</span><br><span class="line">			<span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">			ssc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">			<span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> ssc.socket();</span><br><span class="line">			ss.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8888</span>));</span><br><span class="line"></span><br><span class="line">			<span class="type">SocketChannel</span> <span class="variable">sC</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">while</span> ((sC = ssc.accept()) == <span class="literal">null</span>)</span><br><span class="line">				System.out.println(<span class="string">&quot;i am pooling for new connection!&quot;</span>);<span class="comment">// poll until new connection was established.non-blocking</span></span><br><span class="line">			sC.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">			<span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">		</span><br><span class="line">			<span class="keyword">while</span> (<span class="literal">true</span>) &#123;<span class="comment">//pool for reading</span></span><br><span class="line">				<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> sC.read(buffer);<span class="comment">//non-blocking</span></span><br><span class="line">				System.out.println(<span class="string">&quot;i am pooling for new data!&quot;</span>);</span><br><span class="line">				<span class="keyword">if</span> (r &gt; <span class="number">0</span>) &#123;</span><br><span class="line">					buffer.flip();</span><br><span class="line">					System.err.println(<span class="string">&quot;recv &quot;</span> + r +<span class="string">&quot; bytes from &quot;</span> + sC);</span><br><span class="line">					System.err.print(decoder.decode(buffer));</span><br><span class="line">					buffer.compact();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>（3）I&#x2F;O复用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> iomodel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.CharsetDecoder;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiplexingIODemo</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="type">Executor</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">			<span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">			ssc.configureBlocking(<span class="literal">false</span>);<span class="comment">// listening socket channel is</span></span><br><span class="line">											<span class="comment">// non-blocking for accept()</span></span><br><span class="line"></span><br><span class="line">			<span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> ssc.socket();</span><br><span class="line">			ss.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8888</span>));</span><br><span class="line"></span><br><span class="line">			ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (;;) &#123;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// System.out.println(&quot;I am selecting..&quot;);</span></span><br><span class="line">				selector.select();<span class="comment">// may block until there occurred at least one</span></span><br><span class="line">									<span class="comment">// IO event.</span></span><br><span class="line"></span><br><span class="line">				Set&lt;SelectionKey&gt; selectKeys = selector.selectedKeys();</span><br><span class="line">				Iterator&lt;SelectionKey&gt; iterator = selectKeys.iterator();</span><br><span class="line"></span><br><span class="line">				<span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">					<span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">					<span class="keyword">if</span> ((key.readyOps() &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT) &#123;</span><br><span class="line">						<span class="type">ServerSocketChannel</span> <span class="variable">ssc1</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">						<span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> ssc1.accept();</span><br><span class="line">						sc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">						sc.register(selector, SelectionKey.OP_READ);</span><br><span class="line">						iterator.remove();</span><br><span class="line">						System.out.println(<span class="string">&quot;Got connection from &quot;</span> + sc);</span><br><span class="line">					&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((key.readyOps() &amp; SelectionKey.OP_READ) == SelectionKey.OP_READ) &#123;</span><br><span class="line">						<span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">						<span class="keyword">if</span> (key.attachment() == <span class="literal">null</span>) &#123;</span><br><span class="line">							<span class="type">ByteBuffer</span> <span class="variable">buff</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">							key.attach(buff);</span><br><span class="line">							System.out.println(<span class="string">&quot;first recv data from &quot;</span> + sc);</span><br><span class="line">						&#125;</span><br><span class="line">						pool.execute(<span class="keyword">new</span> <span class="title class_">IOWorker</span>(sc, (ByteBuffer) key.attachment()));</span><br><span class="line">						iterator.remove();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IOWorker</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">	<span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="type">SocketChannel</span> <span class="variable">sC</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="type">Charset</span> <span class="variable">gb2312</span> <span class="operator">=</span> Charset.forName(<span class="string">&quot;gb2312&quot;</span>);</span><br><span class="line">	<span class="type">CharsetDecoder</span> <span class="variable">decoder</span> <span class="operator">=</span> gb2312.newDecoder();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">IOWorker</span><span class="params">(SocketChannel sC, ByteBuffer buffer)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.sC = sC;</span><br><span class="line">		<span class="built_in">this</span>.buffer = buffer;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="type">int</span> r;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			r = <span class="built_in">this</span>.sC.read(buffer);</span><br><span class="line">			<span class="keyword">if</span> (r &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				System.err.println(<span class="string">&quot;recv &quot;</span> + r + <span class="string">&quot; new bytes from &quot;</span> + sC);</span><br><span class="line">				buffer.flip();</span><br><span class="line">				<span class="comment">// get first byte</span></span><br><span class="line">				<span class="comment">// decode bytes stream</span></span><br><span class="line">				<span class="keyword">for</span> (; buffer.hasRemaining();) &#123;</span><br><span class="line">					<span class="type">byte</span> <span class="variable">fisrt</span> <span class="operator">=</span> buffer.get(<span class="number">0</span>);</span><br><span class="line">					<span class="keyword">if</span> (Byte.toUnsignedInt(fisrt) &lt;= <span class="number">127</span>) &#123;<span class="comment">// 高字节的大小判断</span></span><br><span class="line">						fisrt = buffer.get();</span><br><span class="line">						System.err.println(<span class="string">&quot;[to &quot;</span> + sC.socket().getPort() + <span class="string">&quot; ] &quot;</span>+ (<span class="type">char</span>) fisrt);</span><br><span class="line">					&#125; <span class="keyword">else</span> <span class="keyword">if</span> (buffer.remaining() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">						<span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span>];</span><br><span class="line">						b[<span class="number">0</span>] = buffer.get();</span><br><span class="line">						b[<span class="number">1</span>] = buffer.get();</span><br><span class="line">						<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(b, <span class="string">&quot;gbk&quot;</span>);</span><br><span class="line">						System.err.println(<span class="string">&quot;[to &quot;</span> + sC.socket().getPort() + <span class="string">&quot; ] &quot;</span> + s);</span><br><span class="line">					&#125; <span class="keyword">else</span></span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				buffer.compact();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>（4）异步I&#x2F;O</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> iomodel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousFileChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.CompletionHandler;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Path;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.StandardOpenOption;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AIODemo</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="type">AsynchronousFileChannel</span> <span class="variable">aFC</span> <span class="operator">=</span> AsynchronousFileChannel.open(Paths.get(<span class="string">&quot;a.txt&quot;</span>), StandardOpenOption.READ);</span><br><span class="line">			System.out.println(<span class="string">&quot;main &quot;</span> + Thread.currentThread().getId());</span><br><span class="line">			<span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate((<span class="type">int</span>) <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;a.txt&quot;</span>).length());</span><br><span class="line">			Future&lt;Integer&gt; result = aFC.read(buffer, <span class="number">0</span>);	</span><br><span class="line">			<span class="keyword">while</span> (!result.isDone()) &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;i am doing other useful work...&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			buffer.flip();</span><br><span class="line">			System.out.println(result.get());</span><br><span class="line">		</span><br><span class="line">			System.out.println(<span class="string">&quot;read is done&quot;</span>);</span><br><span class="line">			</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileReadHandler</span> <span class="keyword">implements</span> <span class="title class_">CompletionHandler</span>&lt;Integer, AsynchronousFileChannel&gt; &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(Integer result, AsynchronousFileChannel attachment)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;new connection from &quot;</span> + result);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, AsynchronousFileChannel attachment)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><ul>
<li>几种IO模型的优缺点，模型的阻塞、非阻塞以及同步、异步指的是什么？</li>
<li>select模型与阻塞+多线程模型的区别以及使用场景；</li>
</ul>
<h2 id="4-References"><a href="#4-References" class="headerlink" title="4. References"></a>4. References</h2><p>[1] 史蒂文斯，芬纳，鲁道夫.UNIX网络编程卷一[M].北京:人民邮电出版社,2015:122-148</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://spground.github.io/2017/07/19/Java%20getClass()%20VS%20instanceof%20VS%20==/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Spground">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spground Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Spground Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/07/19/Java%20getClass()%20VS%20instanceof%20VS%20==/" class="post-title-link" itemprop="url">Java getClass()  VS  instanceof  VS  ==</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-07-19 00:00:00" itemprop="dateCreated datePublished" datetime="2017-07-19T00:00:00+08:00">2017-07-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-24 22:30:21" itemprop="dateModified" datetime="2025-09-24T22:30:21+08:00">2025-09-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><ul>
<li><code>getClass()</code> 返回调用对象<code>object</code>的<strong>运行时类</strong>(<code>runtime class</code>)，一个<code>Class</code>实例。</li>
<li><code>a instanceof T</code> 返回<code>a</code>是否是<code>T</code>类型的实例或者<code>T</code>类型的子类型的实例</li>
<li><code>a == b</code> 判断<code>a</code>和<code>b</code>引用的是否是同一个对象</li>
</ul>
<h3 id="区分"><a href="#区分" class="headerlink" title="区分"></a>区分</h3><p><code>getClass()</code>的文档介绍如下：</p>
<blockquote>
<p>Returns the runtime class of this Object.<br>The returned Class object is the object that is locked by static synchronized methods of the represented class. </p>
</blockquote>
<p><code>The returned Class object is the object that is locked by static synchronized methods of the represented class</code><br>这句话的意思是在说明一个事实：</p>
<blockquote>
<p>T.class &#x3D; a.getClass()</p>
</blockquote>
<p>返回的<code>Class</code>对象是该对象(<code>Class</code>对象)表示的类中的静态同步方法锁住的那个对象。</p>
<p><code>java</code>中当同步关键字加在静态方法前面，当某个线程进入该方法时，必须是已经获得了该类对象(<code>T.class</code>)的锁。</p>
<p>下面两个写法效果相同：</p>
<ul>
<li>1</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>2</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">synchronized</span>(T.class) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>另外，<code>java</code>中的同步关键字的加锁粒度一般发生在<strong>普通对象</strong>和<strong>类对象</strong>上，封锁范围一般可以是<strong>代码块</strong>、<strong>一个方法</strong>、<strong>整个类的所有方法</strong>等。</p>
<hr>
<p><code>instanceof</code>是一个操作符，返回值是<code>false</code>或<code>true</code>。</p>
<p><code>instanceof</code>不仅可以判断对象是否是某个类<code>T</code>或其子类的实例，还可以判断是否是某个接口<code>I</code>或其子接口<code>I</code>的实现类的实例。</p>
<hr>
<p><code>==</code>操作符是判断两个引用对应的对象是否是同一个。</p>
<p><code>equal()</code>方法是自定义的判断的两个引用对应的对象是否逻辑相等。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://spground.github.io/2017/07/07/Heap%20and%20Heap's%20Application-Heap%20Sort%20and%20Priority%20Queue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Spground">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spground Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Spground Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/07/07/Heap%20and%20Heap's%20Application-Heap%20Sort%20and%20Priority%20Queue/" class="post-title-link" itemprop="url">堆和堆的应用：堆排序和优先队列</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-07-07 00:00:00" itemprop="dateCreated datePublished" datetime="2017-07-07T00:00:00+08:00">2017-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-24 22:30:21" itemprop="dateModified" datetime="2025-09-24T22:30:21+08:00">2025-09-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-堆"><a href="#1-堆" class="headerlink" title="1.堆"></a>1.堆</h2><p><a href="https://en.wikipedia.org/wiki/Heap_(data_structure)">堆(Heap)</a>是一种重要的数据结构，是实现<a href="https://en.wikipedia.org/wiki/Priority_queue">优先队列(Priority Queues)</a></p>
<p>首选的数据结构。由于堆有很多种变体，包括二项式堆、斐波那契堆等，但是这里只考虑最常见的就是二叉堆（以下简称堆）。</p>
<p>堆是一棵满足一定性质的二叉树，具体的讲堆具有如下性质：<strong>父节点的键值总是不大于它的孩子节点的键值（小顶堆）</strong>, 堆可以分为<strong>小顶堆</strong>和<strong>大顶堆</strong>，这里以<strong>小顶堆</strong>为例，其主要包含的操作有：</p>
<ul>
<li>insert()</li>
<li>extractMin</li>
<li>peek(findMin)</li>
<li>delete(i)</li>
</ul>
<p>由于堆是一棵形态规则的二叉树，因此堆的父节点和孩子节点存在如下关系：</p>
<blockquote>
<p><strong>设父节点的编号为 <code>i</code>, 则其左孩子节点的编号为<code>2*i+1</code>, 右孩子节点的编号为<code>2*i+2</code></strong><br><strong>设孩子节点的编号为<code>i</code>, 则其父节点的编号为<code>(i-1)/2</code></strong></p>
</blockquote>
<p>由于二叉树良好的形态已经包含了父节点和孩子节点的关系信息，因此就可以不使用链表而简单的使用数组来存储堆。</p>
<p>要实现堆的基本操作，涉及到的两个关键的函数</p>
<ul>
<li><code>siftUp(i, x)</code> ： 将位置<code>i</code>的元素<code>x</code>向上调整，以满足堆得性质，常常是用于<code>insert</code>后，用于调整堆；</li>
<li><code>siftDown(i, x)</code>：同理，常常是用于<code>delete(i)</code>后，用于调整堆；</li>
</ul>
<p>具体的操作如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftUp</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> nums[i];</span><br><span class="line">	<span class="keyword">for</span> (; i &gt; <span class="number">0</span>;) &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> (i - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (nums[p] &lt;= key)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		nums[i] = nums[p];</span><br><span class="line">		i = p;</span><br><span class="line">	&#125;</span><br><span class="line">	nums[i] = key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftDown</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> nums[i];</span><br><span class="line">		<span class="keyword">for</span> (;i &lt; nums.length / <span class="number">2</span>;) &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">child</span> <span class="operator">=</span> (i &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (child + <span class="number">1</span> &lt; nums.length &amp;&amp; nums[child] &gt; nums[child+<span class="number">1</span>])</span><br><span class="line">				child++;</span><br><span class="line">			<span class="keyword">if</span> (key &lt;= nums[child])</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			nums[i] = nums[child];</span><br><span class="line">			i = child;</span><br><span class="line">		&#125;</span><br><span class="line">		nums[i] = key;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>siftUp</code>和<code>siftDown</code>不停的在父节点和子节点之间比较、交换；在不超过<code>logn</code>的时间复杂度就可以完成一次操作。</p>
<p>有了这两个基本的函数，就可以实现上述提及的堆的基本操作。</p>
<p>首先是如何建堆，<strong>实现建堆操作有两个思路</strong>:</p>
<ul>
<li>一个是不断地<code>insert</code>（<code>insert</code>后调用的是<code>siftUp</code>）</li>
<li>另一个将原始数组当成一个需要调整的堆，然后自底向上地<br>在每个位置<code>i</code>调用<code>siftDown(i)</code>，完成后我们就可以得到一个满足堆性质的堆。这里考虑后一种思路：</li>
</ul>
<p>通常堆的<code>insert</code>操作是将元素插入到堆尾，由于新元素的插入可能违反堆的性质，因此需要调用<code>siftUp</code>操作自底向上调整堆；堆移除堆顶元素操作是将堆顶元素删除，然后将堆最后一个元素放置在堆顶，接着执行<code>siftDown</code>操作，同理替换堆顶元素也是相同的操作。</p>
<p><strong>建堆</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 建立小顶堆</span><br><span class="line">private void buildMinHeap(int[] nums) &#123;</span><br><span class="line">	int size = nums.length;</span><br><span class="line">	for (int j = size / 2 - 1; j &gt;= 0; j--)</span><br><span class="line">		siftDown(nums, j, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>那么建堆操作的时间复杂度是多少呢？答案是<code>O(n)</code>。虽然<code>siftDown</code>的操作时间是<code>logn</code>，但是由于高度在递减的同时，每一层的节点数量也在成倍减少，最后通过数列错位相减可以得到时间复杂度是<code>O(n)</code>。</p>
<p><strong>extractMin</strong><br>由于堆的固有性质，堆的根便是最小的元素，因此<strong>peek</strong>操作就是返回根<code>nums[0]</code>元素即可；<br>若要将<code>nums[0]</code>删除，可以将末尾的元素<code>nums[n-1]</code>覆盖<code>nums[0]</code>,然后将堆得<code>size = size-1</code>，调用<code>siftDown(0)</code>调整堆。时间复杂度为<code>logn</code>。</p>
<p><strong>peek</strong><br>同上</p>
<p><strong>delete(i)</strong></p>
<p>删除堆中位置为<code>i</code>的节点，涉及到两个函数<code>siftUp</code>和<code>siftDown</code>，时间复杂度为<code>logn</code>,具体步骤是，</p>
<ul>
<li>将元素<code>last</code>覆盖元素<code>i</code>，然后<code>siftDown</code></li>
<li>检查是否需要<code>siftUp</code></li>
</ul>
<p><strong>注意到堆的删除操作，如果是删除堆的根节点，则不用考虑执行siftUp的操作；若删除的是堆的非根节点，则要视情况决定是siftDown还是siftUp操作，两个操作是互斥的。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> nums[i];</span><br><span class="line">	<span class="comment">//将last元素移动过来，先siftDown; 再视情况考虑是否siftUp</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> nums[i] = nums[size-<span class="number">1</span>];</span><br><span class="line">	size--;</span><br><span class="line">	siftDown(i);</span><br><span class="line">	<span class="comment">//check #i的node的键值是否确实发生改变（是否siftDown操作生效）,若发生改变，则ok,否则为确保堆性质，则需要siftUp </span></span><br><span class="line">	<span class="keyword">if</span> (i &lt; size &amp;&amp; nums[i] == last) &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;delete siftUp&quot;</span>);</span><br><span class="line">		siftUp(i);</span><br><span class="line">	&#125;	</span><br><span class="line">     <span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>case 1 :</strong> </p>
<p>删除中间节点<code>i</code>21，将最后一个节点复制过来；</p>
<p><img src="/images/case1-1.jpeg" alt="这里写图片描述"></p>
<p>由于没有进行<code>siftDown</code>操作，节点<code>i</code>的值仍然为6，因此为确保堆的性质，执行<code>siftUp</code>操作；</p>
<p><img src="/images/case1-2.jpeg" alt="这里写图片描述"></p>
<p><strong>case 2</strong></p>
<p>删除中间节点<code>i</code>，将值为11的节点复制过来，执行<code>siftDown</code>操作；<br><img src="/images/case2-1.jpeg" alt="这里写图片描述"></p>
<p>由于执行<code>siftDown</code>操作后，节点<code>i</code>的值不再是<code>11</code>，因此就不用再执行<code>siftUp</code>操作了，因为堆的性质在<code>siftDown</code>操作生效后已经得到了保持。</p>
<p><img src="/images/case2-2.jpeg" alt="这里写图片描述"></p>
<hr>
<p>可以看出，堆的基本操作都依赖于两个核心的函数<code>siftUp</code>和<code>siftDown</code>；较为完整的<code>Heap</code>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Heap</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">//default size</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span>[] nums;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Heap</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.nums = nums;</span><br><span class="line">		<span class="built_in">this</span>.size = nums.length;</span><br><span class="line">		heapify(<span class="built_in">this</span>.nums);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Heap</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.nums = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * heapify an array, O(n)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> nums An array to be heapified. </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> (size - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">			siftDown(j);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * append x to heap</span></span><br><span class="line"><span class="comment">	 * O(logn)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> x</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (size &gt;= <span class="built_in">this</span>.nums.length)</span><br><span class="line">			expandSpace();</span><br><span class="line">		size += <span class="number">1</span>;</span><br><span class="line">		nums[size-<span class="number">1</span>] = x;</span><br><span class="line">		siftUp(size-<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * delete an element located in i position.</span></span><br><span class="line"><span class="comment">	 * O(logn)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">		rangeCheck(i);</span><br><span class="line">		<span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> nums[i];</span><br><span class="line">		<span class="comment">//将last元素覆盖过来,先siftDown; 再视情况考虑是否siftUp;</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> nums[i] = nums[size-<span class="number">1</span>];</span><br><span class="line">		size--;</span><br><span class="line">		siftDown(i);</span><br><span class="line">		<span class="comment">//check #i的node的键值是否确实发生改变,若发生改变，则ok,否则为确保堆性质，则需要siftUp; </span></span><br><span class="line">		<span class="keyword">if</span> (i &lt; size &amp;&amp; nums[i] == last) </span><br><span class="line">			siftUp(i);</span><br><span class="line">		<span class="keyword">return</span> key;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * remove the root of heap, return it&#x27;s value, and adjust heap to maintain the heap&#x27;s property. </span></span><br><span class="line"><span class="comment">	 * O(logn)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">extractMin</span><span class="params">()</span> &#123;</span><br><span class="line">		rangeCheck(<span class="number">0</span>);</span><br><span class="line">		<span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> nums[<span class="number">0</span>], last = nums[size-<span class="number">1</span>];</span><br><span class="line">		nums[<span class="number">0</span>] = last;</span><br><span class="line">		size--;</span><br><span class="line">		siftDown(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> key;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * return an element&#x27;s index, if not exists, return -1;</span></span><br><span class="line"><span class="comment">	 * O(n)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> x</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">			<span class="keyword">if</span> (nums[i] == x)</span><br><span class="line">				<span class="keyword">return</span> i;</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * return but does not remove the root of heap.</span></span><br><span class="line"><span class="comment">	 * O(1)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">		rangeCheck(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftUp</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> nums[i];</span><br><span class="line">		<span class="keyword">for</span> (; i &gt; <span class="number">0</span>;) &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> (i - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (nums[p] &lt;= key)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			nums[i] = nums[p];</span><br><span class="line">			i = p;</span><br><span class="line">		&#125;</span><br><span class="line">		nums[i] = key;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftDown</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> nums[i];</span><br><span class="line">		<span class="keyword">for</span> (;i &lt; size / <span class="number">2</span>;) &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">child</span> <span class="operator">=</span> (i &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (child + <span class="number">1</span> &lt; size &amp;&amp; nums[child] &gt; nums[child+<span class="number">1</span>])</span><br><span class="line">				child++;</span><br><span class="line">			<span class="keyword">if</span> (key &lt;= nums[child])</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			nums[i] = nums[child];</span><br><span class="line">			i = child;</span><br><span class="line">		&#125;</span><br><span class="line">		nums[i] = key;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rangeCheck</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (!(<span class="number">0</span> &lt;= i &amp;&amp; i &lt; size))</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Index is out of boundary&quot;</span>);	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">expandSpace</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.nums = Arrays.copyOf(<span class="built_in">this</span>.nums, size * <span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">		sb.append(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">			sb.append(String.format((i != <span class="number">0</span> ? <span class="string">&quot;, &quot;</span> : <span class="string">&quot;&quot;</span>) + <span class="string">&quot;%d&quot;</span>, nums[i]));</span><br><span class="line">		sb.append(<span class="string">&quot;]\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> sb.toString();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-堆的应用：堆排序"><a href="#2-堆的应用：堆排序" class="headerlink" title="2.堆的应用：堆排序"></a>2.堆的应用：堆排序</h2><p>运用堆的性质，我们可以得到一种常用的、稳定的、高效的排序算法————<strong>堆排序</strong>。堆排序的时间复杂度为<code>O(n*log(n))</code>，空间复杂度为<code>O(1)</code>，堆排序的思想是：<br>对于含有<code>n</code>个元素的无序数组<code>nums</code>, 构建一个堆(这里是小顶堆)<code>heap</code>，然后执行<code>extractMin</code>得到最小的元素，这样执行<code>n</code>次得到序列就是排序好的序列。<br>如果是降序排列则是小顶堆；否则利用大顶堆。</p>
<p><strong>Trick</strong></p>
<p>由于<code>extractMin</code>执行完毕后，最后一个元素<code>last</code>已经被移动到了<code>root</code>，因此可以将<code>extractMin</code>返回的元素放置于最后，这样可以得到<code>sort in place</code>的堆排序算法。</p>
<p>具体操作如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] n = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">1</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">86</span>&#125;;</span><br><span class="line"><span class="type">Heap</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Heap</span>(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n.length; i++)</span><br><span class="line">	n[n.length-<span class="number">1</span>-i] = h.extractMin();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p>当然，如果不使用前面定义的<code>heap</code>，则可以手动写堆排序，由于堆排序设计到<strong>建堆</strong>和<strong>extractMin</strong>， 两个操作都公共依赖于<code>siftDown</code>函数，因此我们只需要实现<code>siftDown</code>即可。(trick:由于建堆操作可以采用<code>siftUp</code>或者<code>siftDown</code>，而<code>extractMin</code>是需要<code>siftDown</code>操作，因此取公共部分，则采用<code>siftDown</code>建堆)。</p>
<p>这里便于和前面统一，采用小顶堆数组进行降序排列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> nums.length;</span><br><span class="line">		buildMinHeap(nums);</span><br><span class="line">		<span class="keyword">while</span> (size != <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">// 交换堆顶和最后一个元素</span></span><br><span class="line">			<span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">			nums[<span class="number">0</span>] = nums[size - <span class="number">1</span>];</span><br><span class="line">			nums[size - <span class="number">1</span>] = tmp;</span><br><span class="line">			size--;</span><br><span class="line">			siftDown(nums, <span class="number">0</span>, size);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 建立小顶堆</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildMinHeap</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> nums.length;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> size / <span class="number">2</span> - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">			siftDown(nums, j, size);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftDown</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> newSize)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> nums[i];</span><br><span class="line">		<span class="keyword">while</span> (i &lt; newSize &gt;&gt;&gt; <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">leftChild</span> <span class="operator">=</span> (i &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">			<span class="type">int</span> <span class="variable">rightChild</span> <span class="operator">=</span> leftChild + <span class="number">1</span>;</span><br><span class="line">			<span class="comment">// 最小的孩子，比最小的孩子还小</span></span><br><span class="line">			<span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> (rightChild &gt;= newSize || nums[leftChild] &lt; nums[rightChild]) ? leftChild : rightChild;</span><br><span class="line">			<span class="keyword">if</span> (key &lt;= nums[min])</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			nums[i] = nums[min];</span><br><span class="line">			i = min;</span><br><span class="line">		&#125;</span><br><span class="line">		nums[i] = key;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="3-堆的应用：优先队列"><a href="#3-堆的应用：优先队列" class="headerlink" title="3.堆的应用：优先队列"></a>3.堆的应用：优先队列</h2><p>优先队列是一种抽象的数据类型，它和堆的关系类似于，<code>List</code>和数组、链表的关系一样；我们常常使用堆来实现优先队列，因此很多时候堆和优先队列都很相似，它们只是概念上的区分。<br>优先队列的应用场景十分的广泛：<br>常见的应用有：</p>
<ul>
<li>Dijkstra’s algorithm（单源最短路问题中需要在邻接表中找到某一点的最短邻接边，这可以将复杂度降低。）</li>
<li>Huffman coding（贪心算法的一个典型例子，采用优先队列构建最优的前缀编码树(<code>prefixEncodeTree</code>)）</li>
<li>Prim’s algorithm for minimum spanning tree</li>
<li>Best-first search algorithms</li>
</ul>
<p>这里简单介绍上述应用之一：<a href="https://en.wikipedia.org/wiki/Huffman_coding">Huffman coding</a>。</p>
<p>Huffman编码是一种变长的编码方案，对于每一个字符，所对应的二进制位串的长度是不一致的，但是遵守如下原则：</p>
<ul>
<li>出现频率高的字符的二进制位串的长度小</li>
<li>不存在一个字符<code>c</code>的二进制位串<code>s</code>是除<code>c</code>外任意字符的二进制位串的前缀</li>
</ul>
<p>遵守这样原则的Huffman编码属于变长编码，可以无损的压缩数据，压缩后通常可以节省20%-90%的空间，具体压缩率依赖于数据的固有结构。</p>
<p>Huffman编码的实现就是要找到满足这两种原则的 <strong>字符-二进制位串</strong> 对照关系，即找到<strong>最优前缀码</strong>的编码方案（前缀码：没有任何字符编码后的二进制位串是其他字符编码后位串的前缀）。<br>这里我们需要用到二叉树来表达最优前缀码，该树称为<strong>最优前缀码树</strong><br>一棵最优前缀码树看起来像这样：</p>
<p><img src="/images/optim-prefix-tree.png" alt="这里写图片描述"></p>
<p>算法思想：用一个属性为<code>freqeunce</code>关键字的最小优先队列Q,将当前最小的两个元素x,y合并得到一个新元素z（z.frequence &#x3D; x.freqeunce + y.frequence）,<br>然后插入到优先队列中Q中，这样执行<code>n-1</code>次合并后，得到一棵最优前缀码树（这里不讨论算法的证明）。</p>
<p>一个常见的构建流程如下：</p>
<p><img src="/images/haffman-tree-build.jpeg" alt="这里写图片描述"></p>
<p>树中指向某个节点左孩子的边上表示位<code>0</code>,指向右孩子的边上的表示位<code>1</code>，这样遍历一棵最优前缀码树就可以得到对照表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *                            root </span></span><br><span class="line"><span class="comment"> *                            /   \ </span></span><br><span class="line"><span class="comment"> *                    --------- ---------- </span></span><br><span class="line"><span class="comment"> *                    |c:freq | | c:freq | </span></span><br><span class="line"><span class="comment"> *                    --------- ----------</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HuffmanEncodeDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		Node[] n = <span class="keyword">new</span> <span class="title class_">Node</span>[<span class="number">6</span>];</span><br><span class="line">		<span class="type">float</span>[] freq = <span class="keyword">new</span> <span class="title class_">float</span>[] &#123; <span class="number">9</span>, <span class="number">5</span>, <span class="number">45</span>, <span class="number">13</span>, <span class="number">16</span>, <span class="number">12</span> &#125;;</span><br><span class="line">		<span class="type">char</span>[] chs = <span class="keyword">new</span> <span class="title class_">char</span>[] &#123; <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;c&#x27;</span> &#125;;</span><br><span class="line">		<span class="type">HuffmanEncodeDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HuffmanEncodeDemo</span>();</span><br><span class="line">		<span class="type">Node</span> <span class="variable">root</span> <span class="operator">=</span> demo.buildPrefixEncodeTree(n, freq, chs);</span><br><span class="line">		Map&lt;Character, String&gt; collector = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">		<span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">		demo.tranversalPrefixEncodeTree(root, collector, sb);</span><br><span class="line">		System.out.println(collector);</span><br><span class="line">		<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;abcabcefefefeabcdbebfbebfbabc&quot;</span>;</span><br><span class="line">		<span class="type">StringBuilder</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">			sb1.append(collector.get(c));</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(sb1.toString());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> Node <span class="title function_">buildPrefixEncodeTree</span><span class="params">(Node[] n, <span class="type">float</span>[] freq, <span class="type">char</span>[] chs)</span> &#123;</span><br><span class="line">		PriorityQueue&lt;Node&gt; pQ = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Node&gt;() &#123;</span><br><span class="line">			<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Node o1, Node o2)</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> o1.item.freq &gt; o2.item.freq ? <span class="number">1</span> : o1.item.freq == o2.item.freq ? <span class="number">0</span> : -<span class="number">1</span>;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="type">Node</span> <span class="variable">e</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">			n[i] = e = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Item</span>(chs[i], freq[i]));</span><br><span class="line">			pQ.add(e);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">			<span class="type">Node</span> <span class="variable">x</span> <span class="operator">=</span> pQ.poll(), y = pQ.poll();</span><br><span class="line">			<span class="type">Node</span> <span class="variable">z</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(x, y, <span class="keyword">new</span> <span class="title class_">Item</span>(<span class="string">&#x27;$&#x27;</span>, x.item.freq + y.item.freq));</span><br><span class="line">			pQ.add(z);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> pQ.poll();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * tranversal  </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> collector</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> sb</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tranversalPrefixEncodeTree</span><span class="params">(Node root, Map&lt;Character, String&gt; collector, StringBuilder sb)</span> &#123;</span><br><span class="line">		<span class="comment">// leaf node</span></span><br><span class="line">		<span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">			collector.put(root.item.c, sb.toString());</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">Node</span> <span class="variable">left</span> <span class="operator">=</span> root.left, right = root.right;</span><br><span class="line">		tranversalPrefixEncodeTree(left, collector, sb.append(<span class="number">0</span>));</span><br><span class="line">		sb.delete(sb.length() - <span class="number">1</span>, sb.length());</span><br><span class="line">		tranversalPrefixEncodeTree(right, collector, sb.append(<span class="number">1</span>));</span><br><span class="line">		sb.delete(sb.length() - <span class="number">1</span>, sb.length());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> Node left, right;</span><br><span class="line">	<span class="keyword">public</span> Item item;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Node left, Node right, Item item)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.left = left;</span><br><span class="line">		<span class="built_in">this</span>.right = right;</span><br><span class="line">		<span class="built_in">this</span>.item = item;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">char</span> c;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">float</span> freq;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Item</span><span class="params">(<span class="type">char</span> c, <span class="type">float</span> freq)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.c = c;</span><br><span class="line">		<span class="built_in">this</span>.freq = freq;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;a=0, b=101, c=100, d=111, e=1101, f=1100&#125;</span><br><span class="line">010110001011001101110011011100110111001101010110011110111011011100101110110111001010101100</span><br></pre></td></tr></table></figure>
<h2 id="4-堆的应用：海量实数中（一亿级别以上）找到TopK（一万级别以下）的数集合。"><a href="#4-堆的应用：海量实数中（一亿级别以上）找到TopK（一万级别以下）的数集合。" class="headerlink" title="4 堆的应用：海量实数中（一亿级别以上）找到TopK（一万级别以下）的数集合。"></a>4 堆的应用：海量实数中（一亿级别以上）找到TopK（一万级别以下）的数集合。</h2><ul>
<li><p>A:通常遇到找一个集合中的TopK问题，想到的便是排序，因为常见的排序算法例如快排算是比较快了，然后再取出K个TopK数，时间复杂度为<code>O(nlogn)</code>，当<code>n</code>很大的时候这个时间复杂度还是很大的；</p>
</li>
<li><p>B:另一种思路就是打擂台的方式,每个元素与K个待选元素比较一次，时间复杂度很高：<code>O(k*n)</code>，此方案明显逊色于前者。</p>
</li>
</ul>
<p>对于一亿数据来说，A方案大约是<code>26.575424*n</code>；</p>
<ul>
<li>C:由于我们只需要TopK，因此不需要对所有数据进行排序，可以利用堆得思想，维护一个大小为K的小顶堆，然后依次遍历每个元素<code>e</code>, 若元素<code>e</code>大于堆顶元素<code>root</code>，则删除<code>root</code>，将<code>e</code>放在堆顶，然后调整，时间复杂度为<code>logK</code>；若小于或等于，则考察下一个元素。这样遍历一遍后，最小堆里面保留的数就是我们要找的<code>topK</code>，整体时间复杂度为<code>O(k+n*logk)</code>约等于<code>O(n*logk)</code>，大约是<code>13.287712*n</code>（由于k与n数量级差太多），这样时间复杂度下降了约一半。</li>
</ul>
<p>A、B、C三个方案中，C通常是优于B的，因为logK通常是小于k的，当<code>K</code>和<code>n</code>的数量级相差越大，这种方式越有效。</p>
<p>以下为具体操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TopKNumbersInMassiveNumbersDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="type">int</span>[] topK = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">50001</span>,<span class="number">50002</span>,<span class="number">50003</span>,<span class="number">50004</span>,<span class="number">50005</span>&#125;;</span><br><span class="line">		genData(<span class="number">1000</span> * <span class="number">1000</span> * <span class="number">1000</span>, <span class="number">500</span>, topK);</span><br><span class="line">		<span class="type">long</span> <span class="variable">t</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">		findTopK(topK.length);</span><br><span class="line">		System.out.println(String.format(<span class="string">&quot;cost:%fs&quot;</span>, (System.currentTimeMillis() - t) * <span class="number">1.0</span> / <span class="number">1000</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">genData</span><span class="params">(<span class="type">int</span> N, <span class="type">int</span> maxRandomNumer, <span class="type">int</span>[] topK)</span> &#123;</span><br><span class="line">		<span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;data.txt&quot;</span>);</span><br><span class="line">		<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> topK.length;</span><br><span class="line">		Set&lt;Integer&gt; index = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">			index.add((<span class="type">int</span>)(Math.random() * N));</span><br><span class="line">			<span class="keyword">if</span> (index.size() == k)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(index);</span><br><span class="line">		<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="type">PrintWriter</span> <span class="variable">pW</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(f, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">				<span class="keyword">if</span>(!index.contains(i))</span><br><span class="line">					pW.println((<span class="type">int</span>)(Math.random() * maxRandomNumer));</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					pW.println(topK[j++]);</span><br><span class="line">			pW.flush();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">findTopK</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">		<span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">		<span class="comment">//read</span></span><br><span class="line">		<span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;data.txt&quot;</span>);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(f);</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; k; j++)</span><br><span class="line">				nums[j] = scanner.nextInt();</span><br><span class="line">			heapify(nums);</span><br><span class="line">			<span class="comment">//core</span></span><br><span class="line">			<span class="keyword">while</span> (scanner.hasNextInt()) &#123;</span><br><span class="line">				<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">				<span class="keyword">if</span> (a &lt;= nums[<span class="number">0</span>])</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					nums[<span class="number">0</span>] = a;</span><br><span class="line">					siftDown(<span class="number">0</span>, k, nums);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(Arrays.toString(nums));</span><br><span class="line">		&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//O(n), minimal heap</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> nums.length;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> (size - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">			siftDown(j, size, nums);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">siftDown</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> n, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> nums[i];</span><br><span class="line">		<span class="keyword">for</span> (;i &lt; (n &gt;&gt;&gt; <span class="number">1</span>);) &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">child</span> <span class="operator">=</span> (i &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (child + <span class="number">1</span> &lt; n &amp;&amp; nums[child] &gt; nums[child+<span class="number">1</span>])</span><br><span class="line">				child++;</span><br><span class="line">			<span class="keyword">if</span> (key &lt;= nums[child])</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			nums[i] = nums[child];</span><br><span class="line">			i = child;</span><br><span class="line">		&#125;</span><br><span class="line">		nums[i] = key;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>ps:大致测试了一下，10亿个数中找到top5需要140秒左右，应该是很快了。</p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h2><ul>
<li>堆是基于树的满足一定约束的重要数据结构，存在许多变体例如二叉堆、二项式堆、斐波那契堆（很高效）等。</li>
<li>堆的几个基本操作都依赖于两个重要的函数<code>siftUp</code>和<code>siftDown</code>，堆的<code>insert</code>通常是在堆尾插入新元素并<code>siftUp</code>调整堆，而<code>extractMin</code>是在<br>删除堆顶元素，然后将最后一个元素放置堆顶并调用<code>siftDown</code>调整堆。</li>
<li>二叉堆是常用的一种堆，其是一棵二叉树；由于二叉树良好的性质，因此常常采用数组来存储堆。<br>堆得基本操作的时间复杂度如下表所示：</li>
</ul>
<table>
<thead>
<tr>
<th>heapify</th>
<th>insert</th>
<th>peek</th>
<th>extractMin</th>
<th>delete(i)</th>
</tr>
</thead>
<tbody><tr>
<td><code>O(n)</code></td>
<td><code>O(logn)</code></td>
<td><code>O(1)</code></td>
<td><code>O(logn)</code></td>
<td><code>O(logn)</code></td>
</tr>
</tbody></table>
<ul>
<li><p>二叉堆通常被用来实现堆排序算法，堆排序可以<code>sort in place</code>，堆排序的时间复杂度的上界是<code>O(nlogn)</code>，是一种很优秀的排序算法。由于存在相同键值的两个元素处于两棵子树中，而两个元素的顺序可能会在后续的堆调整中发生改变，因此堆排序不是稳定的。降序排序需要建立小顶堆，升序排序需要建立大顶堆。</p>
</li>
<li><p>堆是实现抽象数据类型优先队列的一种方式，优先队列有很广泛的应用，例如Huffman编码中使用优先队列利用贪心算法构建最优前缀编码树。</p>
</li>
<li><p>堆的另一个应用就是在海量数据中找到TopK个数，思想是维护一个大小为K的二叉堆，然后不断地比较堆顶元素，判断是否需要执行替换对顶元素的操作，采用<br>此方法的时间复杂度为<code>n*logk</code>，当<code>k</code>和<code>n</code>的数量级差距很大的时候，这种方式是很有效的方法。</p>
</li>
</ul>
<h2 id="6-references"><a href="#6-references" class="headerlink" title="6 references"></a>6 references</h2><p>[1] <a href="https://en.wikipedia.org/wiki/Heap_(data_structure)">https://en.wikipedia.org/wiki/Heap_(data_structure)</a>  </p>
<p>[2] <a href="https://en.wikipedia.org/wiki/Heapsort">https://en.wikipedia.org/wiki/Heapsort</a></p>
<p>[3] <a href="https://en.wikipedia.org/wiki/Priority_queue">https://en.wikipedia.org/wiki/Priority_queue</a></p>
<p>[4] <a href="https://www.cnblogs.com/swiftma/p/6006395.html">https://www.cnblogs.com/swiftma/p/6006395.html</a></p>
<p>[5] Thomas H.Cormen, Charles E.Leiserson, Ronald L.Rivest, Clifford Stein.算法导论[M].北京:机械工业出版社,2015:245-249</p>
<p>[6] Jon Bentley.编程珠玑[M].北京:人民邮电出版社,2015:161-174</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://spground.github.io/2017/06/20/LCS%20problem/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Spground">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spground Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Spground Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/06/20/LCS%20problem/" class="post-title-link" itemprop="url">LCS问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-06-20 00:00:00" itemprop="dateCreated datePublished" datetime="2017-06-20T00:00:00+08:00">2017-06-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-24 22:30:21" itemprop="dateModified" datetime="2025-09-24T22:30:21+08:00">2025-09-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p><a href="https://en.wikipedia.org/wiki/Longest_common_subsequence_problem">LCS</a>通常是指Longest Common Subsequence, 但是也可代指Longest Common Substring。子串是一种特殊的子序列，子串和子序列的区别就是字串要求是组成子串的<br>各字符是连续的，而子序列仅仅要求各字符的下标是递增的即可。举个例子，如<code>helloworld</code>， <code>world</code>是子串(也是子序列)， <code>hw</code>不是子串是子序列。</p>
<p>LCS问题就是在若干(这里是两个)字符串中，找到最长的一个字符串p, 这个p是那些字符串的子串(子序列)。LCS问题的意义之一就是去衡量若干字符串的相似度，例如在生物信息学<br>中有DNA序列的问题，比如序列<code>a = &quot;ATGATAGATAGATAG&quot;</code>， 序列<code>b=&quot;TGGGCCGAGAAGCGAGA&quot;</code>，需要一种去衡量<code>a</code>、<code>b</code>相似度的方法，那么最长公共子序列就可以作为一种衡量方法。<br>除此之外，在软件开发领域中的版本控制系统（典型的就是<code>Git</code>），比较同一个文件不同时刻的差异的时候，就需要利用到这个方法。</p>
<p>例如下图就是<code>Git</code>上面的两次不同时刻对同一个文件的快照的对比图，我们可以看到，系统把两次的差异标示出来了。而原来位置、内容相同的部分没有标示。这个就可以通过<br><code>LCS</code>问题的解决，来找到最长的公共子序列部分，就是作为公共的、未发生改变部分；剩下的就是改变的部分，应该标示出来。</p>
<p><img src="http://img.blog.csdn.net/20171120120813271?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDUzMjkwMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>同理基于这个，我们还可以简单的比较两篇文章的相似度来检查雷同、抄袭的情况，这么看来，LCS问题的还是和我们日常比较相关的。</p>
<p>解决LCS问题依靠暴力(brute force)的求解时间复杂度是指数级别的，因此不太现实，由于问题的本身的最优解具有<strong>最优子结构</strong>特征，因此原问题的求解可以化为多个子问题的求解；另外子问题的求解存在重叠的情况，这恰好是适合动态规划求解的问题的第二个特征：<strong>存在重叠的子问题求解过程</strong>，因此适合利用动态规划来求解，这个也是较常见的解决LCS问题的方法,时间复杂度为<code>O(n*m)</code>，动态规划易于编写，但是时间复杂度较高；另外更高级的还存在一种线性复杂度的<code>O(n+m)</code>的解法，就是<a href="https://en.wikipedia.org/wiki/Suffix_tree"><code>Suffix Tree</code></a>，不过这种方法的缺点是程序难以编制。因此在日常的编码中，动态规划已经够用了。</p>
<h2 id="2-最长公共子串问题"><a href="#2-最长公共子串问题" class="headerlink" title="2. 最长公共子串问题"></a>2. 最长公共子串问题</h2><p>设dp[i][j]表示s[0<del>i]和t[0</del>j]的最长公共子串的长度，对于两个字符串的最长公共子串问题的最优解，最优解存在如下结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = 1 (i == 0 || j == 0)</span><br><span class="line">dp[i][j] = dp[i-1][j-1] + 1;(s[i] == t[j] &amp;&amp; i &gt; 0 &amp;&amp; j &gt; 0);</span><br><span class="line">dp[i][j] = 0;(s[i] != t[j])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上述等式建立了原问题和子问题的关系（此类证明可用反证法），剩下的就是编码了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">findLongestLCS</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">   <span class="type">char</span>[] schs = s.toCharArray();</span><br><span class="line">   <span class="type">char</span>[] tchs = t.toCharArray();</span><br><span class="line">   <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s.length(), n = t.length();</span><br><span class="line">   <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">   <span class="type">int</span> <span class="variable">maxSize</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">   List&lt;Integer&gt; indexs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//存储最长公共子串的在原始串中结束位置</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">       <span class="keyword">if</span> (schs[i] == tchs[j]) &#123;</span><br><span class="line">         <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>)</span><br><span class="line">           dp[i][j] = <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">           dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (dp[i][j] &gt; maxSize) &#123;</span><br><span class="line">           maxSize = dp[i][j];</span><br><span class="line">           indexs.clear();<span class="comment">//找到更优的解，前面存储的下标值全部作废</span></span><br><span class="line">           indexs.add(i);</span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[i][j] == maxSize)</span><br><span class="line">           indexs.add(i);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">          dp[i][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   List&lt;String&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   <span class="keyword">for</span> (Integer i : indexs)</span><br><span class="line">     ret.add(s.substring(i + <span class="number">1</span> - maxSize, i + <span class="number">1</span>));</span><br><span class="line">   <span class="keyword">return</span> ret;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>改进：上面的版本时间复杂度是<code>O(n*m)</code>,空间复杂度也是<code>O(n*m)</code>;但是观察dp二维数组发现，发现有优化的余地。由于在计算dp[i][j]的时候只使用到了dp[i-1][j-1]，因此dp二维数组可以使用一个一位数组和两个临时变量即可完成，这样就把空间复杂度降低到<code>O(min(n, m))</code>。</p>
<p><strong>改进版本</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 内存改进版本, 只存储one row,新增两个临时变量空间复杂度O(min(m, n))</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">findLongestLCS0</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">tmp</span> <span class="operator">=</span> s;</span><br><span class="line">		<span class="keyword">if</span> (s.length() &gt; t.length()) &#123;</span><br><span class="line">			s = t;</span><br><span class="line">			t = tmp;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="type">char</span>[] schs = s.toCharArray();</span><br><span class="line">		<span class="type">char</span>[] tchs = t.toCharArray();</span><br><span class="line">		<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s.length(), n = t.length();</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line">  <span class="comment">//prev存储dp[i-1][j-1]，cur存储dp[i][j]</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="number">0</span>, cur = <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">maxSize</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		List&lt;Integer&gt; indexs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">				<span class="keyword">if</span> (schs[j] == tchs[i]) &#123;</span><br><span class="line">					<span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>)</span><br><span class="line">						dp[j] = <span class="number">1</span>;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						cur = dp[j];</span><br><span class="line">						dp[j] = prev + <span class="number">1</span>;</span><br><span class="line">						prev = cur;</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					<span class="keyword">if</span> (dp[j] &gt; maxSize) &#123;</span><br><span class="line">						maxSize = dp[j];</span><br><span class="line">						indexs.clear();</span><br><span class="line">						indexs.add(j);</span><br><span class="line">					&#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[j] == maxSize)</span><br><span class="line">						indexs.add(j);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					cur = dp[j];</span><br><span class="line">					dp[j] = <span class="number">0</span>;</span><br><span class="line">					prev = cur;</span><br><span class="line">				&#125;</span><br><span class="line">		List&lt;String&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (Integer j : indexs)</span><br><span class="line">			ret.add(s.substring(j + <span class="number">1</span> - maxSize, j + <span class="number">1</span>));</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>如果上面的dp数组很稀疏(0值很多)，当字符串很大时，也还可以继续优化，采用<code>hashmap</code>的方式存储非0值，这样在字符串大且dp数组稀疏的时候，可以进一步优化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 内存改进版1 用hashtable存储每一行dp的非0值</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">findLongestLCS1</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">tmp</span> <span class="operator">=</span> s;</span><br><span class="line">		<span class="keyword">if</span> (s.length() &gt; t.length()) &#123;</span><br><span class="line">			s = t;</span><br><span class="line">			t = tmp;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="type">char</span>[] schs = s.toCharArray();</span><br><span class="line">		<span class="type">char</span>[] tchs = t.toCharArray();</span><br><span class="line">		<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s.length(), n = t.length();</span><br><span class="line"></span><br><span class="line">		Map&lt;Integer, Integer&gt; dp = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">		<span class="type">int</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="number">0</span>, cur = <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">maxSize</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		List&lt;Integer&gt; indexs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">				<span class="type">Integer</span> <span class="variable">tmpj</span> <span class="operator">=</span> dp.get(j);</span><br><span class="line">				<span class="keyword">if</span> (schs[j] == tchs[i]) &#123;</span><br><span class="line">					<span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>)</span><br><span class="line">						dp.put(j, <span class="number">1</span>);</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						cur = tmpj == <span class="literal">null</span> ? <span class="number">0</span> : tmpj;</span><br><span class="line">						dp.put(j, prev + <span class="number">1</span>);</span><br><span class="line">						prev = cur;</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					tmpj = dp.get(j);</span><br><span class="line">					<span class="keyword">if</span> (tmpj &gt; maxSize) &#123;</span><br><span class="line">						maxSize = tmpj;</span><br><span class="line">						indexs.clear();</span><br><span class="line">						indexs.add(j);</span><br><span class="line">					&#125; <span class="keyword">else</span> <span class="keyword">if</span> (tmpj == maxSize)</span><br><span class="line">						indexs.add(j);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">//非0值不存储， 优化稀疏情况。</span></span><br><span class="line">					cur = tmpj == <span class="literal">null</span> ? <span class="number">0</span> : tmpj;</span><br><span class="line">					dp.remove(j);</span><br><span class="line">					prev = cur;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		System.out.println(indexs);</span><br><span class="line">		List&lt;String&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (Integer j : indexs)</span><br><span class="line">			ret.add(s.substring(j + <span class="number">1</span> - maxSize, j + <span class="number">1</span>));</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="3-最长公共子序列问题"><a href="#3-最长公共子序列问题" class="headerlink" title="3. 最长公共子序列问题"></a>3. 最长公共子序列问题</h2><p>同样的最长公共子序列也可以利用刻画最优解的结构来利用DP求解。<br>对于字符串s和t，和上面一样dp[i][j]存储的值依然是s[0<del>i]和t[0</del>j]的最长公共子序列的长度。</p>
<p>最优解的结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = 1 (i == 0 || j == 0 &amp;&amp; s[i] == t[j])</span><br><span class="line">dp[i][j] = 0 (i == 0 || j == 0 &amp;&amp; s[i] != t[j])</span><br><span class="line">dp[i][j] = dp[i-1][j-1] + 1(i &gt; 0 &amp;&amp; j &gt; 0 &amp;&amp; s[i] == t[j])</span><br><span class="line">dp[i][j] = max(dp[i-1][j], dp[i][j-1])(i &gt; 0 &amp;&amp; j &gt; 0 &amp;&amp; s[i] != t[j])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>具体证明参见《算法讨导论》,也是利用反证法。</p>
<p>由于计算的时候只使用到了dp[i-1][j-1]、dp[i-1][j]和dp[i][j-1]，则可以运用上上文中的思路，进行空间优化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//只需要求解长度，可以进行空间优化</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">longestLCS</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">tmp</span> <span class="operator">=</span> s;</span><br><span class="line">		<span class="keyword">if</span> (s.length() &gt; t.length()) &#123;</span><br><span class="line">			s = t;</span><br><span class="line">			t = tmp;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="type">char</span>[] schs = s.toCharArray();</span><br><span class="line">		<span class="type">char</span>[] tchs = t.toCharArray();</span><br><span class="line">		<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s.length(), n = t.length(), prev = <span class="number">0</span>, cur;</span><br><span class="line">		<span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (schs[i] == tchs[j]) &#123;</span><br><span class="line">					<span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) </span><br><span class="line">						dp[i] = <span class="number">1</span>;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						cur = dp[i];</span><br><span class="line">						dp[i] = prev + <span class="number">1</span>;<span class="comment">//prev ---&gt; dp[i-1][j-1]</span></span><br><span class="line">						prev = cur;</span><br><span class="line">					&#125;	</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					cur = dp[i];</span><br><span class="line">					<span class="type">int</span> <span class="variable">aa</span> <span class="operator">=</span> i == <span class="number">0</span> ? <span class="number">0</span> : dp[i-<span class="number">1</span>], bb = j == <span class="number">0</span> ? <span class="number">0</span> : dp[i];</span><br><span class="line">					dp[i] = Math.max(aa, bb);</span><br><span class="line">					prev = cur;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;	</span><br><span class="line">		<span class="keyword">return</span> dp[m-<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p>但是由于有些时候，我们需要知道这些最长公共子序列，因此我们还需要在求解的过程保存额外的信息(上文中保存的是下标值)。为了得到最长公共子序列，我们可以<br>沿着求解反方向去得到最长公共子序列。具体的做法就是，给定一个dp[i][j]我们可以判断出，它是由dp[i][j-1]还是dp[i-1][j]还是dp[i-1][j-1]得来的，知道了这个以后我们就知道了求解方向了，这样可以逆着回退到起点dp[0][0]。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">longestLCSWithReconstructionLCS</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line">	<span class="type">char</span>[] achs = a.toCharArray();</span><br><span class="line">	<span class="type">char</span>[] bchs = b.toCharArray();</span><br><span class="line">	<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> a.length(), n = b.length();</span><br><span class="line">	<span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">	<span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (achs[i] == bchs[j]) &#123;</span><br><span class="line">				<span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>)</span><br><span class="line">					dp[i][j] = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="type">int</span> <span class="variable">aa</span> <span class="operator">=</span> i == <span class="number">0</span> ? <span class="number">0</span> : dp[i - <span class="number">1</span>][j], bb = j == <span class="number">0</span> ? <span class="number">0</span> : dp[i][j - <span class="number">1</span>];</span><br><span class="line">				dp[i][j] = Math.max(aa, bb);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;	</span><br><span class="line">	<span class="comment">// 重构最长公共子序列</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> m - <span class="number">1</span>, j = n - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">//判断方向</span></span><br><span class="line">		<span class="keyword">if</span> (achs[i] == bchs[j]) &#123;<span class="comment">//如果相等，必然是子序列的一部分</span></span><br><span class="line">			sb.append(achs[i]);</span><br><span class="line">			i--;j--;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;<span class="comment">//如果不相等，则需要判断求解方向，然后逆行。</span></span><br><span class="line">			<span class="keyword">if</span> (dp[i - <span class="number">1</span>][j] &gt;= dp[i][j - <span class="number">1</span>])</span><br><span class="line">				i--;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				j--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p>我们可以在<code>O(n)</code>的时间重构得到最长公共子序列,由于我们需要在最后逆行构造最长公共子序列，因此是不能将二维数组dp优化成一位数组dp,因为优化以后我们是没法<br>在<code>O(1)</code>的时间判断出由dp[i][j-1]还是dp[i-1][j]还是dp[i-1][j-1]得来的，重构最长公共子序列也就无从谈起了。</p>
<h2 id="4-References"><a href="#4-References" class="headerlink" title="4. References"></a>4. References</h2><p>[1] <a href="https://en.wikipedia.org/wiki/Longest_common_subsequence_problem">Longest_common_subsequence_problem</a></p>
<p>[2] <a href="https://en.wikipedia.org/wiki/Suffix_tree">Suffix Tree</a></p>
<p>[3] Thomas H.Cormen, Charles E.Leiserson, Ronald L.Rivest, Clifford Stein.算法导论[M].北京:机械工业出版社,2015:222-226</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://spground.github.io/2017/04/16/introduction%20to%20Java%20dynamic%20proxy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Spground">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spground Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Spground Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/04/16/introduction%20to%20Java%20dynamic%20proxy/" class="post-title-link" itemprop="url">Java动态代理简述</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-04-16 20:41:00" itemprop="dateCreated datePublished" datetime="2017-04-16T20:41:00+08:00">2017-04-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-24 22:30:21" itemprop="dateModified" datetime="2025-09-24T22:30:21+08:00">2025-09-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="一、代理简介"><a href="#一、代理简介" class="headerlink" title="一、代理简介"></a>一、代理简介</h2><p>代理一词含义十分宽泛，例如金融领域的股票发行代理、营销领域的销售代理、以及计算机领域中的代理设计模式等。尽管代理一词被使用的领域如此广泛，但是代理一词的大致的抽象含义是相似的或者说是相同的。代理是一个被委托人委托其执行如下活动：参加活动、行驶权力、执行任务等。这样理解的话，计算机中某个对象或组件的代理就非常好理解了。</p>
<p>计算机领域中代理的概念是一个十分重要的概念，常见的有<strong>代理服务器</strong>、<strong>代理设计模式</strong>等。在软件开发发展成熟的今天，每个工程的代码量也越来越庞大，带来的一个问题就是一次小小的需求修改就会引起很大的变化，从而可能引进新的BUG.<br>因此程序员对需求修改都深恶痛绝，而代理设计模式在某种程度上可以缓解这种问题。代理设计模式可以实现在<strong>不破坏原有代码</strong>的情况下，对原有代码添加<strong>额外的功能</strong>，从而实现以低的<strong>侵入</strong>完成原有系统功能的扩展，这种设计也符合<strong>里氏替换原则</strong>（对修改关闭，对扩展开放）。</p>
<h2 id="二、Java语言的代理"><a href="#二、Java语言的代理" class="headerlink" title="二、Java语言的代理"></a>二、Java语言的代理</h2><p>编程语言中的代理分为<strong>静态代理</strong>和<strong>动态代理</strong></p>
<ul>
<li>静态代理：在<strong>编译时期</strong>就已经确定了静态代理的类型或者说是是在<strong>编译时期</strong>的时候生成代理的类（class）</li>
<li>动态代理：在<strong>运行时期</strong>确定代理的类型或者是说在<strong>运行时期</strong>生成代理的类（class）</li>
</ul>
<p>像大多数其他语言一样，Java可以轻松的实现静态代理。具体来讲有两种形式：</p>
<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><ol>
<li>匿名内部类的形式</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractProxy</span> &#123;</span><br><span class="line">	AbstractProxy real;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">AbstractProxy</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">AbstractProxy</span><span class="params">(AbstractProxy real)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.real = real;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">//被代理的方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">foolbar</span><span class="params">(String str)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//某个被代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealClass</span> <span class="keyword">extends</span> <span class="title class_">AbstractProxy</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">RealClass</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">RealClass</span><span class="params">(AbstractProxy real)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(real);</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foolbar</span><span class="params">(String str)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">&quot;out&gt;&gt;&quot;</span> + str);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">AbstractProxy</span> <span class="variable">realObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealClass</span>();</span><br><span class="line"><span class="type">AbstractProxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AbstractProxy</span>() &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foolbar</span><span class="params">(String str)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">&quot;you are proxied by me!&quot;</span>);</span><br><span class="line">		realObj.foolbar(str);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>该形式可以实现一个代理，看似是在运行时生成的一个匿名内部类，但是通过测试发现匿名内部类是在编译时期生成的类，这个可以通过匿名内部类类文件来观察，因此其属于静态代理。这种形式的代理看起来不太正常，而且一个代理类只能代理一个接口或者一个抽象类，如果代理多个就必须新增加多个匿名内部类。</p>
<ol start="2">
<li>继承被代理类或者实现被代理接口<br>  这种形式的代理设计类似于设计模式中的装饰器模式或者适配器模式，具体看代码：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//被代理的接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IReal</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomeThing</span><span class="params">(String str)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//某个被代理的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealClass</span> <span class="keyword">implements</span> <span class="title class_">IReal</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomeThing</span><span class="params">(String str)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">&quot;doSomeThing &quot;</span> + str);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProxyClass</span> <span class="keyword">implements</span> <span class="title class_">IReal</span> &#123;</span><br><span class="line">	IReal realObj;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">ProxyClass</span><span class="params">(IReal realObj)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.realObj = realObj;	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomeThing</span><span class="params">(String str)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">&quot;you are proxied by me!&quot;</span>);</span><br><span class="line">		realObj.doSomething();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">RealClass</span> <span class="variable">realObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealClass</span>();</span><br><span class="line"><span class="type">RealClass</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyClass</span>(realObj);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这种形式的代理类型需要在编译时期确定，因此属于静态类型。从某种程度上来看，这种形式和装饰器模式、适配器模式的设计思路相似。缺点同第一种形式一样，如果多个需要代理多个接口就需要重写代理类，让其实现多个被代理的接口；同时在类型转换的时候也会很麻烦。</p>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p><code>java</code>的动态代理是<strong>运行时动态</strong>的根据需要被代理的接口列表interfaces生成一个代理类，该代理类实现了接口列表<code>interfaces</code>中的所有方法，然后在方法的内部实际是讲该方法的调用<strong>转发</strong>给了实现了<code>InvocationHandler</code>接口的对象，顾名思义，该对象让包含代理时被代理方法的代理逻辑。</p>
<p>用法举例：编写一个代理类实现拦截某个被代理方法<br>具体的使用代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IProxied1</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">proxiedMethod1</span><span class="params">(String str)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IProxied2</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">proxiedMethod2</span><span class="params">(String str)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Proxied</span> <span class="keyword">implements</span> <span class="title class_">IProxied1</span>, IProxied2 &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">proxiedMethod2</span><span class="params">(String str)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">&quot;proxiedMethod2 &quot;</span> + str);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">proxiedMethod1</span><span class="params">(String str)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">&quot;proxiedMethod1 &quot;</span> + str);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Interceptor</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">	Object proxied;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Interceptor</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Interceptor</span><span class="params">(Object proxied)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">		<span class="built_in">this</span>.proxied = proxied;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">&quot;I am watching...&quot;</span>);</span><br><span class="line">		<span class="comment">//判断是否拦截</span></span><br><span class="line">		<span class="keyword">if</span>(method.getName().equals(<span class="string">&quot;proxiedMethod1&quot;</span>)) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;you are intercepted!!!!!&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> method.invoke(proxied, args);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicProxyDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] str)</span> &#123;</span><br><span class="line">		<span class="type">IProxied1</span> <span class="variable">proxiedObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Proxied</span>();</span><br><span class="line">		<span class="type">Object</span> <span class="variable">proxyObj</span> <span class="operator">=</span> Proxy.newProxyInstance(IProxied1.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[]&#123;IProxied1.class, IProxied2.class&#125;, <span class="keyword">new</span> <span class="title class_">Interceptor</span>(proxiedObj));</span><br><span class="line">		((IProxied1)proxyObj).proxiedMethod1(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;-------&quot;</span>);</span><br><span class="line">		((IProxied2)proxyObj).proxiedMethod2(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">I am watching...</span><br><span class="line">you are intercepted!!!!!</span><br><span class="line">-------</span><br><span class="line">I am watching...</span><br><span class="line">proxiedMethod2 Hello, World!</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="比较静态代理和动态代理"><a href="#比较静态代理和动态代理" class="headerlink" title="比较静态代理和动态代理"></a>比较静态代理和动态代理</h3><p>一般来讲，静态代理是<strong>硬编码</strong>去实现一个代理类，如果需要被代理的接口有变动，则需要重新编码代理类；静态绑定的过程将代理类的<strong>代理逻辑</strong>和代理类的<strong>生成</strong>绑定到一起了，<br>所以修改起来不是很方便（解耦不彻底）。其实我们最关注的是代理类的<strong>代理逻辑</strong>，因此如果将代理的<strong>生成</strong>自动化（因为代理类的生成的规则是<code>general</code>的，可以泛化。先实现被代理的接口、然后方法转发，就是这么简单。），<br>而将<strong>代理逻辑</strong>分离出来，所有的代理逻辑全部发生在这里；通过这样的解耦，代码可维护性会增强、侵入性会减小，这就是动态代理的思想。</p>
<p>具体来讲区别如下图：</p>
<h4 id="静态代理-1"><a href="#静态代理-1" class="headerlink" title="静态代理"></a>静态代理</h4><p><img src="/images/static-proxy.jpeg" alt="这里写图片描述"></p>
<p>静态代理的代理类多处出现代理逻辑的代码，并且同时静态代理的代理类需要自己硬编码。</p>
<h4 id="动态代理-1"><a href="#动态代理-1" class="headerlink" title="动态代理"></a>动态代理</h4><p><img src="/images/dynamic-proxy.jpeg"></p>
<p>动态代理的代理类类似于一个<strong>方法路由</strong>，对被代理对象的任何被代理方法的调用，都会被该路由<strong>转发</strong>到<strong>InvocationHandler</strong>代理逻辑处理类中，从而将代理类的<strong>生成</strong>和代理类的<strong>代理逻辑</strong>分开。<br><code>Java</code>动态代理生成的代理类是直接在内存中按照<code>class</code>文件格式生成了一个二进制文件，然后类加载器加载该二进制类文件，最后实例化一个代理类的实例。</p>
<h2 id="三、Java动态代理源码分析"><a href="#三、Java动态代理源码分析" class="headerlink" title="三、Java动态代理源码分析"></a>三、Java动态代理源码分析</h2><p>前面已经介绍了<code>Java</code>动态代理的基本用法，主要涉及到如下几个类和方法如下：（<code>JDK7</code>）</p>
<ul>
<li><code>java.lang.reflect.Proxy</code><ul>
<li><code>public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException</code></li>
<li><code>public static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;... interfaces) throws IllegalArgumentException</code></li>
</ul>
</li>
<li><code>sun.misc.ProxyGenerator</code><ul>
<li><code> public static byte[] generateProxyClass(final String name, Class[] interfaces)</code></li>
</ul>
</li>
<li><code>java.lang.reflect.InvocationHandler</code><ul>
<li><code>public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;</code></li>
</ul>
</li>
</ul>
<p>具体源代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns an instance of a proxy class for the specified interfaces</span></span><br><span class="line"><span class="comment"> * that dispatches method invocations to the specified invocation</span></span><br><span class="line"><span class="comment"> * handler.  This method is equivalent to:</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> *     Proxy.getProxyClass(loader, interfaces).</span></span><br><span class="line"><span class="comment"> *         getConstructor(new Class[] &#123; InvocationHandler.class &#125;).</span></span><br><span class="line"><span class="comment"> *         newInstance(new Object[] &#123; handler &#125;);</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&#123;<span class="doctag">@code</span> Proxy.newProxyInstance&#125; throws</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> IllegalArgumentException&#125; for the same reasons that</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> Proxy.getProxyClass&#125; does.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   loader the class loader to define the proxy class</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   interfaces the list of interfaces for the proxy class</span></span><br><span class="line"><span class="comment"> *          to implement</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   h the invocation handler to dispatch method invocations to</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  a proxy instance with the specified invocation handler of a</span></span><br><span class="line"><span class="comment"> *          proxy class that is defined by the specified class loader</span></span><br><span class="line"><span class="comment"> *          and that implements the specified interfaces</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  IllegalArgumentException if any of the restrictions on the</span></span><br><span class="line"><span class="comment"> *          parameters that may be passed to &#123;<span class="doctag">@code</span> getProxyClass&#125;</span></span><br><span class="line"><span class="comment"> *          are violated</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  NullPointerException if the &#123;<span class="doctag">@code</span> interfaces&#125; array</span></span><br><span class="line"><span class="comment"> *          argument or any of its elements are &#123;<span class="doctag">@code</span> null&#125;, or</span></span><br><span class="line"><span class="comment"> *          if the invocation handler, &#123;<span class="doctag">@code</span> h&#125;, is</span></span><br><span class="line"><span class="comment"> *          &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span><br><span class="line"><span class="params">                                      Class&lt;?&gt;[] interfaces,</span></span><br><span class="line"><span class="params">                                      InvocationHandler h)</span></span><br><span class="line">    <span class="keyword">throws</span> IllegalArgumentException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Look up or generate the designated proxy class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt; cl = getProxyClass(loader, interfaces);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Invoke its constructor with the designated invocation handler.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">cons</span> <span class="operator">=</span> cl.getConstructor(constructorParams);</span><br><span class="line">        <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; h &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(e.toString());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(e.toString());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(e.toString());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns the &#123;<span class="doctag">@code</span> java.lang.Class&#125; object for a proxy class</span></span><br><span class="line"><span class="comment">    * given a class loader and an array of interfaces.  The proxy class</span></span><br><span class="line"><span class="comment">    * will be defined by the specified class loader and will implement</span></span><br><span class="line"><span class="comment">    * all of the supplied interfaces.  If a proxy class for the same</span></span><br><span class="line"><span class="comment">    * permutation of interfaces has already been defined by the class</span></span><br><span class="line"><span class="comment">    * loader, then the existing proxy class will be returned; otherwise,</span></span><br><span class="line"><span class="comment">    * a proxy class for those interfaces will be generated dynamically</span></span><br><span class="line"><span class="comment">    * and defined by the class loader.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;There are several restrictions on the parameters that may be</span></span><br><span class="line"><span class="comment">    * passed to &#123;<span class="doctag">@code</span> Proxy.getProxyClass&#125;:</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">    * &lt;li&gt;All of the &#123;<span class="doctag">@code</span> Class&#125; objects in the</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> interfaces&#125; array must represent interfaces, not</span></span><br><span class="line"><span class="comment">    * classes or primitive types.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * &lt;li&gt;No two elements in the &#123;<span class="doctag">@code</span> interfaces&#125; array may</span></span><br><span class="line"><span class="comment">    * refer to identical &#123;<span class="doctag">@code</span> Class&#125; objects.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * &lt;li&gt;All of the interface types must be visible by name through the</span></span><br><span class="line"><span class="comment">    * specified class loader.  In other words, for class loader</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> cl&#125; and every interface &#123;<span class="doctag">@code</span> i&#125;, the following</span></span><br><span class="line"><span class="comment">    * expression must be true:</span></span><br><span class="line"><span class="comment">    * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">    *     Class.forName(i.getName(), false, cl) == i</span></span><br><span class="line"><span class="comment">    * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * &lt;li&gt;All non-public interfaces must be in the same package;</span></span><br><span class="line"><span class="comment">    * otherwise, it would not be possible for the proxy class to</span></span><br><span class="line"><span class="comment">    * implement all of the interfaces, regardless of what package it is</span></span><br><span class="line"><span class="comment">    * defined in.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * &lt;li&gt;For any set of member methods of the specified interfaces</span></span><br><span class="line"><span class="comment">    * that have the same signature:</span></span><br><span class="line"><span class="comment">    * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">    * &lt;li&gt;If the return type of any of the methods is a primitive</span></span><br><span class="line"><span class="comment">    * type or void, then all of the methods must have that same</span></span><br><span class="line"><span class="comment">    * return type.</span></span><br><span class="line"><span class="comment">    * &lt;li&gt;Otherwise, one of the methods must have a return type that</span></span><br><span class="line"><span class="comment">    * is assignable to all of the return types of the rest of the</span></span><br><span class="line"><span class="comment">    * methods.</span></span><br><span class="line"><span class="comment">    * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * &lt;li&gt;The resulting proxy class must not exceed any limits imposed</span></span><br><span class="line"><span class="comment">    * on classes by the virtual machine.  For example, the VM may limit</span></span><br><span class="line"><span class="comment">    * the number of interfaces that a class may implement to 65535; in</span></span><br><span class="line"><span class="comment">    * that case, the size of the &#123;<span class="doctag">@code</span> interfaces&#125; array must not</span></span><br><span class="line"><span class="comment">    * exceed 65535.</span></span><br><span class="line"><span class="comment">    * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;If any of these restrictions are violated,</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> Proxy.getProxyClass&#125; will throw an</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> IllegalArgumentException&#125;.  If the &#123;<span class="doctag">@code</span> interfaces&#125;</span></span><br><span class="line"><span class="comment">    * array argument or any of its elements are &#123;<span class="doctag">@code</span> null&#125;, a</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> NullPointerException&#125; will be thrown.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Note that the order of the specified proxy interfaces is</span></span><br><span class="line"><span class="comment">    * significant: two requests for a proxy class with the same combination</span></span><br><span class="line"><span class="comment">    * of interfaces but in a different order will result in two distinct</span></span><br><span class="line"><span class="comment">    * proxy classes.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>   loader the class loader to define the proxy class</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>   interfaces the list of interfaces for the proxy class</span></span><br><span class="line"><span class="comment">    *          to implement</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>  a proxy class that is defined in the specified class loader</span></span><br><span class="line"><span class="comment">    *          and that implements the specified interfaces</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span>  IllegalArgumentException if any of the restrictions on the</span></span><br><span class="line"><span class="comment">    *          parameters that may be passed to &#123;<span class="doctag">@code</span> getProxyClass&#125;</span></span><br><span class="line"><span class="comment">    *          are violated</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span>  NullPointerException if the &#123;<span class="doctag">@code</span> interfaces&#125; array</span></span><br><span class="line"><span class="comment">    *          argument or any of its elements are &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//根据一组接口列表interfaces，返回一个由类加载器loader加载的实现了所有interfaces的类对象</span></span><br><span class="line">   <span class="comment">//如果实现接口列表interfaces的类已经被加载过了；则直接返回缓存的类对象</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass(ClassLoader loader,</span><br><span class="line">                                        Class&lt;?&gt;... interfaces)</span><br><span class="line">       <span class="keyword">throws</span> IllegalArgumentException</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;interface limit exceeded&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Class&lt;?&gt; proxyClass = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* collect interface names to use as key for proxy class cache */</span></span><br><span class="line">       String[] interfaceNames = <span class="keyword">new</span> <span class="title class_">String</span>[interfaces.length];</span><br><span class="line"></span><br><span class="line">       <span class="comment">// for detecting duplicates</span></span><br><span class="line">       Set&lt;Class&lt;?&gt;&gt; interfaceSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//验证接口列表的接口对于参数给定的类加载器loader是否是可见的；</span></span><br><span class="line">       <span class="comment">//同时检查接口列表interfaces的合法性（无重复的接口、必须是接口类型）</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; interfaces.length; i++) &#123;</span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * Verify that the class loader resolves the name of this</span></span><br><span class="line"><span class="comment">            * interface to the same Class object.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="type">String</span> <span class="variable">interfaceName</span> <span class="operator">=</span> interfaces[i].getName();</span><br><span class="line">           Class&lt;?&gt; interfaceClass = <span class="literal">null</span>;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               interfaceClass = Class.forName(interfaceName, <span class="literal">false</span>, loader);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (interfaceClass != interfaces[i]) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                   interfaces[i] + <span class="string">&quot; is not visible from class loader&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * Verify that the Class object actually represents an</span></span><br><span class="line"><span class="comment">            * interface.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="keyword">if</span> (!interfaceClass.isInterface()) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                   interfaceClass.getName() + <span class="string">&quot; is not an interface&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * Verify that this interface is not a duplicate.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="keyword">if</span> (interfaceSet.contains(interfaceClass)) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                   <span class="string">&quot;repeated interface: &quot;</span> + interfaceClass.getName());</span><br><span class="line">           &#125;</span><br><span class="line">           interfaceSet.add(interfaceClass);</span><br><span class="line"></span><br><span class="line">           interfaceNames[i] = interfaceName;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Using string representations of the proxy interfaces as</span></span><br><span class="line"><span class="comment">        * keys in the proxy class cache (instead of their Class</span></span><br><span class="line"><span class="comment">        * objects) is sufficient because we require the proxy</span></span><br><span class="line"><span class="comment">        * interfaces to be resolvable by name through the supplied</span></span><br><span class="line"><span class="comment">        * class loader, and it has the advantage that using a string</span></span><br><span class="line"><span class="comment">        * representation of a class makes for an implicit weak</span></span><br><span class="line"><span class="comment">        * reference to the class.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       List&lt;String&gt; key = Arrays.asList(interfaceNames);</span><br><span class="line"></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Find or create the proxy class cache for the class loader.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       Map&lt;List&lt;String&gt;, Object&gt; cache;</span><br><span class="line">       <span class="keyword">synchronized</span> (loaderToCache) &#123;</span><br><span class="line">           cache = loaderToCache.get(loader);</span><br><span class="line">           <span class="keyword">if</span> (cache == <span class="literal">null</span>) &#123;</span><br><span class="line">               cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">               loaderToCache.put(loader, cache);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * This mapping will remain valid for the duration of this</span></span><br><span class="line"><span class="comment">            * method, without further synchronization, because the mapping</span></span><br><span class="line"><span class="comment">            * will only be removed if the class loader becomes unreachable.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Look up the list of interfaces in the proxy class cache using</span></span><br><span class="line"><span class="comment">        * the key.  This lookup will result in one of three possible</span></span><br><span class="line"><span class="comment">        * kinds of values:</span></span><br><span class="line"><span class="comment">        *     null, if there is currently no proxy class for the list of</span></span><br><span class="line"><span class="comment">        *         interfaces in the class loader,</span></span><br><span class="line"><span class="comment">        *     the pendingGenerationMarker object, if a proxy class for the</span></span><br><span class="line"><span class="comment">        *         list of interfaces is currently being generated,</span></span><br><span class="line"><span class="comment">        *     or a weak reference to a Class object, if a proxy class for</span></span><br><span class="line"><span class="comment">        *         the list of interfaces has already been generated.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">synchronized</span> (cache) &#123;</span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * Note that we need not worry about reaping the cache for</span></span><br><span class="line"><span class="comment">            * entries with cleared weak references because if a proxy class</span></span><br><span class="line"><span class="comment">            * has been garbage collected, its class loader will have been</span></span><br><span class="line"><span class="comment">            * garbage collected as well, so the entire cache will be reaped</span></span><br><span class="line"><span class="comment">            * from the loaderToCache map.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="keyword">do</span> &#123;</span><br><span class="line">               <span class="comment">//cache 的key是接口名数组生成的list；value是一个代理类对象的弱引用</span></span><br><span class="line">               <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">               <span class="keyword">if</span> (value <span class="keyword">instanceof</span> Reference) &#123;</span><br><span class="line">                   proxyClass = (Class&lt;?&gt;) ((Reference) value).get();</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (proxyClass != <span class="literal">null</span>) &#123;</span><br><span class="line">                   <span class="comment">// proxy class already generated: return it</span></span><br><span class="line">                   <span class="keyword">return</span> proxyClass;</span><br><span class="line">                   <span class="comment">//如果是一个标志符号，则说明有另外的线程正在创建代理类；则该线程挂起等待</span></span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value == pendingGenerationMarker) &#123;</span><br><span class="line">                   <span class="comment">// proxy class being generated: wait for it</span></span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       cache.wait();</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                       <span class="comment">/*</span></span><br><span class="line"><span class="comment">                        * The class generation that we are waiting for should</span></span><br><span class="line"><span class="comment">                        * take a small, bounded time, so we can safely ignore</span></span><br><span class="line"><span class="comment">                        * thread interrupts here.</span></span><br><span class="line"><span class="comment">                        */</span></span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">continue</span>;<span class="comment">//被唤醒后；继续check是否存在类对象</span></span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    * No proxy class for this list of interfaces has been</span></span><br><span class="line"><span class="comment">                    * generated or is being generated, so we will go and</span></span><br><span class="line"><span class="comment">                    * generate it now.  Mark it as pending generation.</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                   <span class="comment">//不存在代理类的时候，需要自己去生成代理类；生成代理类之前先置一个状态标志对象pendingGenerationMarker</span></span><br><span class="line">                   cache.put(key, pendingGenerationMarker);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="type">String</span> <span class="variable">proxyPkg</span> <span class="operator">=</span> <span class="literal">null</span>;     <span class="comment">// package to define proxy class in</span></span><br><span class="line"></span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * Record the package of a non-public proxy interface so that the</span></span><br><span class="line"><span class="comment">            * proxy class will be defined in the same package.  Verify that</span></span><br><span class="line"><span class="comment">            * all non-public proxy interfaces are in the same package.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; interfaces.length; i++) &#123;</span><br><span class="line">               <span class="type">int</span> <span class="variable">flags</span> <span class="operator">=</span> interfaces[i].getModifiers();</span><br><span class="line">               <span class="keyword">if</span> (!Modifier.isPublic(flags)) &#123;</span><br><span class="line">                   <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> interfaces[i].getName();</span><br><span class="line">                   <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> name.lastIndexOf(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                   <span class="type">String</span> <span class="variable">pkg</span> <span class="operator">=</span> ((n == -<span class="number">1</span>) ? <span class="string">&quot;&quot;</span> : name.substring(<span class="number">0</span>, n + <span class="number">1</span>));</span><br><span class="line">                   <span class="keyword">if</span> (proxyPkg == <span class="literal">null</span>) &#123;</span><br><span class="line">                       proxyPkg = pkg;</span><br><span class="line">                   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pkg.equals(proxyPkg)) &#123;</span><br><span class="line">                       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                           <span class="string">&quot;non-public interfaces from different packages&quot;</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (proxyPkg == <span class="literal">null</span>) &#123;     <span class="comment">// if no non-public proxy interfaces,</span></span><br><span class="line">               proxyPkg = <span class="string">&quot;&quot;</span>;          <span class="comment">// use the unnamed package</span></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           &#123;</span><br><span class="line">               <span class="comment">/*</span></span><br><span class="line"><span class="comment">                * Choose a name for the proxy class to generate.</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">               <span class="type">long</span> num;</span><br><span class="line">               <span class="keyword">synchronized</span> (nextUniqueNumberLock) &#123;</span><br><span class="line">                   num = nextUniqueNumber++;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="type">String</span> <span class="variable">proxyName</span> <span class="operator">=</span> proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line">               <span class="comment">/*</span></span><br><span class="line"><span class="comment">                * Verify that the class loader hasn&#x27;t already</span></span><br><span class="line"><span class="comment">                * defined a class with the chosen name.</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line"></span><br><span class="line">               <span class="comment">/*</span></span><br><span class="line"><span class="comment">                * Generate the specified proxy class.</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">               <span class="comment">//重点在这里；调用ProxyGenerator的静态方法去生成一个代理类，得到类文件的字节数组</span></span><br><span class="line">               <span class="type">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">                   proxyName, interfaces);</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="comment">//用类加载器加载二进制类文件，得到代理类对象</span></span><br><span class="line">                   proxyClass = defineClass0(loader, proxyName,</span><br><span class="line">                       proxyClassFile, <span class="number">0</span>, proxyClassFile.length);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (ClassFormatError e) &#123;</span><br><span class="line">                   <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    * A ClassFormatError here means that (barring bugs in the</span></span><br><span class="line"><span class="comment">                    * proxy class generation code) there was some other</span></span><br><span class="line"><span class="comment">                    * invalid aspect of the arguments supplied to the proxy</span></span><br><span class="line"><span class="comment">                    * class creation (such as virtual machine limitations</span></span><br><span class="line"><span class="comment">                    * exceeded).</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(e.toString());</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// add to set of all generated proxy classes, for isProxyClass</span></span><br><span class="line">           proxyClasses.put(proxyClass, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * We must clean up the &quot;pending generation&quot; state of the proxy</span></span><br><span class="line"><span class="comment">            * class cache entry somehow.  If a proxy class was successfully</span></span><br><span class="line"><span class="comment">            * generated, store it in the cache (with a weak reference);</span></span><br><span class="line"><span class="comment">            * otherwise, remove the reserved entry.  In all cases, notify</span></span><br><span class="line"><span class="comment">            * all waiters on reserved entries in this cache.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="keyword">synchronized</span> (cache) &#123;</span><br><span class="line">               <span class="keyword">if</span> (proxyClass != <span class="literal">null</span>) &#123;</span><br><span class="line">                   <span class="comment">//加入缓存</span></span><br><span class="line">                   cache.put(key, <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;Class&lt;?&gt;&gt;(proxyClass));</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   cache.remove(key);</span><br><span class="line">               &#125;</span><br><span class="line">               cache.notifyAll();<span class="comment">//不管创建代理类是否成功，唤醒在cache上面等待的线程</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> proxyClass;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Generate a class file for the proxy class.  This method drives the</span></span><br><span class="line"><span class="comment"> * class file generation process.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//根据得到的方法信息、类信息；按照JVM的规范动态的生成一个代理类的二进制文件</span></span><br><span class="line"> <span class="comment">//该过程比较复杂涉及到许多JVM的指令</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">byte</span>[] generateClassFile() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ============================================================</span></span><br><span class="line"><span class="comment">     * Step 1: Assemble ProxyMethod objects for all methods to</span></span><br><span class="line"><span class="comment">     * generate proxy dispatching code for.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Record that proxy methods are needed for the hashCode, equals,</span></span><br><span class="line"><span class="comment">     * and toString methods of java.lang.Object.  This is done before</span></span><br><span class="line"><span class="comment">     * the methods from the proxy interfaces so that the methods from</span></span><br><span class="line"><span class="comment">     * java.lang.Object take precedence over duplicate methods in the</span></span><br><span class="line"><span class="comment">     * proxy interfaces.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    addProxyMethod(hashCodeMethod, Object.class);</span><br><span class="line">    addProxyMethod(equalsMethod, Object.class);</span><br><span class="line">    addProxyMethod(toStringMethod, Object.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Now record all of the methods from the proxy interfaces, giving</span></span><br><span class="line"><span class="comment">     * earlier interfaces precedence over later ones with duplicate</span></span><br><span class="line"><span class="comment">     * methods.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; interfaces.length; i++) &#123;</span><br><span class="line">        Method[] methods = interfaces[i].getMethods();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; methods.length; j++) &#123;</span><br><span class="line">            addProxyMethod(methods[j], interfaces[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * For each set of proxy methods with the same signature,</span></span><br><span class="line"><span class="comment">     * verify that the methods&#x27; return types are compatible.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (List&lt;ProxyMethod&gt; sigmethods : proxyMethods.values()) &#123;</span><br><span class="line">        checkReturnTypes(sigmethods);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ============================================================</span></span><br><span class="line"><span class="comment">     * Step 2: Assemble FieldInfo and MethodInfo structs for all of</span></span><br><span class="line"><span class="comment">     * fields and methods in the class we are generating.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        methods.add(generateConstructor());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (List&lt;ProxyMethod&gt; sigmethods : proxyMethods.values()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (ProxyMethod pm : sigmethods) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// add static field for method&#x27;s Method object</span></span><br><span class="line">                fields.add(<span class="keyword">new</span> <span class="title class_">FieldInfo</span>(pm.methodFieldName,</span><br><span class="line">                    <span class="string">&quot;Ljava/lang/reflect/Method;&quot;</span>,</span><br><span class="line">                     ACC_PRIVATE | ACC_STATIC));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// generate code for proxy method and add it</span></span><br><span class="line">                methods.add(pm.generateMethod());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        methods.add(generateStaticInitializer());</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(<span class="string">&quot;unexpected I/O Exception&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (methods.size() &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;method limit exceeded&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fields.size() &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;field limit exceeded&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ============================================================</span></span><br><span class="line"><span class="comment">     * Step 3: Write the final class file.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Make sure that constant pool indexes are reserved for the</span></span><br><span class="line"><span class="comment">     * following items before starting to write the final class file.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    cp.getClass(dotToSlash(className));</span><br><span class="line">    cp.getClass(superclassName);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; interfaces.length; i++) &#123;</span><br><span class="line">        cp.getClass(dotToSlash(interfaces[i].getName()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Disallow new constant pool additions beyond this point, since</span></span><br><span class="line"><span class="comment">     * we are about to write the final constant pool table.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    cp.setReadOnly();</span><br><span class="line"></span><br><span class="line">    <span class="type">ByteArrayOutputStream</span> <span class="variable">bout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">    <span class="type">DataOutputStream</span> <span class="variable">dout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(bout);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Write all the items of the &quot;ClassFile&quot; structure.</span></span><br><span class="line"><span class="comment">         * See JVMS section 4.1.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">                                    <span class="comment">// u4 magic;</span></span><br><span class="line">        dout.writeInt(<span class="number">0xCAFEBABE</span>);</span><br><span class="line">                                    <span class="comment">// u2 minor_version;</span></span><br><span class="line">        dout.writeShort(CLASSFILE_MINOR_VERSION);</span><br><span class="line">                                    <span class="comment">// u2 major_version;</span></span><br><span class="line">        dout.writeShort(CLASSFILE_MAJOR_VERSION);</span><br><span class="line"></span><br><span class="line">        cp.write(dout);             <span class="comment">// (write constant pool)</span></span><br><span class="line"></span><br><span class="line">                                    <span class="comment">// u2 access_flags;</span></span><br><span class="line">        dout.writeShort(ACC_PUBLIC | ACC_FINAL | ACC_SUPER);</span><br><span class="line">                                    <span class="comment">// u2 this_class;</span></span><br><span class="line">        dout.writeShort(cp.getClass(dotToSlash(className)));</span><br><span class="line">                                    <span class="comment">// u2 super_class;</span></span><br><span class="line">        dout.writeShort(cp.getClass(superclassName));</span><br><span class="line"></span><br><span class="line">                                    <span class="comment">// u2 interfaces_count;</span></span><br><span class="line">        dout.writeShort(interfaces.length);</span><br><span class="line">                                    <span class="comment">// u2 interfaces[interfaces_count];</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; interfaces.length; i++) &#123;</span><br><span class="line">            dout.writeShort(cp.getClass(</span><br><span class="line">                dotToSlash(interfaces[i].getName())));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">                                    <span class="comment">// u2 fields_count;</span></span><br><span class="line">        dout.writeShort(fields.size());</span><br><span class="line">                                    <span class="comment">// field_info fields[fields_count];</span></span><br><span class="line">        <span class="keyword">for</span> (FieldInfo f : fields) &#123;</span><br><span class="line">            f.write(dout);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">                                    <span class="comment">// u2 methods_count;</span></span><br><span class="line">        dout.writeShort(methods.size());</span><br><span class="line">                                    <span class="comment">// method_info methods[methods_count];</span></span><br><span class="line">        <span class="keyword">for</span> (MethodInfo m : methods) &#123;</span><br><span class="line">            m.write(dout);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">                                     <span class="comment">// u2 attributes_count;</span></span><br><span class="line">        dout.writeShort(<span class="number">0</span>); <span class="comment">// (no ClassFile attributes for proxy classes)</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(<span class="string">&quot;unexpected I/O Exception&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bout.toByteArray();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过反编译生成的动态代理类的文件，可以得到</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span></span><br><span class="line">  <span class="keyword">extends</span> <span class="title class_">Proxy</span></span><br><span class="line">  <span class="keyword">implements</span> <span class="title class_">IReal</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> $Proxy0(InvocationHandler paramInvocationHandler)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">super</span>(paramInvocationHandler);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object paramObject)</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> ((Boolean)<span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m1, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; paramObject &#125;)).booleanValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Error|RuntimeException localError)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> localError;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable localThrowable)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(localThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">doSomeThing</span><span class="params">(String paramString)</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m3, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; paramString &#125;);<span class="comment">//方法的转发;反射调用InvocationHandler的invoke方法</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Error|RuntimeException localError)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> localError;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable localThrowable)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(localThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> (String)<span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m2, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Error|RuntimeException localError)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> localError;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable localThrowable)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(localThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> ((Integer)<span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m0, <span class="literal">null</span>)).intValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Error|RuntimeException localError)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> localError;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable localThrowable)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(localThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">      m1 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;equals&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>) &#125;);</span><br><span class="line">      m3 = Class.forName(<span class="string">&quot;trick.IReal&quot;</span>).getMethod(<span class="string">&quot;doSomeThing&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; Class.forName(<span class="string">&quot;java.lang.String&quot;</span>) &#125;);</span><br><span class="line">      m2 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;toString&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]);</span><br><span class="line">      m0 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;hashCode&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (NoSuchMethodException localNoSuchMethodException)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchMethodError</span>(localNoSuchMethodException.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ClassNotFoundException localClassNotFoundException)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoClassDefFoundError</span>(localClassNotFoundException.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p><code>java</code>动态代理的应用在框架中十分广泛，例如<code>Spring</code>框架用动态代理来实现<code>AOP</code>、<code>Struts2</code>框架利用动态代理实现拦截器。<br><code>AOP</code>中的<code>代理逻辑点</code>又称为<code>切面的切入点(cut point)</code>。另外，实现<code>AOP</code>概念的方式是动态代理，但动态代理的形式有很多种，<code>JDK</code>提供的这种只是其中一种，还有涉及到类加载器加载类前、加载类后植入字节码等形式。</p>
<h1 id="See-Also"><a href="#See-Also" class="headerlink" title="See Also"></a>See Also</h1><p>[1] <a href="http://www.cnblogs.com/flyoung2008/archive/2013/08/11/3251148.html">彻底理解JAVA动态代理</a></p>
<p>[2] <a href="http://rejoy.iteye.com/blog/1627405">JDK动态代理实现原理</a></p>
<p>[3]<a href="https://my.oschina.net/u/1412027/blog/189480">AOP动态代理的实现机制</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://spground.github.io/2017/03/31/HashMap%20and%20LinkedHashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Spground">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spground Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Spground Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/03/31/HashMap%20and%20LinkedHashMap/" class="post-title-link" itemprop="url">HashMap与LinkedHashMap</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-03-31 00:00:00" itemprop="dateCreated datePublished" datetime="2017-03-31T00:00:00+08:00">2017-03-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-24 22:30:21" itemprop="dateModified" datetime="2025-09-24T22:30:21+08:00">2025-09-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>在日常开发中我们经常会批量操作数据，因此很多高级语言除了提供数组，还给我们提供很多高级的、抽象的数据类型来让我们处理批量数据时得心应手。由于这些轮子对于程序的性能是比较关键的轮子，因此很多语言都内置的提供了比较精致的实现。在<code>java</code>中，这种实现被称为集合框架。集合框架包含的接口、类十分丰富，而且功能强大，因此理解并熟悉<code>java</code>集合框架，对于写出正确高效的程序是十分有必要的。<code>java</code>集合框架中包含两个重要的类<code>LinkedHashMap</code>与<code>HashMap</code>，它们常常被用于按<code>key-value</code>存储、操作数据，对于常见的操作都是常数的时间复杂度，因此被广泛使用，虽然这两个类的作用类似，但是他们的实现和使用场景稍微不同。</p>
<h2 id="2-二者的区别"><a href="#2-二者的区别" class="headerlink" title="2. 二者的区别"></a>2. 二者的区别</h2><p><code>HashMap</code>与<code>LinkedHashMap</code>都实现了<code>Map</code>接口，二者的存储形式都是采用**<code>bucket</code>加链表**的形式来进行存储的。二者的主要区别:</p>
<ul>
<li><code>HashMap</code>由于是按照<code>key</code>的<code>hash</code>值映射到对应的<code>bucket</code>中，<strong>无法保证遍历<code>HashMap</code>时的顺序是预期的顺序</strong></li>
<li><code>LinkedHashMap</code>在<code>HashMap</code>的基础上加以改进，却可以保证遍历的顺序要么是<strong>插入<code>item</code>的顺序或者<code>LRU</code>访问的顺序</strong></li>
</ul>
<p>这是因为<code>LinkedHashMap</code><strong>维护了一个双向链表</strong>来记录数据插入的顺序，因此在迭代遍历生成的迭代器的时候，是按照双向链表的路径进行遍历的。</p>
<p>如果选择<code>LRU</code>访问的顺序，<code>LinkedHashMap</code>对于访问过的<code>item</code>会将其<strong>移动到双链表的末尾</strong>，这样保证最近访问过的<code>item</code>是处于链表末端，因此较老其不经常使用的<code>item</code>会处于<strong>链表前端</strong>。这个特性恰好符合<code>LRU</code>的思想，因此<code>LinkedHashMap</code>可以用来实现**<code>LRU Cache</code>**。<code>Android</code>提供的<code>SDK</code>的<code>LruCache</code>类便是利用<code>LinkedHashMap</code>实现了基于<code>Lru</code>规则的缓存功能。</p>
<p>另外可以发现在<code>java8</code>中<code>HashMap</code>和<code>LinkedHashMap</code>有了改动，据说在某些<code>Hash</code>碰撞严重时，性能也不会太差。<code>java8</code>之前的<code>Map</code>实现的问题是当出现某个<code>bucket</code>的后面的链表太长了，也就是说发生<code>hash</code>冲突的<code>item</code>太多了，这样会导致访问操作退化到了<code>O(n)</code>。</p>
<p><code>java8</code>的改进便是当<code>bucket</code>的链表长度大于阈值的时候，会将链表重新组织为一颗<strong>红黑树</strong>，这样在<code>hash</code>碰撞严重的时候性能还是可以保证到<code>log(n)</code>.改进前后的示意图如下所示：</p>
<p><img src="/images/hashmap-1.png"></p>
<p><img src="/images/hashmap-2.png" alt="这里写图片描述"></p>
<p>在使用<code>LinkedHashMap</code>和<code>HashMap</code>的时候应该注意<code>Key</code>的<code>hash</code>值是怎么取得，如果不同的<code>key</code>经常出现相同的hash值，则会频繁出现冲突，降低性能。</p>
<p>同时，由于改进后的<code>HashMap</code>会在某个<code>bucket</code>后的链表长度超过某个阈值时，重新将连边组织为一颗红黑树，因此在<code>java8</code>上的<code>key</code>最好实现<code>Comparable</code>接口来保证<code>key</code>是可以通过<code>compareTo</code>进行比较的，因为这样会简化建立红黑树的判断流程，提高效率。当然如果不实现<code>Comparable</code>接口的话，也会有相应的方法保证<code>hash</code>值冲突的<code>item</code>形成一颗平衡的红黑树。</p>
<h2 id="3-源码阅读"><a href="#3-源码阅读" class="headerlink" title="3. 源码阅读"></a>3. 源码阅读</h2><p>此处选取几个关键的地方进行源码分析：</p>
<ol>
<li>对于<code>HashMap</code>重点关注这几个方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> hash)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">tieBreakOrder</span><span class="params">(Object a, Object b)</span></span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">           <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line"><span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">    n = (tab = resize()).length;</span><br><span class="line"><span class="comment">//通过hash找到对应的桶，如果桶空则直接新建一个链表节点置于桶中并成为链表头</span></span><br><span class="line"><span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">    tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//桶不为空，则从桶内存放的链表头开始查找</span></span><br><span class="line">    Node&lt;K,V&gt; e; K k;</span><br><span class="line">    <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">        ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))<span class="comment">//运气好的话，在链表头就找到了，注意此处key的匹配规则，首先是 == 匹配，然后再是调用equals方法匹配</span></span><br><span class="line">        e = p;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)<span class="comment">//如果该桶内存放的不再是链表，而是一颗树，则按树的规则去执行。</span></span><br><span class="line">        e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;<span class="comment">//按链表顺序查找，并记录链表的节点数目</span></span><br><span class="line">            <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;<span class="comment">//如果查找到了链表尾，认为匹配到key,则新建一个节点</span></span><br><span class="line">                p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                <span class="comment">//java8改进的地方！！！！如果桶内链表的长度大于了阈值则树形化该链表</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                    treeifyBin(tab, hash);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))<span class="comment">//匹配到一个存在的item</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            p = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果成功匹配了key，则此次put操作仅仅是修改value而没有插入新的节点</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">        <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">        <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">            e.value = value;</span><br><span class="line">        afterNodeAccess(e);<span class="comment">//访问元素e的回调，注意比较LinkedHashMap在此处的实现。</span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">++modCount;</span><br><span class="line"><span class="keyword">if</span> (++size &gt; threshold)<span class="comment">//如果真个hashmap的长度超过了阈值，就说明可能会出现严重的hash冲突此时就应该resize()，rehash。</span></span><br><span class="line">    resize();</span><br><span class="line">afterNodeInsertion(evict);<span class="comment">//插入元素e的回调，注意比较LinkedHashMap在此处的实现。</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Replaces all linked nodes in bin at index for given hash unless</span></span><br><span class="line"><span class="comment">* table is too small, in which case resizes instead.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line"><span class="type">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line"><span class="comment">//如果Hash表的桶数小于可以树形化的阈值，则只是扩大桶数，进行再Hash</span></span><br><span class="line"><span class="comment">//我估计在设计的时候权衡了重建一颗红黑树和再Hash的cost，当桶的数量很少的时候，再hash划算一些</span></span><br><span class="line"><span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">    resize();</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//从链表头hd,将每一个节点转化为一个树节点且继续保持链表的顺序</span></span><br><span class="line">        TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">            hd = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p.prev = tl;</span><br><span class="line">            tl.next = p;</span><br><span class="line">        &#125;</span><br><span class="line">        tl = p;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">if</span> ((tab[index] = hd) != <span class="literal">null</span>)</span><br><span class="line">        hd.treeify(tab);<span class="comment">//最终树形化链表在这里完成</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Forms tree of the nodes linked from this node.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> root of tree</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; root = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//以当前对象作为root，开始构建一颗红黑树</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="built_in">this</span>, next; x != <span class="literal">null</span>; x = next) &#123;</span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">        x.left = x.right = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            x.parent = <span class="literal">null</span>;</span><br><span class="line">            x.red = <span class="literal">false</span>;</span><br><span class="line">            root = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">K</span> <span class="variable">k</span> <span class="operator">=</span> x.key;<span class="comment">//当前树节点x包含的key</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> x.hash;<span class="comment">//当前树节x点的hash值</span></span><br><span class="line">            Class&lt;?&gt; kc = <span class="literal">null</span>;<span class="comment">//x节点包含的key的类</span></span><br><span class="line">            <span class="comment">//从红黑树的根节点开始寻找合适的插入的位置，然后再平衡该树。</span></span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                <span class="type">int</span> dir, ph;</span><br><span class="line">                <span class="type">K</span> <span class="variable">pk</span> <span class="operator">=</span> p.key;</span><br><span class="line">                <span class="comment">//正常来讲，由于HashMap是树形化一个桶内的链表，因此</span></span><br><span class="line">                <span class="comment">//每个链表的节点的hashCode()返回的值应该是一样的。</span></span><br><span class="line">                <span class="comment">//因此这里两个分支(ph = p.hash) &gt; h 和 ph &lt; h应该都不会被执行</span></span><br><span class="line">                <span class="comment">//这里会直接进入分支3进行判断</span></span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)<span class="comment">//分支1</span></span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)<span class="comment">//分支2</span></span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">                   <span class="comment">//分支3 当两个节点的hash值相等的时候（事实上绝大部分都是这样的情况）</span></span><br><span class="line">                    <span class="comment">//则反射判断x节点的key的类是否是实现了Comparable接口，如果实现了则利用compareTo方法进行比较判断，从而决定插入的位置；</span></span><br><span class="line">                    <span class="comment">//如果没有实现Comparable接口或者实现了Comparable接口但是compareTo比较的结果还是一致，则利用tieBreakOrder来决定大小。</span></span><br><span class="line">                    <span class="comment">//因为红黑树的节点都要有大小区分的，不能出现大小相同的节点，因此无论采用哪种量化方式，一定得比较个大小出来。</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                          (kc = comparableClassFor(k)) == <span class="literal">null</span>) ||</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                    dir = tieBreakOrder(k, pk);<span class="comment">//当俩节点hashCode返回值相等且没有实现comparable接口，在这种尴尬僵持的局面，就需要调用tieBreakOrder方法</span></span><br><span class="line">                <span class="comment">//来一较高低了。因此java8中对于HashMap的文档中建议Key要实现Comparable接口，这样此处就不会进入到如此尴尬僵持的局面，会提高些许性能，毕竟后面</span></span><br><span class="line">                <span class="comment">//打破僵局是需要付出代价的</span></span><br><span class="line"></span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                <span class="comment">//直到走到叶节点，则进行插入</span></span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    x.parent = xp;</span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x;<span class="comment">//如果该节点x比父亲节点p小，则作为节点p的左孩子</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    root = balanceInsertion(root, x);<span class="comment">//红黑树都有的操作，插入节点后需要进行调整以继续保证红黑树的性质</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    moveRootToFront(tab, root);<span class="comment">//保证桶内存放的是红黑树的根节点root</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Forms tree of the nodes linked from this node.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> root of tree</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; root = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//以当前对象作为root，开始构建一颗红黑树</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="built_in">this</span>, next; x != <span class="literal">null</span>; x = next) &#123;</span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">        x.left = x.right = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            x.parent = <span class="literal">null</span>;</span><br><span class="line">            x.red = <span class="literal">false</span>;</span><br><span class="line">            root = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">K</span> <span class="variable">k</span> <span class="operator">=</span> x.key;<span class="comment">//当前树节点x包含的key</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> x.hash;<span class="comment">//当前树节x点的hash值</span></span><br><span class="line">            Class&lt;?&gt; kc = <span class="literal">null</span>;<span class="comment">//x节点包含的key的类</span></span><br><span class="line">            <span class="comment">//从红黑树的根节点开始寻找合适的插入的位置，然后再平衡该树。</span></span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                <span class="type">int</span> dir, ph;</span><br><span class="line">                <span class="type">K</span> <span class="variable">pk</span> <span class="operator">=</span> p.key;</span><br><span class="line">                <span class="comment">//正常来讲，由于HashMap是树形化一个桶内的链表，因此</span></span><br><span class="line">                <span class="comment">//每个链表的节点的hashCode()返回的值应该是一样的。</span></span><br><span class="line">                <span class="comment">//因此这里两个分支(ph = p.hash) &gt; h 和 ph &lt; h应该都不会被执行</span></span><br><span class="line">                <span class="comment">//这里会直接进入分支3进行判断</span></span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)<span class="comment">//分支1</span></span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)<span class="comment">//分支2</span></span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">                   <span class="comment">//分支3 当两个节点的hash值相等的时候（事实上绝大部分都是这样的情况）</span></span><br><span class="line">                    <span class="comment">//则反射判断x节点的key的类是否是实现了Comparable接口，如果实现了则利用compareTo方法进行比较判断，从而决定插入的位置；</span></span><br><span class="line">                    <span class="comment">//如果没有实现Comparable接口或者实现了Comparable接口但是compareTo比较的结果还是一致，则利用tieBreakOrder来决定大小。</span></span><br><span class="line">                    <span class="comment">//因为红黑树的节点都要有大小区分的，不能出现大小相同的节点，因此无论采用哪种量化方式，一定得比较个大小出来。</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                          (kc = comparableClassFor(k)) == <span class="literal">null</span>) ||</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                    dir = tieBreakOrder(k, pk);<span class="comment">//当俩节点hashCode返回值相等且没有实现comparable接口，在这种尴尬僵持的局面，就需要调用tieBreakOrder方法</span></span><br><span class="line">                <span class="comment">//来一较高低了。因此java8中对于HashMap的文档中建议Key要实现Comparable接口，这样此处就不会进入到如此尴尬僵持的局面，会提高些许性能，毕竟后面</span></span><br><span class="line">                <span class="comment">//打破僵局是需要付出代价的</span></span><br><span class="line"></span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                <span class="comment">//直到走到叶节点，则进行插入</span></span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    x.parent = xp;</span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x;<span class="comment">//如果该节点x比父亲节点p小，则作为节点p的左孩子</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    root = balanceInsertion(root, x);<span class="comment">//红黑树都有的操作，插入节点后需要进行调整以继续保证红黑树的性质</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    moveRootToFront(tab, root);<span class="comment">//保证桶内存放的是红黑树的根节点root</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tie-breaking utility for ordering insertions when equal</span></span><br><span class="line"><span class="comment"> * hashCodes and non-comparable. We don&#x27;t require a total</span></span><br><span class="line"><span class="comment"> * order, just a consistent insertion rule to maintain</span></span><br><span class="line"><span class="comment"> * equivalence across rebalancings. Tie-breaking further than</span></span><br><span class="line"><span class="comment"> * necessary simplifies testing a bit.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">tieBreakOrder</span><span class="params">(Object a, Object b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> d;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">null</span> || b == <span class="literal">null</span> ||</span><br><span class="line">        (d = a.getClass().getName().</span><br><span class="line">         compareTo(b.getClass().getName())) == <span class="number">0</span>)<span class="comment">//先利用两对象的类名的大小比较，若仍然陷入僵局，则调用</span></span><br><span class="line">        <span class="comment">//System.identityHashCode()的方法该方法会返回对象唯一的真实的hash值无论对象的类是否重写了hashCode方法</span></span><br><span class="line">        d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ?</span><br><span class="line">             -<span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p>以上部分简要的分析了<code>HashMap</code>的改进处的源码。</p>
<ol start="2">
<li>对于<code>LinkedHashMap</code>,主要阅读分析其如<strong>何保证迭代的顺序</strong>、<strong>具有LRU的性质</strong><br>  <code>LinkedHashMap</code>是<code>HashMap</code>的子类，只是稍加改造便使得其具有链表的顺序性质。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedHashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">HashMap</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The head (eldest) of the doubly linked list.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;<span class="comment">//维护的双向链表的</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The tail (youngest) of the doubly linked list.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;<span class="comment">//维护的双向链表的表尾</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The iteration ordering method for this linked hash map: &lt;tt&gt;true&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">* for access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> accessOrder;<span class="comment">//是访问顺序还是插入顺序</span></span><br></pre></td></tr></table></figure>

<p>主要关注以下几个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt; <span class="title function_">newNode</span><span class="params">(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> </span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">linkNodeLast</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeInsertion</span><span class="params">(<span class="type">boolean</span> evict)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个方法是HashMap的hook方法，只是简单的扩展了HashMap的Node类，就完成了LinkedHashMap的大部分功能</span></span><br><span class="line"><span class="comment">//不得不说类的设计很巧妙</span></span><br><span class="line">Node&lt;K,V&gt; <span class="title function_">newNode</span><span class="params">(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> &#123;</span><br><span class="line">LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>.Entry&lt;K,V&gt;(hash, key, value, e);<span class="comment">//将节点e</span></span><br><span class="line">linkNodeLast(p);<span class="comment">//将该Entry链接到LinkedHashMap维护的双向链表的表尾</span></span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* HashMap.Node subclass for normal LinkedHashMap entries.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">HashMap</span>.Node&lt;K,V&gt; &#123;</span><br><span class="line">Entry&lt;K,V&gt; before, after;</span><br><span class="line">Entry(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">    <span class="built_in">super</span>(hash, key, value, next);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// link at the end of list</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">linkNodeLast</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> &#123;</span><br><span class="line">LinkedHashMap.Entry&lt;K,V&gt; last = tail;<span class="comment">//tail是维护的双链表的表尾</span></span><br><span class="line">tail = p;</span><br><span class="line"><span class="comment">//接下就是简单的链表链接操作</span></span><br><span class="line"><span class="keyword">if</span> (last == <span class="literal">null</span>)</span><br><span class="line">    head = p;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    p.before = last;</span><br><span class="line">    last.after = p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>由于<code>LinkedHashMap</code>没有重写<code>put</code>方法，因此它复用了<code>HashMap</code>的<code>put</code>方法，只是简单重写了**<code>hook</code>方法**<code>newNode</code>。因此<code>put</code>方法不用分析了。到此应该就可以去看迭代器的实现了，讲道理的话应该是按照<strong>双向链表的顺序</strong>来迭代的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">LinkedHashIterator</span> &#123;</span><br><span class="line">LinkedHashMap.Entry&lt;K,V&gt; next;</span><br><span class="line">LinkedHashMap.Entry&lt;K,V&gt; current;</span><br><span class="line"><span class="type">int</span> expectedModCount;</span><br><span class="line"></span><br><span class="line">LinkedHashIterator() &#123;</span><br><span class="line">    next = head;<span class="comment">//head存放的是双向链表的表头</span></span><br><span class="line">    expectedModCount = modCount;</span><br><span class="line">    current = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> next != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> LinkedHashMap.Entry&lt;K,V&gt; <span class="title function_">nextNode</span><span class="params">()</span> &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; e = next;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    current = e;</span><br><span class="line">    next = e.after;<span class="comment">//依次迭代</span></span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>自此已经大致清楚了<code>LinkedHashMap</code>是如何简单的改造了<code>HashMap</code>而拥有了顺序的迭代。</p>
<p><code>LinkedHashMap</code>不仅仅遍历是有序的，而且还可以选择是何种顺序，是<strong>插入顺序</strong>还是<strong>访问顺序</strong>。</p>
<p><code>acceeOrder</code>的定义了遍历是何种顺序，该值默认是<code>false</code>,若想为<code>true</code>,需要显示的指定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> &#123; <span class="comment">// move node to last</span></span><br><span class="line">LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line"><span class="comment">//如果是访问顺序，则将节点e放在链表尾部</span></span><br><span class="line"><span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">    p.after = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="literal">null</span>)</span><br><span class="line">        head = a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        b.after = a;</span><br><span class="line">    <span class="keyword">if</span> (a != <span class="literal">null</span>)</span><br><span class="line">        a.before = b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        last = b;</span><br><span class="line">    <span class="keyword">if</span> (last == <span class="literal">null</span>)</span><br><span class="line">        head = p;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        p.before = last;</span><br><span class="line">        last.after = p;</span><br><span class="line">    &#125;</span><br><span class="line">    tail = p;</span><br><span class="line">    ++modCount;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样无论是<code>put</code>还是<code>get</code>操作都会导致该元素<code>e</code>会被放在链表尾部。这样链表表头部分的元素的访问时间就相对久远了，这个特性就恰恰比较符合<code>LRU</code>的思想。因此当<code>LinkiedHashMap</code>的元素个数超过一定的阈值时（因为缓存的容量是有限的），就需要删除某些缓存<code>item</code>了。在<code>LinkedHashMap</code>中就有这样的<code>CallBack</code>来完成这个目的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeInsertion</span><span class="params">(<span class="type">boolean</span> evict)</span> &#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line"><span class="comment">//如果该LinkedHashMap允许删除老元素，则移除老元素</span></span><br><span class="line"><span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="literal">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">    <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> first.key;</span><br><span class="line">    removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>LinkedHashMap</code>默认是不移除老元素，因此要实现Lru需要重写该方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通常会这么重写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ENTRIES</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry eldest)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; MAX_ENTRIES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看出来<code>LinkedHashMap</code>只是稍微加以改进，就具备了额外的功能。这种类的设计十分精致，值得借鉴。<br><code>HashMap</code>预留了几个关键的<code>hook</code>方法给扩展类(此处是<code>LinkedHashMap</code>)，例如<code>newNode()</code>,<code>afterAccess()</code> <code>afterInsertion()</code>等。这样就是策略和机制分离了，便于扩展类添加更丰富的功能。当然我们也可以按照需要扩展<code>HashMap</code>,从而改变其某些行为。</p>
<p>但是<code>HashMap</code>类中的<code>TreeNode</code>怎么会去继承子类<code>LinkedHashMap</code>的<code>Entry</code>，难道仅仅是为了少些几行代码？我觉得这个设计不是很好。毕竟父类不应该去获取子类的某些信息，有点本末倒置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Entry for Tree bins. Extends LinkedHashMap.Entry (which in turn</span></span><br><span class="line"><span class="comment">* extends Node) so can be used as extension of either regular or</span></span><br><span class="line"><span class="comment">* linked node.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="4-Best-Practices"><a href="#4-Best-Practices" class="headerlink" title="4. Best Practices"></a>4. Best Practices</h2><ul>
<li><p>在使用<code>HashMap</code>时应该尽量保证<code>key</code>的<code>hashCode</code>返回值分布均匀性；在java8上使用时<code>key</code>应该尽量实现<code>comparable</code>接口。</p>
</li>
<li><p><code>LinkedHashMap</code>和<code>HashMap</code>性能的比较:在基本的<code>put</code> <code>get</code> <code>remove</code>操作，两者的性能几乎相近，由于<code>LinkedHashMap</code>维护着一个双向链表，因此性能可能稍微差一点点。但是在迭代遍历的时候，因为<code>LinkedHashMap</code>遍历的所有的插入的元素，而<code>HashMap</code>是遍历的整个<code>HashMap</code>（包括一些空桶），因此<code>LinkedHashMap</code>的性能稍微优于<code>HashMap</code>。</p>
</li>
<li><p><code>LinkedHashMap</code>可以保持任意的<code>Map</code>的顺序信息，就像这样使用：</p>
</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(Map m)</span> &#123;</span><br><span class="line">        <span class="type">Map</span> <span class="variable">copy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>(m);</span><br><span class="line">        ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>





      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://spground.github.io/2017/03/12/Common%20Algorithm%20Strategy%20Backtracking/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Spground">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spground Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Spground Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/03/12/Common%20Algorithm%20Strategy%20Backtracking/" class="post-title-link" itemprop="url">常用算法策略之回溯法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-03-12 00:00:00" itemprop="dateCreated datePublished" datetime="2017-03-12T00:00:00+08:00">2017-03-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-24 22:30:21" itemprop="dateModified" datetime="2025-09-24T22:30:21+08:00">2025-09-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-回溯法简介"><a href="#1-回溯法简介" class="headerlink" title="1.回溯法简介"></a>1.回溯法简介</h2><p><a href="https://en.wikipedia.org/wiki/Backtracking">回溯法</a>，又称试探法，是常用的，基本的优选搜索方法。常用于解决这一类问题：给定一定约束条件F（该约束条件常用于后面的剪枝）下求问题的一个解或者所有解。</p>
<p><strong>回溯法其实是暴力枚举的一种改进，因为其会聪明的filter掉不合适的分支，大大减少了无谓的枚举。若某问题的枚举都是可行解得话，也就是没有剪枝发生，那么回溯法和暴力枚举并无二异。</strong></p>
<p>该回溯法先从解空间中选取任意一个可能满足约束条件<code>F</code>的点<code>x1</code>,然后从满足<code>F</code>的解空间中继续选择一个点<code>x2</code>，直到所找到的点构成一个解<code>S</code>或者找不到满足约束条件<code>F</code>的点时，开始回溯。回溯到上一层节点f，再另选满足<code>F</code>的解空间中的一点，继续试探。</p>
<p>整个过程类似于一个递归树，因此回溯法常常采用<code>DFS</code>的方法来实现。不考虑约束条件<code>F</code>，整个递归树的任一根节点<code>root</code>到叶子节点<code>leaf</code>的路径<code>path</code>都是无约束条件<code>F</code>的原问题的一个解。</p>
<p>现在考虑约束条件<code>F</code>，实际就是在每次向下深入的时候，利用约束条件<code>F</code>来判断当前遍历的节点是否有必要继续搜索下去,若无必要则马上回溯；有必要则继续深入，这一个过程类似于约束条件<code>F</code>剪去了多余的递归分支。</p>
<p>回溯法解决的问题的<strong>一般特征</strong>：能够利用约束条件<code>F</code>去<strong>快速</strong>判断构成一个完整解的一些局部候选信息<code>partial candidates</code>是否可能最终构成一个正确的、完整的解。</p>
<h2 id="2-回溯法的基本步骤"><a href="#2-回溯法的基本步骤" class="headerlink" title="2.回溯法的基本步骤"></a>2.回溯法的基本步骤</h2><ol>
<li>明确问题的解空间<code>S</code>和约束条件<code>F</code>.</li>
<li>利用深度优先搜索，试探可能构成一个完整解的候选节点，利用约束条件<code>F</code>进行剪枝<br>  2.1. 找到递归的<code>base case</code><br>  2.2. 利用约束条件<code>F</code>判断是否剪枝，一旦剪枝，则开始回溯（返回）</li>
<li>当递归到叶节点的时候，即得到原问题在约束条件<code>F</code>下的一个解，若要得到所有的可行解，则还需要考察根节点的其他分支。</li>
</ol>
<p>回溯法注意事项：</p>
<ol>
<li>递归状态的存储和更新</li>
<li>回溯点的处理（是否应该清除该回溯点之前对递归状态产生的<code>side effect</code>）</li>
<li>解的搜集</li>
</ol>
<h2 id="3-回溯法之经典问题"><a href="#3-回溯法之经典问题" class="headerlink" title="3.回溯法之经典问题"></a>3.回溯法之经典问题</h2><p>回溯法之经典问题：N皇后问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NQueensDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="type">NQueensDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NQueensDemo</span>();</span><br><span class="line">		demo.solution(<span class="number">8</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solution</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">		List&lt;<span class="type">int</span>[]&gt; collector = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">			dfs(<span class="number">0</span>, j, <span class="keyword">new</span> <span class="title class_">int</span>[n], <span class="keyword">new</span> <span class="title class_">int</span>[n], <span class="keyword">new</span> <span class="title class_">int</span>[n], <span class="keyword">new</span> <span class="title class_">int</span>[n * <span class="number">2</span> - <span class="number">1</span>], <span class="keyword">new</span> <span class="title class_">int</span>[n * <span class="number">2</span> - <span class="number">1</span>], collector, n);</span><br><span class="line">		System.out.println(<span class="string">&quot;numbers of solution &quot;</span> + collector.size());</span><br><span class="line">		print(collector, n);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span>[] solution, <span class="type">int</span>[] occupiedRow, <span class="type">int</span>[] occupiedCol, <span class="type">int</span>[] occupiedTopBottom,</span></span><br><span class="line"><span class="params">			<span class="type">int</span>[] occupiedBottomTop, List&lt;<span class="type">int</span>[]&gt; collector, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">		solution[i] = j;</span><br><span class="line">		<span class="keyword">if</span> (i &gt;= size - <span class="number">1</span>) &#123;</span><br><span class="line">			collector.add(solution.clone());</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 8个方向</span></span><br><span class="line">		occupiedRow[i] = <span class="number">1</span>;</span><br><span class="line">		occupiedCol[j] = <span class="number">1</span>;</span><br><span class="line">		occupiedTopBottom[size - <span class="number">1</span> + (i - j)] = <span class="number">1</span>;<span class="comment">// 左上到右下的斜线 (i+d, j+d) 关系为i-j,</span></span><br><span class="line">													<span class="comment">// 范围为 -size + 1 ~ size - 1,</span></span><br><span class="line">													<span class="comment">// 所以左右各加size - 1归到区间</span></span><br><span class="line">													<span class="comment">// 0~2size - 2, 关系为 size - 1</span></span><br><span class="line">													<span class="comment">// + (i - j), 分配的数组大小为 2size</span></span><br><span class="line">													<span class="comment">// - 1</span></span><br><span class="line">		occupiedBottomTop[i + j] = <span class="number">1</span>;<span class="comment">// 左下到右上的斜线(i-d, j+d)和(i+d, j-d) 关系为 i+j</span></span><br><span class="line">										<span class="comment">// 分配的数组大小为 2size - 1</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 寻找下一个皇后放置的位置</span></span><br><span class="line">		i = i + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>; n &lt; size; n++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (occupiedRow[i] == <span class="number">0</span> &amp;&amp; occupiedCol[n] == <span class="number">0</span> &amp;&amp; occupiedTopBottom[size - <span class="number">1</span> + (i - n)] == <span class="number">0</span></span><br><span class="line">					&amp;&amp; occupiedBottomTop[i + n] == <span class="number">0</span>)</span><br><span class="line">				dfs(i, n, solution, occupiedRow, occupiedCol, occupiedTopBottom, occupiedBottomTop, collector, size);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 回溯后, clear flag，恢复原状</span></span><br><span class="line">		i = i - <span class="number">1</span>;</span><br><span class="line">		occupiedRow[i] = <span class="number">0</span>;</span><br><span class="line">		occupiedCol[j] = <span class="number">0</span>;</span><br><span class="line">		occupiedTopBottom[size - <span class="number">1</span> + (i - j)] = <span class="number">0</span>;</span><br><span class="line">		occupiedBottomTop[i + j] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(List&lt;<span class="type">int</span>[]&gt; collector, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span>[] s : collector) &#123;</span><br><span class="line">			System.out.println();</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">				System.out.println();</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">					<span class="keyword">if</span> (j == s[i])</span><br><span class="line">						System.out.print(<span class="number">1</span> + <span class="string">&quot;  &quot;</span>);</span><br><span class="line">					<span class="keyword">else</span></span><br><span class="line">						System.out.print(<span class="number">0</span> + <span class="string">&quot;  &quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-回溯法之经典问题：Sudoku（数独）"><a href="#4-回溯法之经典问题：Sudoku（数独）" class="headerlink" title="4.回溯法之经典问题：Sudoku（数独）"></a>4.回溯法之经典问题：Sudoku（数独）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">char</span> <span class="variable">base</span> <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solveSudoku</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">filledNum</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// 统计已填的数目，作为DFS搜索结束的条件</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">0</span>, n = <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span>[][] rowCount = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">9</span>][<span class="number">9</span>], colCount = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">9</span>][<span class="number">9</span>], subBoxCount = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (m = <span class="number">0</span>; m &lt; <span class="number">9</span>; m++)</span><br><span class="line">			<span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; <span class="number">9</span>; n++)</span><br><span class="line">				<span class="keyword">if</span> (board[m][n] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">					rowCount[m][board[m][n] - base] += <span class="number">1</span>;</span><br><span class="line">					colCount[n][board[m][n] - base] += <span class="number">1</span>;</span><br><span class="line">					subBoxCount[m / <span class="number">3</span> * <span class="number">3</span> + n / <span class="number">3</span>][board[m][n] - base] += <span class="number">1</span>;</span><br><span class="line">					filledNum++;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">		<span class="type">boolean</span> <span class="variable">found</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span> (m = <span class="number">0</span>; m &lt; <span class="number">9</span>; m++) &#123;<span class="comment">// 找到第一个待填的方格</span></span><br><span class="line">			<span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; <span class="number">9</span>; n++)</span><br><span class="line">				<span class="keyword">if</span> (board[m][n] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">					found = <span class="literal">true</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">if</span> (found)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>; num &lt; <span class="number">9</span>; num++)</span><br><span class="line">			<span class="keyword">if</span> (rowCount[m][num] == <span class="number">0</span> &amp;&amp; colCount[n][num] == <span class="number">0</span> &amp;&amp; subBoxCount[m / <span class="number">3</span> * <span class="number">3</span> + n / <span class="number">3</span>][num] == <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">if</span> (dfs(m, n, (<span class="type">char</span>) (num + base), board, rowCount, colCount, subBoxCount, filledNum))</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">char</span> c, <span class="type">char</span>[][] board, <span class="type">int</span>[][] rowCount, <span class="type">int</span>[][] colCount, <span class="type">int</span>[][] subBoxCount,</span></span><br><span class="line"><span class="params">			<span class="type">int</span> filledNum)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> c - base;<span class="comment">// 0~8代表1~9</span></span><br><span class="line">		board[i][j] = c;</span><br><span class="line">		rowCount[i][number] += <span class="number">1</span>;</span><br><span class="line">		colCount[j][number] += <span class="number">1</span>;</span><br><span class="line">		subBoxCount[i / <span class="number">3</span> * <span class="number">3</span> + j / <span class="number">3</span>][number] += <span class="number">1</span>;</span><br><span class="line">		filledNum += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// bas case</span></span><br><span class="line">		<span class="keyword">if</span> (filledNum &gt;= <span class="number">81</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> i, n = j;</span><br><span class="line">		<span class="type">boolean</span> <span class="variable">found</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="comment">// 找到下一个待填方格</span></span><br><span class="line">		<span class="keyword">for</span> (; m &lt; <span class="number">9</span>; m++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (; n &lt; <span class="number">9</span>; n++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (board[m][n] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">					found = <span class="literal">true</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (found)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				n = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>; num &lt; <span class="number">9</span>; num++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (rowCount[m][num] == <span class="number">0</span> &amp;&amp; colCount[n][num] == <span class="number">0</span> &amp;&amp; subBoxCount[m / <span class="number">3</span> * <span class="number">3</span> + n / <span class="number">3</span>][num] == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (dfs(m, n, (<span class="type">char</span>) (num + base), board, rowCount, colCount, subBoxCount, filledNum))</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// failed 该格子无论填啥都无解,所以clear所做的更改</span></span><br><span class="line">		board[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">		rowCount[i][number] -= <span class="number">1</span>;</span><br><span class="line">		colCount[j][number] -= <span class="number">1</span>;</span><br><span class="line">		subBoxCount[i / <span class="number">3</span> * <span class="number">3</span> + j / <span class="number">3</span>][number] -= <span class="number">1</span>;</span><br><span class="line">		filledNum -= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Spground</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
