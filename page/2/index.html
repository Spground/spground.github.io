<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"spground.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Spground Blog">
<meta property="og:url" content="https://spground.github.io/page/2/index.html">
<meta property="og:site_name" content="Spground Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Spground">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://spground.github.io/page/2/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Spground Blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Spground Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">77</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">11</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">41</span></a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Spground</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">41</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">77</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://spground.github.io/2018/10/15/docker-guide-02-Container/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Spground">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spground Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Spground Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/10/15/docker-guide-02-Container/" class="post-title-link" itemprop="url">2. Container</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-10-15 16:00:00" itemprop="dateCreated datePublished" datetime="2018-10-15T16:00:00+08:00">2018-10-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-24 22:30:21" itemprop="dateModified" datetime="2025-09-24T22:30:21+08:00">2025-09-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/docker/" itemprop="url" rel="index"><span itemprop="name">docker</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="2-Container"><a href="#2-Container" class="headerlink" title="2. Container"></a>2. Container</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li>stack</li>
<li>service</li>
<li>container<br>  使用Docker的方式构建一个app。我们从app的层次结构的最下层开始，最下层是容器。接下来上层是service，这一层定义了生产环境容器如何运作，最顶层是stack，定义了service是如何交互的。</li>
</ul>
<h2 id="新的开发环境"><a href="#新的开发环境" class="headerlink" title="新的开发环境"></a>新的开发环境</h2><p>在过去你要写一个python app的时候，你的第一件事情就是在你的机器上安装python环境。但是同样的，你的生产环境要完美的匹配你的开发环境。</p>
<p>使用Docker，你可以构建一个可移植的python runtime作为一个镜像，然后就没有安装的必要了。接下来，你可以将python镜像作为一个基础镜像脱离于你的app代码，确保app和依赖、运行时是独立的。</p>
<p>这些可移植的镜像可以通过Dockerfile来定义。</p>
<h2 id="使用Dockerfile来定义一个容器"><a href="#使用Dockerfile来定义一个容器" class="headerlink" title="使用Dockerfile来定义一个容器"></a>使用Dockerfile来定义一个容器</h2><p>dockerfile定义你的容器里面的环境包含什么。在容器环境里，访问诸如网络和磁盘等资源都是被虚拟化了的，这些资源是和系统其他资源是隔离的，因此你需要对外做端口映射，和指定哪些文件需要被copy进容器环境中。完成上述工作后，你可以验证基于Dockerfile构建的app运行效果和预期一致。</p>
<h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>创建一个空目录，创建一个文件Dockerfile如下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Use an official Python runtime as a parent image</span></span><br><span class="line">FROM python:2.7-slim</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the working directory to /app</span></span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line"><span class="comment"># Copy the current directory contents into the container at /app</span></span><br><span class="line">COPY . /app</span><br><span class="line"></span><br><span class="line"><span class="comment"># Install any needed packages specified in requirements.txt</span></span><br><span class="line">RUN pip install --trusted-host pypi.python.org -r requirements.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Make port 80 available to the world outside this container</span></span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line"><span class="comment"># Define environment variable</span></span><br><span class="line">ENV NAME World</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run app.py when the container launches</span></span><br><span class="line">CMD [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;app.py&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>Dockerfile需要两个额外的文件 <a href="http://app.py/">app.py</a> requirments.txt。</p>
<h2 id="app"><a href="#app" class="headerlink" title="app"></a>app</h2><p><a href="http://新建app.py/">新建app.py</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> Redis, RedisError</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># Connect to Redis</span></span><br><span class="line">redis = Redis(host=<span class="string">&quot;redis&quot;</span>, db=<span class="number">0</span>, socket_connect_timeout=<span class="number">2</span>, socket_timeout=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        visits = redis.incr(<span class="string">&quot;counter&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> RedisError:</span><br><span class="line">        visits = <span class="string">&quot;&lt;i&gt;cannot connect to Redis, counter disabled&lt;/i&gt;&quot;</span></span><br><span class="line"></span><br><span class="line">    html = <span class="string">&quot;&lt;h3&gt;Hello &#123;name&#125;!&lt;/h3&gt;&quot;</span> \</span><br><span class="line">           <span class="string">&quot;&lt;b&gt;Hostname:&lt;/b&gt; &#123;hostname&#125;&lt;br/&gt;&quot;</span> \</span><br><span class="line">           <span class="string">&quot;&lt;b&gt;Visits:&lt;/b&gt; &#123;visits&#125;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> html.<span class="built_in">format</span>(name=os.getenv(<span class="string">&quot;NAME&quot;</span>, <span class="string">&quot;world&quot;</span>), hostname=socket.gethostname(), visits=visits)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>, port=<span class="number">80</span>)</span><br></pre></td></tr></table></figure>

<p>新建requirements.txt</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Flask</span><br><span class="line">Redis</span><br></pre></td></tr></table></figure>
<h2 id="构建app"><a href="#构建app" class="headerlink" title="构建app"></a>构建app</h2><p>运行docker命令构建镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t friendlyhello .</span><br></pre></td></tr></table></figure>



<p><img src="https://cdn.nlark.com/yuque/0/2018/png/168795/1538815425805-488cfe66-f28a-4163-9425-561f9000800f.png" alt="image.png | left | 747x427"></p>
<p>查看构建成功的镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image <span class="built_in">ls</span></span><br></pre></td></tr></table></figure>

<h2 id="运行app"><a href="#运行app" class="headerlink" title="运行app"></a>运行app</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 4000:80 friendlyhello</span><br></pre></td></tr></table></figure>



<p><img src="https://cdn.nlark.com/yuque/0/2018/png/168795/1538815583441-e5baca2b-fb8d-42b4-940c-cbc036c84ba7.png" alt="image.png | left | 747x143"></p>
<p>启动成功后访问localhost:4000</p>
<p><img src="https://cdn.nlark.com/yuque/0/2018/png/168795/1538815686554-9bc3fdcc-8420-4253-99a1-14bc718b43a1.png" alt="image.png | left | 747x185"></p>
<h2 id="共享镜像"><a href="#共享镜像" class="headerlink" title="共享镜像"></a>共享镜像</h2><p>构建好的镜像可以将其push到镜像仓库中，便于和其他人共享。</p>
<p>registry是一系列仓库的集合，一个仓库又是一系列镜像的集合。</p>
<p>Docker官方提供一个公开的registry，免费的、预配置的。</p>
<h2 id="使用Docker-ID登录"><a href="#使用Docker-ID登录" class="headerlink" title="使用Docker ID登录"></a>使用Docker ID登录</h2><p>运行命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker login</span><br></pre></td></tr></table></figure>

<h2 id="镜像打标"><a href="#镜像打标" class="headerlink" title="镜像打标"></a>镜像打标</h2><p>将本地镜像和远程registry的仓库关联的写法是：username&#x2F;repository:tag。<br>tag是可选的但是被推荐的写法，registry使用这个机制来给docker镜像打上一个版本。给repository和tag有意义的命名是推荐的。例如：get-started:part2，这个写法将镜像存放在get-started仓库，然后打上了part2标。</p>
<p>使用docker image tag命令，打标本地镜像。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag image username/repository:tag</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag  friendlyhello dockerjie/get-started:part2</span><br></pre></td></tr></table></figure>



<p><img src="https://cdn.nlark.com/yuque/0/2018/png/168795/1538967521336-6a56e37f-a9ba-48ed-84f2-210b518f00e2.png" alt="image.png | left | 681x124"></p>
<h2 id="publish镜像"><a href="#publish镜像" class="headerlink" title="publish镜像"></a>publish镜像</h2><p>上传打标的镜像到远程的仓库。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push username/get-started:tag</span><br></pre></td></tr></table></figure>

<p>一旦完成，这个上传的结果是公开可用的。如果我们登录到Docker Hub，我们可以看见新的镜像在那，可以使用pull命令。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2018/png/168795/1538968846791-8bb2645d-7d05-4742-ac72-1f1a127c6333.png" alt="image.png | left | 681x163"></p>
<p>一旦上传完成就可以使用远程仓库的镜像来创建容器了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 4000:80 username/get-started:part2</span><br></pre></td></tr></table></figure>

<p>如果本地不存在该镜像，docker会使用远程的镜像。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://spground.github.io/2018/10/15/docker-guide-01-Orientation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Spground">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spground Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Spground Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/10/15/docker-guide-01-Orientation/" class="post-title-link" itemprop="url">1. Orientation</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-10-15 15:00:00" itemprop="dateCreated datePublished" datetime="2018-10-15T15:00:00+08:00">2018-10-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-24 22:30:21" itemprop="dateModified" datetime="2025-09-24T22:30:21+08:00">2025-09-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/docker/" itemprop="url" rel="index"><span itemprop="name">docker</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-Orientation"><a href="#1-Orientation" class="headerlink" title="1. Orientation"></a>1. Orientation</h1><p>Docker是开发人员和运维人员使用容器来开发、部署和运行应用的平台。使用linux容器来部署应用被称为容器化。容器概念不是新的，但是使用容器来便利部署应用却是新的。</p>
<p>容器化越来越受欢迎，因为容器具有以下特点：</p>
<ul>
<li>灵活：大型应用也可以被容器化</li>
<li>轻量：容器共享同一个os内核</li>
<li>通用：可以on-the-fly的进行更新升级</li>
<li>可移植：可以本地构建、云端部署</li>
<li>可伸缩：自动分发容器副本</li>
<li>可堆叠：可以on-the-fly垂直堆叠更多的服务</li>
</ul>
<h2 id="镜像和容器"><a href="#镜像和容器" class="headerlink" title="镜像和容器"></a>镜像和容器</h2><p>镜像和容器的概念类似与程序和进程。<br>镜像是一个可执行的package，里面包含运行一个应用所需要的任何东西，例如代码、运行时、库、环境变量和配置文件等。</p>
<p>容器是镜像的运行实例。使用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>

<p>查看运行的容器。</p>
<h2 id="容器和虚拟机"><a href="#容器和虚拟机" class="headerlink" title="容器和虚拟机"></a>容器和虚拟机</h2><p>容器运行在linux上，和其他容器共享宿主机的内核。它运行在单独的进程，因此是轻量级的。</p>
<p>而虚拟机则运行在一个单独的操作系统上，这个操作系统运行在硬件虚拟化管理器hyperVisor上面。通常，虚拟机环境提供的资源超过了大部分程序的需求。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2018/png/168795/1538809398129-e7b212c4-df53-4d10-a422-fb3b1b4185ee.png" alt="image.png | left | 332x298"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2018/png/168795/1538809411444-6afbaa06-19b7-4b79-b4c7-3a2031db3fe7.png" alt="image.png | left | 330x297"></p>
<h2 id="准备Docker环境"><a href="#准备Docker环境" class="headerlink" title="准备Docker环境"></a>准备Docker环境</h2><p>参见之前的docker安装博客。</p>
<ul>
<li>查看docker版本</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker --version</span><br></pre></td></tr></table></figure>

<ul>
<li>查看docker详情</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure>

<ul>
<li>查看docker镜像列表</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image <span class="built_in">ls</span></span><br></pre></td></tr></table></figure>

<ul>
<li>查看docker容器列表</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container <span class="built_in">ls</span> --all</span><br></pre></td></tr></table></figure>

<ul>
<li>运行镜像，启动一个容器</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run image-name</span><br></pre></td></tr></table></figure>

<p>容器化使得CI&#x2F;CD无缝连接，例如：</p>
<ul>
<li>应用没有系统环境依赖</li>
<li>更新能被推送到一个分布式应用的任何部分</li>
<li>资源密度能被优化<br>  使用docker，伸缩应用也是一件很轻松的事情，而不需要接触厚重的VM机器。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://spground.github.io/2018/02/25/Summary%20for%20a%20try%20to%20lightweight%20RPC%20framework/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Spground">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spground Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Spground Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/02/25/Summary%20for%20a%20try%20to%20lightweight%20RPC%20framework/" class="post-title-link" itemprop="url">初试轻量级RPC框架总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-02-25 00:00:00" itemprop="dateCreated datePublished" datetime="2018-02-25T00:00:00+08:00">2018-02-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-24 22:30:21" itemprop="dateModified" datetime="2025-09-24T22:30:21+08:00">2025-09-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-RPC"><a href="#1-RPC" class="headerlink" title="1. RPC"></a>1. RPC</h1><p><code>RPC</code>即<code>Remote Procedure Call</code>（远程过程调用），直白的说就是：向调用本地服务一样调用远程计算机的服务。</p>
<p>由于现代应用日益复杂，单台机器显然不能满足需求。于是将业务按照一定的方式拆分开来，分散到多台机器上（或者一台机器上的多个进程），让每台机器各司其职，物尽其用。<code>SOA</code>和当前盛行的微服务便是从此变革历史中出现的产物。</p>
<p>为了达到各个分散在不同机器上的服务做到<strong>相互独立又相互联系</strong>，当计算机<code>A</code>上的服务<code>ServiceA</code>需要调用计算机<code>B</code>上的服务<code>ServiceB</code>时，需要一种互相遵守的<strong>协议</strong>来完成一次调用。</p>
<p>而这些协议便是<code>RPC</code>框架包含的内容。</p>
<p>以下从三个方面分析了高性能<code>RPC</code>的三个关键要素：</p>
<ul>
<li>传输协议</li>
</ul>
<blockquote>
<p><code>RPC</code> 可基于 <code>HTTP</code> 或 <code>TCP</code> 协议，<code>Web Service</code> 就是基于 <code>HTTP</code> 协议的 RPC，它具有良好的跨平台性，但其性能却不如基于 TCP 协议的 RPC。有两方面会直接影响 <code>RPC</code> 的性能，一是<strong>传输方式</strong>，二是<strong>序列化</strong>。</p>
</blockquote>
<ul>
<li>序列化方式</li>
</ul>
<blockquote>
<p>众所周知，TCP 是传输层协议，HTTP 是应用层协议，而传输层较应用层更加底层，在数据传输方面，越底层越快，因此，在一般情况下，TCP 一定比 HTTP 快。就序列化而言，Java 提供了默认的序列化方式，但在高并发的情况下，这种方式将会带来一些性能上的瓶颈，于是市面上出现了一系列优秀的序列化框架，比如：Protobuf、Kryo、Hessian、Jackson 等，它们可以取代 Java 默认的序列化，从而提供更高效的性能。</p>
</blockquote>
<ul>
<li>高并发（IO方式）</li>
</ul>
<blockquote>
<p>为了支持高并发，传统的阻塞式 IO 显然不太合适，因此我们需要异步的 IO，即 NIO。Java 提供了 NIO 的解决方案，Java 7 也提供了更优秀的 NIO.2 支持，用 Java 实现 NIO 并不是遥不可及的事情，只是需要我们熟悉 NIO 的技术细节。</p>
</blockquote>
<p>另外，服务部署在分布式环境下的不同节点，因此还需要提供一个服务注册与发现中心（Service Registry），让客户端发现可用的服务。应用、服务、注册表之间的关系如下图：</p>
<p><img src="http://static.oschina.net/uploads/space/2014/1229/002234_ENsM_223750.png"></p>
<p>考虑到上述的几个关键要素，做出如下选型：</p>
<ol>
<li>Spring : 业界权威的依赖注入框架</li>
<li>Netty: 封装了Java的NIO的一个网络框架</li>
<li>Protostuff: 基于Google的Protobuf的序列化框架，面向POJO，无需编写、编译.proto文件</li>
<li>Zookeeper: 分布式系统的必备选择，提供服务发现和服务注册功能</li>
</ol>
<p>参考了某篇博客，搭建一个基于TCP协议，采用Protostuff序列化方式，提供NIO支持且具备服务注册和发现的轻量级RPC框架。</p>
<h1 id="2-搭建轻量级RPC框架"><a href="#2-搭建轻量级RPC框架" class="headerlink" title="2. 搭建轻量级RPC框架"></a>2. 搭建轻量级RPC框架</h1><h2 id="第一步：编写服务接口"><a href="#第一步：编写服务接口" class="headerlink" title="第一步：编写服务接口"></a>第一步：编写服务接口</h2><p>没有规矩，不成方圆。制定客户端和服务端共同遵循的接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IHelloService</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第二步：编写服务接口的实现类"><a href="#第二步：编写服务接口的实现类" class="headerlink" title="第二步：编写服务接口的实现类"></a>第二步：编写服务接口的实现类</h2><p>由于服务端提供服务，因此需要在服务端实现该接口，以便客户端后续通过RPC调用。</p>
<p>由于<strong>不同的服务是按照接口来区分</strong>的，而同一个服务实现类可以实现不同的接口（这些接口可能是服务接口或者其他接口），换句话说一个服务实现类可以提供多种不同的服务。</p>
<p>为了达到标示某个服务实现类对应哪个服务接口，需要自定义一个注解，然后通过<code>Spring</code>扫描包含该注解的<code>Bean</code>，这样就可以发现某个服务接口对应哪个服务实现类。</p>
<ol>
<li><p>自定义注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Component</span><span class="comment">// 表明可被Spring扫描</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RpcService &#123;</span><br><span class="line">	Class&lt;?&gt; value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​</p>
</li>
<li><p>编写服务实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RpcService(IHelloService.class)</span><span class="comment">//稍后通过Spring扫描</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldImpl</span> <span class="keyword">implements</span> <span class="title class_">IHelloService</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Hello &quot;</span> + name + <span class="string">&quot; ==&gt; from remote greeting&quot;</span>;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="第三步：-配置服务端"><a href="#第三步：-配置服务端" class="headerlink" title="第三步： 配置服务端"></a>第三步： 配置服务端</h2><ol>
<li>由于使用了Spring实现依赖注入，此处使用了<code>XML</code>方式声明<code>Bean</code>。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot;</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;dlut.rpc&quot;</span>/&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:rpc.properties&quot;</span>/&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 配置服务发现组件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;serviceRegistry&quot;</span> <span class="attr">class</span>=<span class="string">&quot;dlut.rpc.server.ZookeeperServiceRegistry&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;registryAddress&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;rpc.registry_address&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 配置 RPC Server--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;rpcServer&quot;</span> <span class="attr">class</span>=<span class="string">&quot;dlut.rpc.server.RpcServer&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;serverAddress&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;rpc.server_address&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;serviceRegistry&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;serviceRegistry&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>服务端的Spring配置声明了如下内容：</p>
<ul>
<li>扫描路径</li>
<li>属性文件的路径</li>
<li>两个Bean，一个是ZookeeperServiceRegistry，另一个是RpcServer，且都通过构造器注入。</li>
</ul>
<ol start="2">
<li><p>编写rpc.properties配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpc.registry_address=127.0.0.1:2181</span><br><span class="line">rpc.server_address=127.0.0.1:8000</span><br></pre></td></tr></table></figure>

<p>主要是配置一些端口信息</p>
</li>
</ol>
<h2 id="第四步：-编写服务端代码"><a href="#第四步：-编写服务端代码" class="headerlink" title="第四步： 编写服务端代码"></a>第四步： 编写服务端代码</h2><p>由于RpcServer相当于是一个运行的入口，因此需要在所有Bean实例化后，做一些初始化的操作，这里RpcServer本来也是一个由Spring IoC容器管理的Bean（上面的服务器的Spring.xml配置中已经配置了）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcServer</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span>, InitializingBean &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(RpcServer.class);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> String serverAddress;</span><br><span class="line">	<span class="keyword">private</span> ZookeeperServiceRegistry serviceRegistry;<span class="comment">//由IoC自动注入</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Map&lt;String, Object&gt; handlerMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">RpcServer</span><span class="params">(String serverAddress)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.serverAddress = serverAddress;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">RpcServer</span><span class="params">(String serverAddress, ZookeeperServiceRegistry serviceRegistry)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">		<span class="built_in">this</span>.serverAddress = serverAddress;</span><br><span class="line">		<span class="built_in">this</span>.serviceRegistry = serviceRegistry;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext ctx)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		Map&lt;String, Object&gt; serviceBeanMap = ctx.getBeansWithAnnotation(RpcService.class);<span class="comment">//通过注解去发现提供rpc服务的Bean</span></span><br><span class="line">		<span class="keyword">if</span> (MapUtils.isNotEmpty(serviceBeanMap)) &#123;</span><br><span class="line">			<span class="keyword">for</span> (Object serviceBean : serviceBeanMap.values()) &#123;</span><br><span class="line">				<span class="type">String</span> <span class="variable">interfaceName</span> <span class="operator">=</span> serviceBean.getClass().getAnnotation(RpcService.class).value().getName();</span><br><span class="line">				handlerMap.put(interfaceName, serviceBean);<span class="comment">//建立服务接口--服务实现类的映射</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">		<span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="type">ServerBootstrap</span> <span class="variable">bootStrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">			<span class="comment">// 配置Server端的NIO</span></span><br><span class="line">			bootStrap.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class)</span><br><span class="line">					.childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">						<span class="meta">@Override</span></span><br><span class="line">						<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">							<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">							LOGGER.debug(<span class="string">&quot;initChannel&quot;</span>);</span><br><span class="line">							ch.pipeline()</span><br><span class="line">							.addLast(<span class="keyword">new</span> <span class="title class_">RpcDecoder</span>(RpcRequest.class))<span class="comment">// 处理Rpc请求 RpcRequest</span></span><br><span class="line">							.addLast(<span class="keyword">new</span> <span class="title class_">RpcEncoder</span>(RpcResponse.class))<span class="comment">// 处理Rpc RpcResponse</span></span><br><span class="line">							.addLast(<span class="keyword">new</span> <span class="title class_">RpcHandler</span>(handlerMap));<span class="comment">// 处理Rpc请求</span></span><br><span class="line">						&#125;</span><br><span class="line">					&#125;)</span><br><span class="line">					.option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)</span><br><span class="line">					.option(ChannelOption.SO_KEEPALIVE, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 解析地址</span></span><br><span class="line">			String[] array = serverAddress.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">			<span class="type">String</span> <span class="variable">host</span> <span class="operator">=</span> array[<span class="number">0</span>];</span><br><span class="line">			<span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> Integer.parseInt(array[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">			<span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> bootStrap.bind(host, port).sync();</span><br><span class="line">			LOGGER.debug(<span class="string">&quot;server started on port &#123;&#125;&quot;</span>, port);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 注册服务</span></span><br><span class="line">			<span class="keyword">if</span> (serviceRegistry != <span class="literal">null</span>) &#123;</span><br><span class="line">				serviceRegistry.register(serverAddress);</span><br><span class="line">			&#125;</span><br><span class="line">			future.channel().closeFuture().sync();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			LOGGER.debug(<span class="string">&quot;worker group and boss group shutdown&quot;</span>);</span><br><span class="line">			workerGroup.shutdownGracefully();</span><br><span class="line">			bossGroup.shutdownGracefully();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>同时需要编写一个服务端的handler类（RpcServer当收到请求，并将其转换为RpcRequest后，RpcHandler将做进一步处理）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;RpcRequest&gt; &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(RpcHandler.class);</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; handlerMap;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">RpcHandler</span><span class="params">(Map&lt;String, Object&gt; handlerMap)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.handlerMap = handlerMap;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, RpcRequest msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="type">RpcResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RpcResponse</span>();</span><br><span class="line">		response.setRequestId(msg.getRequestId());</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> handle(msg);</span><br><span class="line">			response.setResult(result);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">			LOGGER.debug(<span class="string">&quot;handle ocurred error ==&gt; &#123;&#125;&quot;</span>, t);</span><br><span class="line">			response.setError(t);</span><br><span class="line">		&#125;</span><br><span class="line">		ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);<span class="comment">//写完然后关闭channel</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> Object <span class="title function_">handle</span><span class="params">(RpcRequest request)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> request.getClassName();<span class="comment">//此处极易出错，需要保证客户端和服务端的className是一致的，否则直接GG</span></span><br><span class="line">		<span class="type">Object</span> <span class="variable">serviceBean</span> <span class="operator">=</span> handlerMap.get(className);</span><br><span class="line">		<span class="keyword">if</span> (serviceBean == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Throwable</span>(String.format(<span class="string">&quot;can not find service bean by given name [%s] in server &quot;</span>, className));</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(handlerMap);</span><br><span class="line">		System.out.println(className);</span><br><span class="line">		Class&lt;?&gt; serviceClass = serviceBean.getClass();</span><br><span class="line">		<span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> request.getMethodName();</span><br><span class="line">		Class&lt;?&gt;[] parameterTypes = request.getParameterTypes();</span><br><span class="line">		Object[] parameters = request.getParameters();</span><br><span class="line">		LOGGER.debug(<span class="string">&quot;handle request &#123;&#125;&quot;</span>, request.getRequestId());</span><br><span class="line">		<span class="comment">//以下为利用CGlib反射调用serviceBean的方法</span></span><br><span class="line">		<span class="type">FastClass</span> <span class="variable">serviceFastClass</span> <span class="operator">=</span> FastClass.create(serviceClass);</span><br><span class="line">		<span class="type">FastMethod</span> <span class="variable">serviceFastMethod</span> <span class="operator">=</span> serviceFastClass.getMethod(methodName, parameterTypes);</span><br><span class="line">		<span class="keyword">return</span> serviceFastMethod.invoke(serviceBean, parameters);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		LOGGER.error(<span class="string">&quot;server caught exception&quot;</span>, cause);</span><br><span class="line">		ctx.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>最后需要编写一个引导类，用于加载Spring.xml文件启动Spring IoC容器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcBootstrap</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@SuppressWarnings(&quot;resource&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;spring.xml&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="第五步：-编写common类"><a href="#第五步：-编写common类" class="headerlink" title="第五步： 编写common类"></a>第五步： 编写common类</h2><p>第四步涉及到几个POJO封装类，由于这几个类无论是客户端还是服务端都是需要，因此应该单独将其打包作为公共的jar包。</p>
<ul>
<li>RpcRequest</li>
<li>RpcResponse</li>
<li>RpcEncoder</li>
<li>RpcDecoder</li>
<li>SerializationUtil</li>
<li>Constants</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcRequest</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String requestId;</span><br><span class="line">	<span class="keyword">private</span> String className;</span><br><span class="line">	<span class="keyword">private</span> String methodName;</span><br><span class="line">	<span class="keyword">private</span> Class&lt;?&gt;[] parameterTypes;</span><br><span class="line">	<span class="keyword">private</span> Object[] parameters;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getRequestId</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> requestId;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRequestId</span><span class="params">(String requestId)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.requestId = requestId;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getClassName</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> className;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setClassName</span><span class="params">(String className)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.className = className;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getMethodName</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> methodName;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMethodName</span><span class="params">(String methodName)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.methodName = methodName;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> Class&lt;?&gt;[] getParameterTypes() &#123;</span><br><span class="line">		<span class="keyword">return</span> parameterTypes;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setParameterTypes</span><span class="params">(Class&lt;?&gt;[] parameterTypes)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.parameterTypes = parameterTypes;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> Object[] getParameters() &#123;</span><br><span class="line">		<span class="keyword">return</span> parameters;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setParameters</span><span class="params">(Object[] parameters)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.parameters = parameters;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcResponse</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String requestId;</span><br><span class="line">	<span class="keyword">private</span> Throwable error;</span><br><span class="line">	<span class="keyword">private</span> Object result;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getRequestId</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> requestId;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRequestId</span><span class="params">(String requestId)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.requestId = requestId;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> Throwable <span class="title function_">getError</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> error;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setError</span><span class="params">(Throwable error)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.error = error;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">getResult</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setResult</span><span class="params">(Object result)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.result = result;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;[id: &quot;</span> + requestId + <span class="string">&quot;, result: &quot;</span> + result + <span class="string">&quot;, error: &quot;</span> + error +  <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcEncoder</span> <span class="keyword">extends</span> <span class="title class_">MessageToByteEncoder</span>&lt;RpcResponse&gt; &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(RpcEncoder.class);</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(ChannelHandlerContext ctx, RpcResponse msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="type">byte</span>[] data = SerializationUtil.serialize(msg);</span><br><span class="line">		LOGGER.debug(<span class="string">&quot;encode =&gt; datalength =&gt; &#123;&#125;&quot;</span>, data.length);</span><br><span class="line">		out.writeInt(data.length);</span><br><span class="line">		out.writeBytes(data);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcDecoder</span> <span class="keyword">extends</span> <span class="title class_">ByteToMessageDecoder</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(RpcDecoder.class);</span><br><span class="line">	<span class="keyword">private</span> Class&lt;?&gt; genericClass;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">RpcDecoder</span><span class="params">(Class&lt;?&gt; genericClass)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">		<span class="built_in">this</span>.genericClass = genericClass;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		LOGGER.debug(<span class="string">&quot;decode =&gt; datalength =&gt; &#123;&#125;&quot;</span>, in.readableBytes());</span><br><span class="line">		<span class="comment">//按照自己的协议，进行解析；</span></span><br><span class="line">		<span class="comment">//dataLength|dataContent</span></span><br><span class="line">		<span class="keyword">if</span> (in.readableBytes() &lt; <span class="number">4</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		in.markReaderIndex();</span><br><span class="line">		<span class="type">int</span> <span class="variable">dataLength</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">		<span class="keyword">if</span> (dataLength &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			ctx.close();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (in.readableBytes() &lt; dataLength) &#123;<span class="comment">//数据还未完全接受完毕，重置in的read Index；等待下一次decode；；</span></span><br><span class="line">			in.resetReaderIndex();</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[dataLength];</span><br><span class="line">		in.readBytes(data);</span><br><span class="line">		<span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> SerializationUtil.deserialize(data, <span class="built_in">this</span>.genericClass);<span class="comment">//反序列化</span></span><br><span class="line">		LOGGER.debug(<span class="string">&quot;decode =&gt; deserialize ok&quot;</span>);</span><br><span class="line">		out.add(obj);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerializationUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Class&lt;?&gt;, Schema&lt;?&gt;&gt; cachedSchema = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ObjenesisStd</span> <span class="variable">objenesis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjenesisStd</span>(<span class="literal">true</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">SerializationUtil</span><span class="params">()</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; Schema&lt;T&gt; <span class="title function_">getSchema</span><span class="params">(Class&lt;T&gt; cls)</span> &#123;</span><br><span class="line">		Schema&lt;T&gt; schema = (Schema&lt;T&gt;) cachedSchema.get(cls);</span><br><span class="line">		<span class="keyword">if</span> (schema == <span class="literal">null</span>) &#123;</span><br><span class="line">			schema = RuntimeSchema.createFrom(cls);</span><br><span class="line">			<span class="keyword">if</span> (schema != <span class="literal">null</span>) &#123;</span><br><span class="line">				cachedSchema.put(cls, schema);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> schema;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(<span class="type">byte</span>[] data, Class&lt;T&gt; cls)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="type">T</span> <span class="variable">msg</span> <span class="operator">=</span> objenesis.newInstance(cls);</span><br><span class="line">			Schema&lt;T&gt; schema = getSchema(cls);</span><br><span class="line">			ProtostuffIOUtil.mergeFrom(data,msg, schema);</span><br><span class="line">			<span class="keyword">return</span> msg;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(e.getMessage(), e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">byte</span>[] serialize(T msg) &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		Class&lt;T&gt; cls = (Class&lt;T&gt;) msg.getClass();</span><br><span class="line">		<span class="type">LinkedBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> LinkedBuffer.allocate(LinkedBuffer.DEFAULT_BUFFER_SIZE);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Schema&lt;T&gt; schema = getSchema(cls);</span><br><span class="line">			<span class="keyword">return</span> ProtostuffIOUtil.toByteArray(msg, schema, buffer);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(e.getMessage(), e);</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			buffer.clear();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Constant</span> &#123;</span><br><span class="line">	 <span class="type">int</span> <span class="variable">ZK_SESSION_TIMEOUT</span> <span class="operator">=</span> <span class="number">5000</span>;</span><br><span class="line">	 <span class="type">String</span> <span class="variable">ZK_REGISTRY_PATH</span> <span class="operator">=</span> <span class="string">&quot;/registry&quot;</span>;</span><br><span class="line">	 <span class="type">String</span> <span class="variable">ZK_DATA_PATH</span> <span class="operator">=</span> ZK_REGISTRY_PATH + <span class="string">&quot;/data&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此服务端代码编写完毕，接下来编写客户端代码。</p>
<h2 id="第六步：配置客户端"><a href="#第六步：配置客户端" class="headerlink" title="第六步：配置客户端"></a>第六步：配置客户端</h2><p>和配置服务端一样，也是对客户端的Spring.xml进行配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot;</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;dlut.rpc-client&quot;</span>/&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:rpc-client.properties&quot;</span>/&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 配置服务发现组件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;serviceDiscover&quot;</span> <span class="attr">class</span>=<span class="string">&quot;dlut.rpc_client.ServiceDiscover&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;registryAddress&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;rpc.registry_address&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 配置 RPC 代理 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;rpcProxy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;dlut.rpc_client.RpcProxy&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;serviceDiscover&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;serviceDiscover&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>编写配置文件<code>rpc-client.properties</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpc.registry_address=127.0.0.1:2181</span><br></pre></td></tr></table></figure>

<h2 id="第七步：-编写客户端"><a href="#第七步：-编写客户端" class="headerlink" title="第七步： 编写客户端"></a>第七步： 编写客户端</h2><ul>
<li><p>编写RpcClient类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcClient</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;RpcResponse&gt; &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(RpcClient.class);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="type">String</span> <span class="variable">host</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> RpcResponse response;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">RpcClient</span><span class="params">(String host, <span class="type">int</span> port)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">		<span class="built_in">this</span>.host = host;</span><br><span class="line">		<span class="built_in">this</span>.port = port;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, RpcResponse msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="built_in">this</span>.response = msg;</span><br><span class="line">		LOGGER.debug(<span class="string">&quot;receive msg from &quot;</span>);</span><br><span class="line">		LOGGER.debug(<span class="string">&quot;content =&gt; &#123;&#125;&quot;</span>, <span class="built_in">this</span>.response);</span><br><span class="line">		<span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">			lock.notifyAll();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> RpcResponse <span class="title function_">send</span><span class="params">(RpcRequest request)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="type">EventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">			bootstrap.group(group)</span><br><span class="line">			.channel(NioSocketChannel.class)</span><br><span class="line">			.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">					<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">					ch.pipeline()</span><br><span class="line">					.addLast(<span class="keyword">new</span> <span class="title class_">RpcEncoder</span>(RpcRequest.class)) <span class="comment">//编码请求</span></span><br><span class="line">					.addLast(<span class="keyword">new</span> <span class="title class_">RpcDecoder</span>(RpcResponse.class))<span class="comment">//解码回复</span></span><br><span class="line">					.addLast(RpcClient.<span class="built_in">this</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">			&#125;)</span><br><span class="line">			.option(ChannelOption.SO_KEEPALIVE, <span class="literal">true</span>);</span><br><span class="line">			LOGGER.debug(<span class="string">&quot;host =&gt; &#123;&#125;, port =&gt; &#123;&#125;&quot;</span>, host, port);</span><br><span class="line">			<span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> bootstrap.connect(host, port).sync();</span><br><span class="line">			future.channel().writeAndFlush(request).sync();</span><br><span class="line">			</span><br><span class="line">			LOGGER.debug(<span class="string">&quot;connected&quot;</span>);</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">synchronized</span> (lock ) &#123;</span><br><span class="line">				lock.wait();<span class="comment">//阻塞直到消息被RpcResponse被读取到</span></span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (response != <span class="literal">null</span>) &#123;</span><br><span class="line">				future.channel().closeFuture().sync();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> response;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			group.shutdownGracefully();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		LOGGER.error(<span class="string">&quot;client caught exception&quot;</span>, cause);</span><br><span class="line">        ctx.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​</p>
</li>
<li><p>编写RpcProxy类，用于生成对RPC服务接口的代理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcProxy</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String serverAddress;</span><br><span class="line">	<span class="keyword">private</span> ServiceDiscover serviceDiscover;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">RpcProxy</span><span class="params">(ServiceDiscover serviceDiscover)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.serviceDiscover = serviceDiscover;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">RpcProxy</span><span class="params">(String serverAddress)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.serverAddress = serverAddress;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> &lt;T&gt; T <span class="title function_">create</span><span class="params">(Class&lt;?&gt; interfaceClass)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> (T) Proxy.newProxyInstance(</span><br><span class="line">				interfaceClass.getClassLoader(),</span><br><span class="line">				<span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[]&#123;interfaceClass&#125;,</span><br><span class="line">				<span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">					</span><br><span class="line">					<span class="meta">@Override</span></span><br><span class="line">					<span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">						<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">						<span class="comment">//封装请求</span></span><br><span class="line">						<span class="type">RpcRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RpcRequest</span>();</span><br><span class="line">						request.setRequestId(UUID.randomUUID().toString());</span><br><span class="line">						request.setClassName(method.getDeclaringClass().getName());</span><br><span class="line">						request.setMethodName(method.getName());</span><br><span class="line">						request.setParameterTypes(method.getParameterTypes());</span><br><span class="line">						request.setParameters(args);</span><br><span class="line">						</span><br><span class="line">						<span class="keyword">if</span> (serviceDiscover != <span class="literal">null</span>) &#123;</span><br><span class="line">							serverAddress = serviceDiscover.discover();</span><br><span class="line">						&#125; </span><br><span class="line">						</span><br><span class="line">						String[] array = serverAddress.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">						<span class="type">String</span> <span class="variable">host</span> <span class="operator">=</span> array[<span class="number">0</span>];</span><br><span class="line">						<span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> Integer.parseInt(array[<span class="number">1</span>]);</span><br><span class="line">						</span><br><span class="line">						<span class="type">RpcClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RpcClient</span>(host, port);</span><br><span class="line">						<span class="type">RpcResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.send(request);<span class="comment">//阻塞直到方法返回</span></span><br><span class="line">						<span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> response.getResult();</span><br><span class="line">						</span><br><span class="line">						System.out.println(Arrays.toString(obj.getClass().getTypeParameters()));</span><br><span class="line">						</span><br><span class="line">						<span class="keyword">if</span> (response == <span class="literal">null</span>)</span><br><span class="line">							<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;response is null&quot;</span>);</span><br><span class="line">						<span class="keyword">if</span> (response.getError() != <span class="literal">null</span>) &#123;</span><br><span class="line">							<span class="keyword">throw</span> response.getError();</span><br><span class="line">						&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">							<span class="keyword">return</span> response.getResult();</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​</p>
</li>
<li><p>编写服务发现ServiceDiscover类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceDiscover</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(ServiceDiscover.class);</span><br><span class="line">	<span class="keyword">private</span> <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> List&lt;String&gt; dataList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">	<span class="keyword">private</span> String registryAddress;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">ServiceDiscover</span><span class="params">(String registryAddress)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.registryAddress = registryAddress;</span><br><span class="line">		<span class="type">ZooKeeper</span> <span class="variable">zk</span> <span class="operator">=</span> connectServer();</span><br><span class="line">		<span class="keyword">if</span> (zk != <span class="literal">null</span>) &#123;</span><br><span class="line">			watchNode(zk);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">discover</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> dataList.size();</span><br><span class="line">		<span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (size == <span class="number">1</span>) &#123;</span><br><span class="line">				data = dataList.get(<span class="number">0</span>);</span><br><span class="line">				LOGGER.debug(<span class="string">&quot;using only data: &#123;&#125;&quot;</span>, data);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				data = dataList.get(ThreadLocalRandom.current().nextInt(size));</span><br><span class="line">				LOGGER.debug(<span class="string">&quot;using random data: &#123;&#125;&quot;</span>, data);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> data;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//查看所有结点</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">watchNode</span><span class="params">(<span class="keyword">final</span> ZooKeeper zk)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			List&lt;String&gt; nodeList = zk.getChildren(Constant.ZK_REGISTRY_PATH, <span class="keyword">new</span> <span class="title class_">Watcher</span>() &#123;</span><br><span class="line"></span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(WatchedEvent event)</span> &#123;</span><br><span class="line">					<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">					<span class="keyword">if</span> (event.getType() == Event.EventType.NodeChildrenChanged) &#123;</span><br><span class="line">						watchNode(zk);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">			List&lt;String&gt; dataList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">			<span class="keyword">for</span> (String node : nodeList ) &#123;</span><br><span class="line">				<span class="type">byte</span>[] bytes = zk.getData(Constant.ZK_REGISTRY_PATH + <span class="string">&quot;/&quot;</span> + node, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">				dataList.add(<span class="keyword">new</span> <span class="title class_">String</span>(bytes));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">this</span>.dataList = dataList;</span><br><span class="line">			LOGGER.debug(<span class="string">&quot;node data: &#123;&#125;&quot;</span>, dataList);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (KeeperException | InterruptedException e) &#123;</span><br><span class="line">			LOGGER.error(<span class="string">&quot;&quot;</span>, e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//连接到zookeeper</span></span><br><span class="line">	<span class="keyword">private</span> ZooKeeper <span class="title function_">connectServer</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		 <span class="type">ZooKeeper</span> <span class="variable">zk</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	        <span class="keyword">try</span> &#123;</span><br><span class="line">	            zk = <span class="keyword">new</span> <span class="title class_">ZooKeeper</span>(registryAddress, Constant.ZK_SESSION_TIMEOUT, <span class="keyword">new</span> <span class="title class_">Watcher</span>() &#123;</span><br><span class="line">	                <span class="meta">@Override</span></span><br><span class="line">	                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(WatchedEvent event)</span> &#123;</span><br><span class="line">	                    <span class="keyword">if</span> (event.getState() == Event.KeeperState.SyncConnected) &#123;</span><br><span class="line">	                        latch.countDown();</span><br><span class="line">	                    &#125;</span><br><span class="line">	                &#125;</span><br><span class="line">	            &#125;);</span><br><span class="line">	            latch.await();</span><br><span class="line">	        &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">	            LOGGER.error(<span class="string">&quot;&quot;</span>, e);</span><br><span class="line">	        &#125;</span><br><span class="line">	        <span class="keyword">return</span> zk;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第八步：发送RPC请求"><a href="#第八步：发送RPC请求" class="headerlink" title="第八步：发送RPC请求"></a>第八步：发送RPC请求</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;resource&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span> &#123;</span><br><span class="line">    	<span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;spring-client.xml&quot;</span>);</span><br><span class="line">    	</span><br><span class="line">    	<span class="type">RpcProxy</span> <span class="variable">rpcProxy</span> <span class="operator">=</span> context.getBean(RpcProxy.class);</span><br><span class="line">        </span><br><span class="line">    	<span class="type">IHelloService</span> <span class="variable">helloService</span> <span class="operator">=</span> rpcProxy.create(IHelloService.class);</span><br><span class="line">        </span><br><span class="line">    	<span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> helloService.hello(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    	System.out.println(result);</span><br><span class="line">        </span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​</p>
</li>
</ul>
<h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><p>参照网络上的一篇博客，自己照猫画虎搭建了一个轻量级RPC框架，了解学习了一些常听说的工具（例如Netty、Zookeeper）等在RPC框架中的应用场景。</p>
<p>搭建该框架的时候，使用Spring作为依赖注入框架，Netty实现NIO方式的数据传输、使用了高效的Protostuff对象序列化工具以及使用了Zookeeper作为分布式环境下的服务发现和服务注册。</p>
<p>具体来梳理下整个框架的运行逻辑。</p>
<ol>
<li><p>启动RpcServer</p>
<p>1.1 通过运行RpcBootstap类，加载了服务器端的spring.xml并启动了IoC容器，随后将xml文件中声明的Bean都实例化；</p>
<p>1.2 扫描带有RpcService注解的类，建立服务接口—服务实现类的映射</p>
<p>1.3 执行RpcServer的初始化操作，包括连接到Zookeeper服务进行服务注册，启动Netty NIO的事件轮询线程池和工作线程池等</p>
</li>
<li><p>客户端App类的运行</p>
<p>2.1 加载客户端配置的spring.xml并启动IoC容器将声明的Bean实例化</p>
<p>2.2 调用RpcProxy的create方法获取服务接口IHelloService的代理类</p>
<p>2.3 执行代理类的hello方法，代理类将请求封装成RpcRequest类，然后连接到Zookeeper服务进行服务发现获取主机地址和端口号，然后调用RpcClient发送请求，获取结果。</p>
<p>2.4 RpcClient配置并启动一个Netty EventLoopGroup，将封装的RpcRuest请求发送出去；</p>
<p>2.5 RpcRequest经由RpcEncoder序列化为二进制数据，然后经由TCP协议发送出去；</p>
<p>2.6 客户端收到来自服务端的二进制数据响应，然后通过RpcDecoder反序列化为RpcResponse类</p>
</li>
<li><p>服务器端接受到该RpcRequest的二进制数据，经由RpcDecoder反序列为RpcRequest类，然后通过服务接口—服务实现类映射表查找到对应的实现类Bean，再通过反射调用对应的方法，获取到结果；然后封装成RpcResponse类，随即被RpcEncoder序列化为二进制数据，并交由netty通过TCP协议发送到客户端；</p>
</li>
</ol>
<p>详细代码参见：<a href="https://github.com/Spground/RpcDemo">https://github.com/Spground/RpcDemo</a></p>
<h1 id="4-Reference"><a href="#4-Reference" class="headerlink" title="4. Reference"></a>4. Reference</h1><p><a href="https://my.oschina.net/huangyong/blog/361751?p=2&temp=1519544796844#blog-comments-list">https://my.oschina.net/huangyong/blog/361751?p=2&amp;temp=1519544796844#blog-comments-list</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://spground.github.io/2018/02/03/java%20lock/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Spground">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spground Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Spground Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/02/03/java%20lock/" class="post-title-link" itemprop="url">Java并发中的锁</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-02-03 00:00:00" itemprop="dateCreated datePublished" datetime="2018-02-03T00:00:00+08:00">2018-02-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-24 22:30:21" itemprop="dateModified" datetime="2025-09-24T22:30:21+08:00">2025-09-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-并发控制和锁"><a href="#1-并发控制和锁" class="headerlink" title="1. 并发控制和锁"></a>1. 并发控制和锁</h1><p>在多处理器的时代，程序设计中经常采用多线程以充分利用处理器的性能。在多线程环境下，由于存在共享变量、共享资源等情况，因此有时候需要对多线程的并发访问进行控制。</p>
<p>同很多并发控制的问题类似（例如数据库的并发控制），程序中的并发控制也会使用到例如加<strong>悲观锁、乐观锁、多版本视图</strong>等技术来完成并发控制（或者称为多线程同步）。因此谈到并发控制，基本上会涉及到锁的概念，而涉及到锁的问题也基本是属于并发控制问题的范畴。</p>
<h1 id="2-Java中的锁"><a href="#2-Java中的锁" class="headerlink" title="2. Java中的锁"></a>2. Java中的锁</h1><p>Java中涉及到很多锁的概念，而涉及到的使用层次也不同，因此这里做一个简单的总结。</p>
<ol>
<li><p><strong>内置锁&#x2F;隐式锁</strong></p>
<p>Java的每一个对象都有一个<code>monitor</code>，且这个<code>monitor</code>每一次仅能被一个线程所拥有，这就是内置锁或者叫隐式锁。内置锁的获取、释放通常是如下的范式写的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(obj) &#123;</span><br><span class="line">  <span class="comment">//当线程获取到obj的内置锁--monitor时，线程会进入到此代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>释放内置锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.wait();<span class="comment">//当前线程放弃obj对象上的内置锁</span></span><br></pre></td></tr></table></figure>

<p>或者退出<code>synchronized</code>代码块，也会自动释放获取的内置锁。</p>
</li>
<li><p><strong>显式锁</strong></p>
<p>顾名思义，显式锁是显式定义的锁。例如并发工具包的<code>Lock</code>接口下的一些实现类。</p>
<p>内置锁在<code>Java</code>的<code>synchronized</code>关键字的配合下使用起来十分的简单，但是简答的预定义的东西往往缺乏灵活性，因此为了补充内置锁，显示锁提供了一些额外的特性例如：<strong>可轮询</strong>、<strong>可超时</strong>、<strong>可中断锁</strong>等。这些特性在实际的编程中提供着很大的灵活性。</p>
<p><code>Lock</code>类的实现类常见的主要是<code>ReentrantLock</code>类。</p>
<p>该类提供了几个重要的方法：</p>
<ul>
<li><code>lock()</code> 语义同<code>synchronized</code></li>
<li><code>tryLock()</code> 提供了可超时的特性，在某些情况下可以通过该特性<strong>避免死锁</strong>的发生</li>
<li><code>lockInterruptibly() throws InterruptedException</code> 在获取锁失败被阻塞的时候可被<strong>中断</strong>，而采用<code>synchronized</code>获取内置锁的时候，无法被中断</li>
</ul>
<p>​</p>
</li>
<li><p><strong>可重入锁</strong>(Reentrant Lock)</p>
<p>可重入锁指的是已经获取了某个锁的线程去尝试再一次该锁的时候，是可以直接获取到的，而不会阻塞。</p>
<p>可重入锁避免了如下的死锁情况的产生:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">  set();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">()</span> &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果锁不可重入，那么当线程A获取到了“保护”get方法的锁时，那么再进入set方法的时候，会无限期阻塞。而此时，除了线程A，没有任何线程拥有该锁，因此线程A相相等于握着锁去等锁，首尾相连形成死锁了。</p>
</li>
<li><p><strong>读写锁</strong>(Read Write Lock)</p>
<p>通常的锁都为互斥锁，大多数被共享的变量都是由这种互斥锁保护。一个时刻只能有一个线程在访问该变量。这个在该变量<strong>读多写少</strong>的情况下显然效率不高。因为<strong>读读</strong>不需要并发控制，而<strong>读写、 写写</strong>才需要并发控制。那么显然应该同数据库的并发控制加锁的策略一样，应该提供两种锁，一个是共享锁（读锁）、另一个是互斥锁（写锁），当读取变量的时候，主需要获取共享锁，而写变量的时候才去获取互斥锁。</p>
<p><code>Java</code>并发包中提供了常用的<code>ReentrantReadWriteLock</code>锁，该锁提供了<strong>读锁、写锁、以及锁降级</strong>等特性。</p>
<ul>
<li><code>readLock()</code> 返回该读写锁对应的读锁</li>
<li><code>writeLock()</code> 返回该读写锁对应的写锁</li>
</ul>
<p>当线程获取写锁的时候，如果该读写锁的读锁、写锁被其他线程占有，则该线程获取锁失败；</p>
<p>当线程获取读锁的时候，如果没有线程持有写锁，则获取读锁成功；否则，获取读锁失败；</p>
<p>读写所允许<strong>锁降级</strong>：当一个线程持有写锁的时候，可以直接降级为读锁，而<strong>不支持锁升级</strong>，因为锁升级会可能会引发死锁（当两个持有读锁的线程，同时进行锁升级，那么这两个线程都不会释放自己的读锁，从而发生死锁）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">ReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">r</span> <span class="operator">=</span> lock.readLock(), w = lock.writeLock();</span><br><span class="line">...</span><br><span class="line">w.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  sb.append(append); <span class="comment">//降级为read lock</span></span><br><span class="line">  r.lock();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  w.unlock();<span class="comment">//still hold read lock</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  r.unlock();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>​</p>
</li>
<li><p><strong>偏向锁</strong>(Biased Lock)</p>
<p>偏向锁是<code>JDK1.6</code>引入的一项锁优化，指的是偏向锁会偏向第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要同步。在某些情况下，锁不存在多线程竞争的情况，而总是由同一线程在获取、释放、获取、释放。因此，引入了偏向锁，让此种情况下的锁获取的代价变小，偏向锁可以提高<strong>带有同步但无竞争</strong>的程序性能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BiasLockDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="type">long</span> <span class="variable">t</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">		List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();<span class="comment">//选择Vector是由于其add方法是synchronized修饰的；</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000_0000</span>; i++) &#123;</span><br><span class="line">			list.add(i);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;cost: &quot;</span> + (System.currentTimeMillis() - t) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>-XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0</code>开启偏向锁后，运行时间：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cost: 340ms</span><br></pre></td></tr></table></figure>

<p><code>-XX:-UseBiasedLocking</code>禁用偏向锁后，运行时间：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cost: 519ms</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>公平锁&#x2F;非公平锁</strong></p>
<p>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的先后顺序来获得锁。</p>
<p>非公平锁是指多个线程在等待同一个锁时，是按按照不确定的顺序来选择某一个线程获取锁。</p>
<p>通常来讲，<strong>公平锁的性能低于非公平锁，但是公平锁可以解决线程饥饿的问题</strong>。</p>
<p><code>Java</code>中可以使用<code>new ReentrantLock(true)</code>构造得到公平锁，而<code>synchronized</code>则提供的内置锁是非公平的。</p>
<p>ps: <code>Java</code>中提供的显式锁一般都提供Fair和Non-Fair模式，但是即便是公平模式也会提供一些允许<code>插队(barging)</code>的方法允许线程先于等待在前面的线程得到锁。</p>
</li>
<li><p><strong>悲观锁&#x2F;乐观锁</strong></p>
<p>悲观锁：主要的并发控制策略之一，假设冲突总是发生，如果不采取同步措施，例如对共享的变量或者资源加锁，那么肯定会出现问题，类似于<strong>事前预防</strong>。因此无论共享的数据无论是是否出现竞争冲突，都会对它进行正确的同步。</p>
<p>乐观锁：和悲观锁不一样，乐观并发控制策略先进行操作，如果操作的数据没出现竞争，那么操作成功；如果操作的数据出现竞争，那么再进行一些后续的弥补操作（常见的就是不断的重试、或者重试数次返回失败信息），类似<strong>事后弥补</strong>，实现乐观并发控制策略有多种常见的方式：</p>
<ul>
<li>CAS</li>
<li>时间戳</li>
<li>版本号</li>
</ul>
<p>存在即合理，悲观锁和乐观锁都有其应用的场景，当数据争用、冲突发生频繁的场景，悲观锁较适合；而数据争用、冲突不频繁的场景，乐观锁则更适合。</p>
</li>
<li><p><strong>自旋锁</strong>(Spinning Lock)</p>
<p>互斥同步的时候，当线程获取锁失败的时候，通常会进入阻塞状态，<code>java</code>线程和操作系统线程是一一对应的，挂起和恢复线程操作需要由<strong>用户态转入核心态</strong>完成，这些操作<strong>耗时、耗资源</strong>。但是某些情况下，某一个线程只会将锁独占很短时间，或者是说很快 便完成了同步代码块的执行，因此其它线程为了这点时间选择将自己挂起、恢复十分没有必要。因此，特别是在多处理环境下，可以让后面请求独占锁失败的线程，进行<strong>自旋</strong>（忙循环）一会儿，而不是阻塞挂起线程。</p>
<p>自旋锁的引入是为了解决锁被独占的时间很短的情况下，避免线程被挂起-恢复带来的<code>overhead</code>，因此当锁独占的时间本来就很长的，这种锁便没有存在的意义了。</p>
<p><code>JVM</code>中可以通过参数：</p>
<p><code>-XX:+UseSpinning</code>开启自旋锁功能；<code>JDK1.6</code>默认是开启的。</p>
<p><code>-XX:PreBlockSpin</code>配置每次自旋的次数，默认是10次；</p>
<p>​</p>
</li>
</ol>
<h1 id="3-死锁和活锁"><a href="#3-死锁和活锁" class="headerlink" title="3. 死锁和活锁"></a>3. 死锁和活锁</h1><h2 id="3-1-死锁"><a href="#3-1-死锁" class="headerlink" title="3.1 死锁"></a>3.1 死锁</h2><p>并发中问题中的死锁最经典莫过于<a href="https://en.wikipedia.org/wiki/Dining_philosophers_problem"><strong>哲学家就餐</strong></a>问题，死锁常常发生在系统高负载环境下，多线程竞争某一共享数据的情况下。当线程A持有锁L的时候同时，线程B持有锁M并尝试获得L，那么这两个线程将永远等待下去。这种情况就是最简单的死锁形式，多个线程由于存在环路的依赖关系而永远的等待下去。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/7b/An_illustration_of_the_dining_philosophers_problem.png/463px-An_illustration_of_the_dining_philosophers_problem.png"></p>
<p>死锁发生最常见的的根本原因就是：<strong>多个线程存在环路的依赖关系</strong>。</p>
<p>比如<code>A</code>等待B，B等待C，C等待D, …, Z等待A，则A间接的等待A，形成环路，发生死锁。</p>
<p>环路的产生具体有如下几种情况：</p>
<ul>
<li><strong>锁顺序死锁</strong>：加锁的顺序不一致导致的死锁；</li>
<li><strong>动态的锁顺序死锁</strong>：方法内部加锁顺序是一致的，但是由于锁被参数化了，因此调用该方法时，锁的顺序取决于方法调用者传来的参数，因此也会动态的产生锁顺序死锁。</li>
<li><strong>协作对象之间发生的死锁</strong></li>
<li><strong>资源死锁</strong> 例如：线程A持有数据库连接D1并等待D2，而线程B持有数据库连接D2，等待D1则A、B之间出现死锁</li>
</ul>
<p>解决死锁问题通常有两个角度来解决，<strong>死锁避免和死锁解除</strong>，一个属于事前预防，另一个是事后弥补；</p>
<p>数据库系统中，为避免死锁，有一个著名的<strong>两阶段加锁协议</strong>，同时，事务管理器可以通过环路判断死锁的存在，并取消一个代价小的事务以达到死锁的解除。</p>
<p><code>Java</code>没有数据库事务管理器那么强大，<code>Java</code>中也有一些方法可以避免死锁，但是当死锁发生的时候，除了重启应用别无他法。</p>
<p><code>Java</code>中的死锁避免：</p>
<ul>
<li><strong>加锁顺序保持相同</strong>（synchronized提供的内置锁只能通过此种方式来避免死锁的发生）</li>
<li><strong>采用可轮询的、可超时的锁</strong>(显式锁Lock提供<code>tryLock(long timeout)</code>轮询和超时的特性，因此不会无限的等待下去，当超时的时候，程序可以简单的重试，或者放弃获取该锁，释放已有的锁。同时这种方式通过引入<strong>随机因素</strong>也可以有限的解决<strong>活锁的问题</strong>)</li>
</ul>
<h2 id="3-2-活锁"><a href="#3-2-活锁" class="headerlink" title="3.2 活锁"></a>3.2 活锁</h2><p>死锁是形成死锁的线程全部处于无限等待状态，而<strong>活锁则是线程不断的重复执行相同的操作，而且总是失败</strong>。就相当于线程在执行一个循环的操作序列，周而复始，无穷无尽，导致系统的状态整体停滞不前。</p>
<p>最形象的例子便是：</p>
<blockquote>
<p>两个过于礼貌的人甲乙，相向走在一个狭窄的巷子里面，甲和乙同时让对方先走，然后甲乙同时准备接受对方的谦让自己先走，然后两人又同时让对方先走…，如此循环往复，两人没有等待，始终处于活动状态，但是两人始终都无法通过巷子。</p>
</blockquote>
<p>同样的类似活锁的例子就是，以太网的共享介质传输信息时，也会出现活锁的问题，以太网技术采用了一种叫做<strong>载波多路访问-冲突检测（CSMA-CD）<strong>的技术，该技术引入了一些</strong>随机因素</strong>来避免活锁。</p>
<p>同样的，解决活锁的问题，可以在<strong>重试机制中以引入随机性</strong>，这样可以有效的避免活锁问题。</p>
<h1 id="4-reference"><a href="#4-reference" class="headerlink" title="4.reference"></a>4.reference</h1><p>[1]. Java并发编程实践</p>
<p>[2]. 深入理解JVM虚拟机</p>
<p>[3]. <a href="http://www.importnew.com/19472.html">http://www.importnew.com/19472.html</a></p>
<p> [4]. <a href="https://www.cnblogs.com/qifengshi/p/6831055.html">https://www.cnblogs.com/qifengshi/p/6831055.html</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://spground.github.io/2018/01/27/Morris%20binary-tree%20traverse/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Spground">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spground Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Spground Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/01/27/Morris%20binary-tree%20traverse/" class="post-title-link" itemprop="url">Morris 遍历</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-01-27 00:00:00" itemprop="dateCreated datePublished" datetime="2018-01-27T00:00:00+08:00">2018-01-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-24 22:30:21" itemprop="dateModified" datetime="2025-09-24T22:30:21+08:00">2025-09-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-二叉树遍历"><a href="#1-二叉树遍历" class="headerlink" title="1. 二叉树遍历"></a>1. 二叉树遍历</h1><p>树是最重要的数据结构之一，而树的遍历是树最基本的操作。</p>
<p>二叉树的遍历一般来说有三种遍历次序：</p>
<ul>
<li>前序遍历 </li>
<li>中序遍历</li>
<li>后序遍历</li>
</ul>
<p>而这三种遍历次序都可以采用<strong>递归</strong>和<strong>非递归</strong>的方式来完成。</p>
<p>就时间、空间的复杂度来讲，因为非递归需要借助额外的<code>Stack</code>来完成操作，所以递归和非递归的时间复杂度都是<code>O(n)</code>，<code>O(logn)</code>。</p>
<p>那么有没有另外的不同的二叉树遍历方法，在时间或空间能做到更优的呢？答案是：<strong>Morris 遍历</strong>。</p>
<p>由于在遍历的时候，我们需要记住某种遍历次序的的<strong>后驱</strong>或者<strong>前驱</strong>结点，常见的递归和非递归都是采用<strong>栈</strong>的方式完成这个过程，有没有内部空间来记录这些后驱或者前驱结点呢？有，那就是叶结点的左，右孩子结点，因为叶结点的两个孩子结点都是空指针，如果利用好这些空间，我们就可以在<code>O(1)</code> 的空间完成遍历。</p>
<p>利用叶结点的左、右孩子指向遍历的前驱或者后驱结点，这些指针叫做<strong>线索</strong>，对应的二叉树叫做<strong>线索二叉树</strong>。</p>
<p><img src="/images/tree_traversal.png"></p>
<p><a href="https://en.wikipedia.org/wiki/Tree_traversal#Morris_in-order_traversal_using_threading"><strong>Morris遍历</strong>是使用线索二叉树进行中序遍历的一种实现</a>，其可以在<code>O(n)</code>的时间，<code>O(1)</code>的空间完成遍历， 对其稍加修改可以推广到<strong>先序、后序遍历</strong>，其遍历过程包含三个部分：</p>
<ol>
<li>创建指向<strong>中序后驱</strong>结点的线索；</li>
<li>遍历输出结点；</li>
<li>删除线索，恢复树的结构；</li>
</ol>
<h1 id="2-Morris-中序遍历"><a href="#2-Morris-中序遍历" class="headerlink" title="2. Morris 中序遍历"></a>2. Morris 中序遍历</h1><p><strong>Morris 中序遍历过程如下：</strong></p>
<ol>
<li><p>当前结点的左孩子是否为空，若是则输出当前结点，更当前结点为当前结点的右孩子；否则进入2；</p>
</li>
<li><p>在当前结点的左子树中寻找中序遍历下的前驱结点（左子树中最右结点）</p>
<p>a. 若前驱结点的右孩子为空，则将前驱结点的右孩子指向当前结点，当前结点更新为当前结点的左孩子；进入3；</p>
<p>b. 若前驱结点的右孩子为当前结点（不为空），将前驱结点的右孩子置NULL，输出当前结点，当前结点更新为当前结点的右孩子，进入3；</p>
</li>
<li><p>若当前结点不为空，进入1；否则程序结束；</p>
</li>
</ol>
<p><strong>伪代码如下：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cur = root</span><br><span class="line">repeat until cur != NULL:</span><br><span class="line">	if cur.left != NULL:</span><br><span class="line">		pre = cur.left;</span><br><span class="line">		while pre.right == NULL &amp;&amp; pre.right != cur://找到前驱结点pre</span><br><span class="line">			pre = pre.right</span><br><span class="line">		if pre.right == NULL:</span><br><span class="line">			pre.right = cur</span><br><span class="line">			cur = cur.left</span><br><span class="line">		else:</span><br><span class="line">			print(cur)</span><br><span class="line">			pre.right = NULL</span><br><span class="line">			cur = cur.right</span><br><span class="line">	else:</span><br><span class="line">		print(cur)</span><br><span class="line">		cur = cur.right</span><br></pre></td></tr></table></figure>



<p>下图为每一步迭代的结果（从左至右，从上到下），<code>cur</code>代表当前节点，深色节点表示该节点已输出。</p>
<p><img src="/images/morris_in_order.jpg"></p>
<p>以下为<code>Java</code>的实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">	<span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root, pre = <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">for</span> (; cur != <span class="literal">null</span>;) &#123;</span><br><span class="line">		<span class="keyword">if</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">			pre = cur.left;</span><br><span class="line">			<span class="comment">// find predecessor</span></span><br><span class="line">			<span class="keyword">while</span> (pre.right != <span class="literal">null</span> &amp;&amp; pre.right != cur)</span><br><span class="line">				pre = pre.right;</span><br><span class="line">			<span class="keyword">if</span> (pre.right == <span class="literal">null</span>) &#123;<span class="comment">// create thread</span></span><br><span class="line">				pre.right = cur;</span><br><span class="line">				cur = cur.left;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				print(cur);</span><br><span class="line">				pre.right = <span class="literal">null</span>;</span><br><span class="line">				cur = cur.right;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			print(cur);</span><br><span class="line">			cur = cur.right;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="3-Morris-前序遍历"><a href="#3-Morris-前序遍历" class="headerlink" title="3. Morris 前序遍历"></a>3. Morris 前序遍历</h1><p>对于前序遍历，只需要在中序遍历的基础上稍加修改便可以完成。</p>
<p><strong>Morris 前序遍历的流程如下：</strong></p>
<ol>
<li><p>当前结点的左孩子是否为空，若是则输出当前结点，并更新当前结点为当前结点的右孩子；否则进入2；</p>
</li>
<li><p>在当前结点的左子树中寻找中序遍历下的前驱结点（左子树中最右结点）</p>
<p>a. 若前驱结点的右孩子为空，则将前驱结点的右孩子指向当前结点，输出当前结点（<strong>在这里输出，和中序遍历不同的地方</strong>），当前结点更新为当前结点的左孩子；进入3；</p>
<p>b.  若前驱结点的右孩子为当前结点（不为空），将前驱结点的右孩子置NULL，当前结点更新为当前结点的右孩子，进入3；</p>
</li>
<li><p>若当前结点不为空，进入1；否则程序结束；</p>
</li>
</ol>
<p>伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cur = root;</span><br><span class="line">repeat until cur != NULL:</span><br><span class="line">	if cur.left != NULL:</span><br><span class="line">		pre = cur.left;</span><br><span class="line">		while pre.right == NULL &amp;&amp; pre.right != cur://找到前驱结点pre</span><br><span class="line">			pre = pre.right</span><br><span class="line">		if pre.right == NULL:</span><br><span class="line">			pre.right = cur</span><br><span class="line">			print(cur)//此处和中序遍历不同</span><br><span class="line">			cur = cur.left</span><br><span class="line">		else:</span><br><span class="line">			pre.right = NULL</span><br><span class="line">			cur = cur.right</span><br><span class="line">	else:</span><br><span class="line">		print(cur)</span><br><span class="line">		cur = cur.right</span><br></pre></td></tr></table></figure>



<p>下图为每一步迭代的结果（从左至右，从上到下），<code>cur</code>代表当前节点，深色节点表示该节点已输出。</p>
<p><img src="/images/morris_in_order.jpg"></p>
<p>以下为<code>Java</code>的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">	<span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root, pre = <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">for</span> (;cur != <span class="literal">null</span>;) &#123;</span><br><span class="line">		<span class="keyword">if</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">			pre = cur.left;</span><br><span class="line">			<span class="comment">// find predecessor</span></span><br><span class="line">			<span class="keyword">while</span> (pre.right != <span class="literal">null</span> &amp;&amp; pre.right != cur)</span><br><span class="line">				pre = pre.right;</span><br><span class="line">			<span class="keyword">if</span> (pre.right == <span class="literal">null</span>) &#123;<span class="comment">// create thread</span></span><br><span class="line">				print(cur);<span class="comment">// print node here </span></span><br><span class="line">				pre.right = cur;</span><br><span class="line">				cur = cur.left;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				pre.right = <span class="literal">null</span>;<span class="comment">//delete thread</span></span><br><span class="line">				cur = cur.right;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			print(cur);</span><br><span class="line">			cur = cur.right;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="4-Morris-后序遍历"><a href="#4-Morris-后序遍历" class="headerlink" title="4. Morris 后序遍历"></a>4. Morris 后序遍历</h1><p>后序遍历的流程如下：</p>
<ol start="0">
<li><p>新建一个<code>Dummy</code>结点，该结点的左孩子指向树根<code>root</code>，将<code>Dummy</code>作为当前结点；</p>
</li>
<li><p>当前结点的左孩子是否为空，更新当前结点为当前结点的右孩子；否则进入2；</p>
</li>
<li><p>在当前结点的左子树中寻找中序遍历下的前驱结点（左子树中最右结点）：</p>
<p>a. 若前驱结点的右孩子为空，则将前驱结点的右孩子指向当前结点，当前结点更新为当前结点的左孩子，进入3；</p>
<p>b. 若前驱结点的右孩子为当前结点（不为空），<strong>反转当前结点到前驱结点之间的路径，输出该路径所有结点；反转当前结点到前驱结点之间的路径，恢复原状</strong>。将前驱结点的右孩子置NULL，当前结点更新为当前结点的右孩子，进入3；</p>
</li>
<li><p>若当前结点不为空，进入1；否则程序结束；</p>
</li>
</ol>
<p>伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">dummy = Node(-1)</span><br><span class="line">dummy.left = root</span><br><span class="line">cur = dummy</span><br><span class="line">repeat until cur != NULL:</span><br><span class="line">	if cur.left != NULL:</span><br><span class="line">		pre = cur.left;</span><br><span class="line">		while pre.right == NULL &amp;&amp; pre.right != cur://找到前驱结点pre</span><br><span class="line">			pre = pre.right</span><br><span class="line">		if pre.right == NULL:</span><br><span class="line">			pre.right = cur</span><br><span class="line">			cur = cur.left</span><br><span class="line">		else:</span><br><span class="line">			reverse(cur.left, pre)</span><br><span class="line">			print(pre, cur.left)</span><br><span class="line">			reverse(pre, cur.left)//再次反转，恢复原状</span><br><span class="line">			pre.right = NULL</span><br><span class="line">			cur = cur.right</span><br><span class="line">	else:</span><br><span class="line">		cur = cur.right</span><br></pre></td></tr></table></figure>



<p>下图为每一步迭代的结果（从左至右，从上到下），<code>cur</code>代表当前节点，深色节点表示该节点已输出。</p>
<p><img src="/images/morris_post_order.jpg"></p>
<p>以下为<code>Java</code>的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="type">TreeNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(-<span class="number">1</span>);</span><br><span class="line">		dummy.left = root;</span><br><span class="line">		<span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy, pre = <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">for</span> (;cur != <span class="literal">null</span>;) &#123;</span><br><span class="line">			<span class="keyword">if</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">				pre = cur.left;</span><br><span class="line">				<span class="comment">// find predecessor</span></span><br><span class="line">				<span class="keyword">while</span> (pre.right != <span class="literal">null</span> &amp;&amp; pre.right != cur)</span><br><span class="line">					pre = pre.right;</span><br><span class="line">				<span class="keyword">if</span> (pre.right == <span class="literal">null</span>) &#123;<span class="comment">// create thread</span></span><br><span class="line">					pre.right = cur;</span><br><span class="line">					cur = cur.left;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;<span class="comment">//print here</span></span><br><span class="line">					reverse(cur.left, pre);</span><br><span class="line">					print(pre, cur.left);</span><br><span class="line">					reverse(pre, cur.left);</span><br><span class="line">					pre.right = <span class="literal">null</span>;</span><br><span class="line">					cur = cur.right;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				cur = cur.right;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(TreeNode from, TreeNode to)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">for</span> (;;from = from.right) &#123;</span><br><span class="line">			print(from);</span><br><span class="line">			<span class="keyword">if</span> (from == to) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(TreeNode from, TreeNode to)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">if</span> (from == to) <span class="keyword">return</span>;</span><br><span class="line">		<span class="type">TreeNode</span> <span class="variable">x</span> <span class="operator">=</span> from, y = from.right, z= <span class="literal">null</span>;</span><br><span class="line">		x.right = <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">			z = y.right;</span><br><span class="line">			y.right = x;</span><br><span class="line">			x = y;</span><br><span class="line">			<span class="keyword">if</span> (y == to) <span class="keyword">break</span>;</span><br><span class="line">			y = z;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>完整的代码：详见</p>
<p><a href="https://github.com/Spground/archive/blob/master/misc/code/MorrisTraversalDemo.java">https://github.com/Spground/archive/blob/master/misc/code/MorrisTraversalDemo.java</a></p>
<h1 id="5-References"><a href="#5-References" class="headerlink" title="5. References"></a>5. References</h1><ol>
<li><a href="http://www.cnblogs.com/AnnieKim/archive/2013/06/15/MorrisTraversal.html">http://www.cnblogs.com/AnnieKim/archive/2013/06/15/MorrisTraversal.html</a></li>
<li><a href="https://en.wikipedia.org/wiki/Tree_traversal#Morris_in-order_traversal_using_threading">https://en.wikipedia.org/wiki/Tree_traversal#Morris_in-order_traversal_using_threading</a></li>
<li><a href="https://en.wikipedia.org/wiki/Threaded_binary_tree#The_array_of_Inorder_traversal">https://en.wikipedia.org/wiki/Threaded_binary_tree#The_array_of_Inorder_traversal</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://spground.github.io/2018/01/17/Threads%20and%20Thread%20pools/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Spground">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spground Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Spground Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/01/17/Threads%20and%20Thread%20pools/" class="post-title-link" itemprop="url">Java线程池</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-01-17 00:00:00" itemprop="dateCreated datePublished" datetime="2018-01-17T00:00:00+08:00">2018-01-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-24 22:30:21" itemprop="dateModified" datetime="2025-09-24T22:30:21+08:00">2025-09-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-Java线程与线程池"><a href="#1-Java线程与线程池" class="headerlink" title="1. Java线程与线程池"></a>1. Java线程与线程池</h1><h2 id="1-1-线程"><a href="#1-1-线程" class="headerlink" title="1.1 线程"></a>1.1 线程</h2><p>相比于“繁重”的进程，线程可以算是一种轻量级的进程，大多数操作系统都是支持以线程作为调度执行单元以提高系统的并发性。毫不例外，Java也支持多线程。</p>
<p>多个线程交替甚至并行的执行，特别在多处理器时代，可以极大的提高资源的利用率。<strong>通常我们使用多线程来并发的执行多个具有明显边界的任务</strong>，例如Web服务器使用多线程来同时处理来自多个用户的请求，每一个请求便是一个独立的、有边界的任务。</p>
<p>在<code>Java</code>中新建一个线程通常有两种方式：</p>
<ul>
<li>new Thread() 方式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//这里是将要被执行的代码		</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>new Thread(new Runnable())方式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;	</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//这里是将要被执行的代码	</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br></pre></td></tr></table></figure>

<p>第一种方式存在一个很大的缺点：<strong>被执行的代码（任务）和执行机制（如何执行这些任务）耦合了</strong>。</p>
<p>如果将<strong>任务</strong>和<strong>执行机制</strong>分别抽象出来，那么久会获得更好的灵活性。第二种通过<code>Runnable</code>方式创建线程的方式，正好克服了这个缺点，<code>Runnable</code>抽象了任务，而<code>Thread</code>抽象了<code>执行机制</code>，一个线程可以通过维护一个工作队列，采取不同的执行策略来执行多个不同的的任务。</p>
<p>因此，第二种创建线程的方式是使用得最多、也更推荐的方式，后面讨论的<code>Executor</code>等内容都会看见这种创建线程的方式。</p>
<p>线程创建完毕后，调用<code>start()</code>方法便可以启动该线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.start()</span><br></pre></td></tr></table></figure>

<p><code>Java</code>线程大致分为两类：</p>
<ol>
<li><strong>守护线程</strong> 通过 方法<code>setDaemon(true)</code>将某个线程设置为守护线程</li>
<li><strong>非守护线程</strong> 默认创建的是非守护线程</li>
</ol>
<p>当<code>JVM</code>启动时候，会创建一个<strong>非守护线程</strong>执行<code>main</code>方法，这个线程有时候也被称为<code>主线程</code>，然后程序可以自主的创建守护线程和非守护线程。<code>JVM</code>一直执行所有被创建的线程，当调用<code>System.exit()</code>或者<code>JVM</code>中所有的非守护线程都死了（正常执行<code>run</code>方法完毕或者未处理异常层层上抛最后抛到了<code>JVM</code>层），此时<code>JVM</code>停止。</p>
<p>到这里我们都在使用一个名为<code>Thread</code>的类，现在有这么几个问题？</p>
<ul>
<li><code>Thread</code>类都有哪些常用的方法？</li>
<li>Java中的线程和OS线程是一一对应的吗？亦或是多对一？甚至是多对多？</li>
</ul>
<p>常用的方法用：</p>
<ol>
<li>start() ：启动一个该线程</li>
<li>sleep(long time): 让该线程让出<code>CPU</code>进入睡眠，直到指定的time后，恢复然后进入可运行状态。</li>
<li>yield(): 主动让出CPU</li>
<li>interrupt() : 向该线程发出一个中断请求</li>
<li>isInterrupt(): 返回该线程是否存在中断请求</li>
<li>interrupted(): 返回该线程是否存在中断请求，并清空线程的中断状态。</li>
</ol>
<p>对于<code>Java</code>的线程和OS线程的对应关系，通过查看源代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        ....</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           start0();</span><br><span class="line">           started = <span class="literal">true</span>;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                   group.threadStartFailed(<span class="built_in">this</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">               <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">                 it will be passed up the call stack */</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>调用了<code>start0()</code>方法，是一个<code>native</code>方法：查看<code>OpenJDK</code>的<code>\src\share\native\java\lang\Thread.c</code>源码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> JNINativeMethod methods[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;start0&quot;</span>,           <span class="string">&quot;()V&quot;</span>,        (<span class="type">void</span> *)&amp;JVM_StartThread&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;stop0&quot;</span>,            <span class="string">&quot;(&quot;</span> OBJ <span class="string">&quot;)V&quot;</span>, (<span class="type">void</span> *)&amp;JVM_StopThread&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;isAlive&quot;</span>,          <span class="string">&quot;()Z&quot;</span>,        (<span class="type">void</span> *)&amp;JVM_IsThreadAlive&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;suspend0&quot;</span>,         <span class="string">&quot;()V&quot;</span>,        (<span class="type">void</span> *)&amp;JVM_SuspendThread&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;resume0&quot;</span>,          <span class="string">&quot;()V&quot;</span>,        (<span class="type">void</span> *)&amp;JVM_ResumeThread&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;setPriority0&quot;</span>,     <span class="string">&quot;(I)V&quot;</span>,       (<span class="type">void</span> *)&amp;JVM_SetThreadPriority&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;yield&quot;</span>,            <span class="string">&quot;()V&quot;</span>,        (<span class="type">void</span> *)&amp;JVM_Yield&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;sleep&quot;</span>,            <span class="string">&quot;(J)V&quot;</span>,       (<span class="type">void</span> *)&amp;JVM_Sleep&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;currentThread&quot;</span>,    <span class="string">&quot;()&quot;</span> THD,     (<span class="type">void</span> *)&amp;JVM_CurrentThread&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;countStackFrames&quot;</span>, <span class="string">&quot;()I&quot;</span>,        (<span class="type">void</span> *)&amp;JVM_CountStackFrames&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;interrupt0&quot;</span>,       <span class="string">&quot;()V&quot;</span>,        (<span class="type">void</span> *)&amp;JVM_Interrupt&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;isInterrupted&quot;</span>,    <span class="string">&quot;(Z)Z&quot;</span>,       (<span class="type">void</span> *)&amp;JVM_IsInterrupted&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;holdsLock&quot;</span>,        <span class="string">&quot;(&quot;</span> OBJ <span class="string">&quot;)Z&quot;</span>, (<span class="type">void</span> *)&amp;JVM_HoldsLock&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;getThreads&quot;</span>,        <span class="string">&quot;()[&quot;</span> THD,   (<span class="type">void</span> *)&amp;JVM_GetAllThreads&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;dumpThreads&quot;</span>,      <span class="string">&quot;([&quot;</span> THD <span class="string">&quot;)[[&quot;</span> STE, (<span class="type">void</span> *)&amp;JVM_DumpThreads&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> THD</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> OBJ</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> STE</span></span><br><span class="line"></span><br><span class="line">JNIEXPORT <span class="type">void</span> JNICALL</span><br><span class="line"><span class="title function_">Java_java_lang_Thread_registerNatives</span><span class="params">(JNIEnv *env, jclass cls)</span></span><br><span class="line">&#123;</span><br><span class="line">    (*env)-&gt;RegisterNatives(env, cls, methods, ARRAY_LENGTH(methods));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>start0</code>对应于<code>JVM_StartThread</code>函数，该函数是<code>JVM</code>提供的一个<code>API</code>函数，查找<code>HotSpot</code>下的<code>\src\share\vm\prims\jvm.cpps</code>，找到对应的方法：发现该出实际上<code>new JavaThread</code>， <code>JavaThread</code>是<code>HotSpot</code>定义的<code>C++</code>类。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JVM_ENTRY</span>(<span class="type">void</span>, <span class="built_in">JVM_StartThread</span>(JNIEnv* env, jobject jthread))</span><br><span class="line">      ....</span><br><span class="line">      <span class="type">size_t</span> sz = size &gt; <span class="number">0</span> ? (<span class="type">size_t</span>) size : <span class="number">0</span>;</span><br><span class="line">      native_thread = <span class="keyword">new</span> <span class="built_in">JavaThread</span>(&amp;thread_entry, sz);   </span><br><span class="line">      Thread::<span class="built_in">start</span>(native_thread);</span><br><span class="line">JVM_END</span><br></pre></td></tr></table></figure>

<p>在<code>\src\share\vm\runtime\thread.cpp</code>找到<code>JavaThread</code>的定义：其调用了<code>os::create_thread()</code>函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JavaThread::<span class="built_in">JavaThread</span>(ThreadFunction entry_point, <span class="type">size_t</span> stack_sz) :</span><br><span class="line">  <span class="built_in">Thread</span>()</span><br><span class="line">  ....</span><br><span class="line">  os::<span class="built_in">create_thread</span>(<span class="keyword">this</span>, thr_type, stack_sz);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>OS::create_thread</code>函数的实现是依赖于不同操作系统，这里选择<code>linux</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">os::create_thread</span><span class="params">(Thread* thread, ThreadType thr_type, <span class="type">size_t</span> stack_size)</span> </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">pthread_create</span>(&amp;tid, &amp;attr, (<span class="type">void</span>* (*)(<span class="type">void</span>*)) java_start, thread);</span><br><span class="line">    ....</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此看出了实际上是<code>pthread_create</code>为我们创建了一个线程，而Java线程OS线程是一对一的关系。</p>
<p>到这里，对于线程简单的总结算是完成了，我们知道当我们需要并发处理多个任务时，我们可以简单的创建一个新的线程去处理这些任务，但是这样的方式在高负载的情况下确是不明智的。</p>
<h2 id="1-2-线程池"><a href="#1-2-线程池" class="headerlink" title="1.2 线程池"></a>1.2 线程池</h2><p>针对每一个需要被执行的任务都创建一个线程来执行的方式虽然很直观，但是存在如下缺点:</p>
<ul>
<li>线程创建与销毁代价非常高，当任务到达的速度特别快时，为每个任务创建一个线程会快速消耗掉系统资源。</li>
<li>当线程的数量大于CPU的数量的时候，当CPU正在100%工作的时候，这时为每一个到来的任务创建一个线程只会耗费额外的内存，而不会提高资源利用率</li>
</ul>
<p>由于不能无限制的创建线程，因此<strong>将一定数量的线程放在一个池中形成一个线程池，同时维护一个任务队列，让这些线程不停的去执行任务</strong>，是一个有效解决上述缺点的好办法。</p>
<p>线程池主要用来解决线程<strong>生命周期开销问题</strong>和<strong>资源不足</strong>问题。通过对多个任务重复使用线程，<strong>线程创建的开销就被分摊到了多个任务上了</strong>，而且由于在新任务到达时线程已经存在，所以消除了线程创建所带来的延迟。这样，就可以立即执行新的任务，使响应更快。另外，通过适当的动态的调整线程中的线程数目可以防止出现资源不足的情况。</p>
<p>使用线程池提交任务这种模型和<strong>生产者-消费者</strong>模式是何其的相似。</p>
<p>任务提交者便是生产者</p>
<p>线程池维护的工作队列便是缓冲区</p>
<p>线程池维护的那些线程便是消费者</p>
<p><img src="http://www.baeldung.com/wp-content/uploads/2016/08/2016-08-10_10-16-52-1024x572.png"></p>
<p>对于一个线程池来讲，它应该需要关注的主要是：</p>
<ul>
<li>创建多少个线程？</li>
<li>工作队列中的任务数量是否有上边界?</li>
<li>当工作队列的任务数量少于线程数量的时候，需要回收线程吗？</li>
<li>这么多线程并发的访问工作队列等共享资源时，如何正确的进行同步而又不降低效率？</li>
<li>如何让任务提交者对已经提交的任务进行操作（获取结果、取消任务）？</li>
<li>如何优雅的关闭线程池？</li>
<li>……</li>
</ul>
<p>上述每一个关注点无疑都是需要精心设计、反复推敲的，如果<code>from scratch</code>构建一个线程池，对实现者的要求是极高的。因此<code>Java</code>为广大用户提高了一个线程池框架，通过该框架我们可以较容易的完成一些常见的多线程任务。</p>
<h1 id="2-Executor框架"><a href="#2-Executor框架" class="headerlink" title="2. Executor框架"></a>2. Executor框架</h1><p><code>Java</code>提供的线程池框架主要涉及到如下的类和接口：</p>
<ul>
<li>Executors： 通过很多静态方法，提供不同的预配置的线程池；</li>
<li>Executor： Executor最上层的接口，只包含<code>execute(Runnable command)</code>方法；</li>
<li>ExecutorService： Executor的子接口；包含很多有用的方法，例如<code>submmit()、shutDown()、shutDownNow()、awaitTermination()、invokeAll()</code>;</li>
<li>ThreadPoolExecutor： 具体的线程池的实现类；</li>
</ul>
<h2 id="2-1-Executors"><a href="#2-1-Executors" class="headerlink" title="2.1 Executors"></a>2.1 Executors</h2><p>工具类Executors主要提供以下几种预配置的线程池：</p>
<ol>
<li><p><code>newFixedThreadPool(int nThreads)</code> 创建一个包含<code>nThreads</code>个线程的线程池，共享一个无边界的工作队列，在任何时刻，线程池最多有<code>nThreads</code>个存活线程；当某个线程由于执行过程中出现错误而死亡，则新建一个线程以补充。</p>
<p>例如：创建一个包含5个线程的线程池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Executor</span> <span class="variable">exe</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">exe.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>​</p>
</li>
<li><p><code>newSingleThreadExecutor()</code>创建仅仅包含一个线程的线程池，维护着一个无边界的工作队列，在任何时刻，线程池只能有一个任务被执行，任务被保证顺序的执行。如果线程由于执行过程中出现错误而死亡，则新建一个线程代替继续执行任务；和<code>newFixedThreadPool(1)</code>不一样，一旦线程池创建，该线程池不能再进行配置。这是通过将<code>ThreadPoolExecutor</code>包装成包装类实现的，因此该方法返回的<code>Executor</code>不能强制转化为<code>ThreadPoolExecutor</code>;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span> <span class="comment">//包装类</span></span><br><span class="line">           (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">e</span> <span class="operator">=</span> (ThreadPoolExecutor) Executors.newSingleThreadExecutor(); <span class="comment">//强转将失败</span></span><br></pre></td></tr></table></figure>

<p>​</p>
</li>
<li><p><code>newCachedThreadPool()</code>创建一个线程池，当新任务被提交，如果池中没有空余的存活线程，则该线程池会创建新的线程；如果有存活的多余的线程则会复用该线程；当某个线程空闲超过60秒的时候，该线程会被终止然后被移除线程池。<strong>这种线程池适合被用于处理大量耗时短的任务</strong>，因为设置了一个空闲超时时间，这样当整个线程池都闲下来时，基本不会暂用额外的资源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Executor</span> <span class="variable">exe</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">exe.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>​</p>
</li>
<li><p><code>newSingleThreadScheduledExecutor</code>和<code>newThreadScheduledExecutor(int coreThreadSize)</code>分别是创建包含一个线程和指定数量的线程，该线程池的线程定时的执行一些任务；</p>
<p>以上是<code>Executors</code>包含的一些常用的静态方法，它为我们预配置一些常用的线程池，但是在某些时候，这些预配置的满足不了需求，<code>JDK</code>也通过<code>ThreadPoolExecutor</code>重载的构造方法让使用者根据自己的需求进行线程池配置。</p>
</li>
</ol>
<h2 id="2-2-ThreadPoolExecutor"><a href="#2-2-ThreadPoolExecutor" class="headerlink" title="2.2 ThreadPoolExecutor"></a>2.2 ThreadPoolExecutor</h2><p>   上述提到的<code>Executors</code>中的静态方法返回的预配置线程池，也是通过调用不同<code>ThreadPoolExecutor</code>的构造方法完成的。</p>
<p>   具体来讲，<code>ThreadPoolExecutor</code>构造方法有几个：</p>
<ul>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,<span class="type">int</span> maximumPoolSize,<span class="type">long</span> keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue)</span></span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,<span class="type">int</span> maximumPoolSize,<span class="type">long</span> keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory)</span></span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,<span class="type">int</span> maximumPoolSize,<span class="type">long</span> keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler)</span></span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,<span class="type">int</span> maximumPoolSize,<span class="type">long</span> keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>综合来看就是如下几个配置参数：</p>
<ul>
<li><p>corePoolSize</p>
<p>指定<strong>常驻</strong>线程池中的线程的数量；当由于某些原因，线程池中的线程数量小于corePoolSize时，线程池负责创建新的线程来补充，直到数量达到corePoolSize。</p>
</li>
<li><p>maximumPoolSize</p>
<p>指定线程池中最多的线程数量，<code>maximumPoolSize &gt;= corePoolSize</code>恒成立。对于<code>newFixedThreadPool</code>和<code>newSingleThreadPool</code>的配置为<code>maximumPoolSize = corePoolSize</code>;而对于<code>newCachedThreadPool</code>中的配置为<code>maximumPoolSize = Integer.MAX_VALUE &gt; corePoolSize = 0</code>。</p>
</li>
<li><p>keepAliveTime&#x2F;unit</p>
<p>当线程池中线程数量大于<code>corePoolSize</code>的时候，对于的线程的空闲时间超过<code>keepAliveTime</code>后，会被终止，从线程池中移除。在<code>newCachedThreadPool</code>中，这个值默认是<code>60</code>秒。<code>unit</code>为时间单位。</p>
</li>
<li><p>workQueue</p>
<p>线程池中用于维护那些已经提交但还未被执行的任务；</p>
</li>
<li><p>threadFactory</p>
<p>负责创建线程的线程工厂；</p>
</li>
<li><p>handler</p>
<p>当工作队列里面待处理的任务已经达到工作队列的最大容量时或者线程池已经（或正在）关闭，其他任务提交者提交的任务将会被拒绝执行；线程池会回调这个handler来通知这次拒绝。</p>
</li>
</ul>
<p>示例：</p>
<p>创建一个常驻线程数量为2的，最大线程数量为5的，多余线程空闲超时为30秒的， 无界工作队列的线程池：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Executor = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">2</span>, <span class="number">5</span>, <span class="number">30</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;());</span><br></pre></td></tr></table></figure>

<h1 id="3-Future、Callable"><a href="#3-Future、Callable" class="headerlink" title="3. Future、Callable"></a>3. Future、Callable</h1><p>现在有了配置好的线程池，接下来便是向线程池提交我们的任务。</p>
<p>通常来讲，任务按有无返回值可以分为两类：</p>
<ul>
<li>无返回值：这类任务不关心返回值，例如复制一个文件；</li>
<li>有返回值：这类任务关系返回值，例如请求一个网络资源；</li>
</ul>
<p><code>JDK</code>提供两种相似的接口来达到上述目的：</p>
<ul>
<li>Runnable ： 包含<code>void run()</code>方法，无返回值；也不会抛出受检查的异常；</li>
<li>Callable<V> ： 包含<code>V call()</code>， 有返回值，会抛出受检查的异常；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</span></span><br><span class="line"><span class="comment">     * to create a thread, starting the thread causes the object&#x27;s</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</span></span><br><span class="line"><span class="comment">     * thread.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</span></span><br><span class="line"><span class="comment">     * take any action whatsoever.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     java.lang.Thread#run()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无论是<code>Runnable</code>还是<code>Callable</code>，任务提交者希望可以在向线程池提交任务后，获得一个关于该任务的Handle，以便任务提交者对任务进行控制（取消任务、查看任务是否完成、获取任务执行结果）这种类似于Handle的便是<code>Future</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Future</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span>;</span><br><span class="line">    V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line">    V <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException,       TimeoutException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>示例：</p>
<p>当提交一个获取网页的任务后，主线程通过<code>Future</code>获取任务执行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(), rEH);</span><br><span class="line">		Callable&lt;String&gt; call = <span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">				<span class="comment">//模拟网络请求</span></span><br><span class="line">				Thread.sleep(<span class="number">500</span>);</span><br><span class="line">				<span class="keyword">return</span> <span class="string">&quot;TEST&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		Future&lt;String&gt; f = e.submit(call);</span><br><span class="line">		<span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> f.get();<span class="comment">//阻塞直到结果返回</span></span><br><span class="line">		System.out.println(res);</span><br></pre></td></tr></table></figure>

<h1 id="4-References"><a href="#4-References" class="headerlink" title="4. References"></a>4. References</h1><ol>
<li><a href="http://www.baeldung.com/thread-pool-java-and-guava">http://www.baeldung.com/thread-pool-java-and-guava</a></li>
<li><a href=""><em>Java Conccurency in Practice</em></a></li>
<li><a href="http://www.blogjava.net/stevenjohn/archive/2011/12/12/366161.html">http://www.blogjava.net/stevenjohn/archive/2011/12/12/366161.html</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://spground.github.io/2018/01/09/Index%20in%20Database/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Spground">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spground Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Spground Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/01/09/Index%20in%20Database/" class="post-title-link" itemprop="url">数据库索引</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-01-09 00:00:00" itemprop="dateCreated datePublished" datetime="2018-01-09T00:00:00+08:00">2018-01-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-24 22:30:21" itemprop="dateModified" datetime="2025-09-24T22:30:21+08:00">2025-09-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><p>大量的结构化数据通常被存储在数据库中，通过简单的<code>SQL</code>语句，我们可以方便的查询、修改、插入、删除这些数据。例如当我们执行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">USER</span> <span class="keyword">WHERE</span> userName <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><code>DBMS</code>会将表中所有用户名等于<code>A</code>的用户的记录返回给我们，但随着表中的记录越来越多，比如说从<code>10000</code>增加到<code>1000万</code>，这时候我们往往会发现查询的速度会变慢很多。这时候，通常的做法就是在<code>userName</code>列上面创建<strong>索引</strong>，以加快数据的查询。</p>
<p>那么<strong>什么是数据库索引</strong>、<strong>为什么数据库索引可以加快查询</strong>以及<strong>如何正确的使用数据库索引</strong>呢？以下将从这个几个方面做一下简单的总结。</p>
<h1 id="2-数据库索引"><a href="#2-数据库索引" class="headerlink" title="2. 数据库索引"></a>2. 数据库索引</h1><h2 id="2-1-改善数据库查询"><a href="#2-1-改善数据库查询" class="headerlink" title="2.1 改善数据库查询"></a>2.1 改善数据库查询</h2><h3 id="2-1-1-用树形数据结构进行查找"><a href="#2-1-1-用树形数据结构进行查找" class="headerlink" title="2.1.1 用树形数据结构进行查找"></a>2.1.1 用树形数据结构进行查找</h3><p>通常来讲，我们在对数据库中数据最频繁的操作便是查询，比如我们给定一定的查询条件将某个表的数据记录查询出来，因此这实际就是一个<strong>查找问题</strong>。</p>
<p>查找问题最简单直接的就是<strong>顺序查找</strong>，其时间复杂度为<code>O(N)</code>。</p>
<p>例如第1节中的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">USER</span> <span class="keyword">WHERE</span> userName <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>假设<code>userName</code>列中不存在重复值，很显然我们在查找这条记录的时候需要对数据表中数据记录一行一行的扫描，然后直到找到我们需要的那条记录，这种方式的平均时间复杂度是<code>O(N/2)</code></li>
<li>假设<code>userName</code>列中存在重复值，这时情况更加糟糕，我们需要进行所谓的<strong>全表扫描</strong>找到所有的记录，这种方式的时间复杂度是<code>O(N)</code></li>
</ul>
<p>即便是在<strong>内存</strong>中对大量数据进行<code>O(N)</code>的查询我们也很难接受，更何况是这些数据是存在<strong>外部存储</strong>设备上（常见便是<strong>磁盘</strong>）。磁盘的一次访问时间大约是<code>8ms</code>，而内存的一次访问约<code>50ns</code>。</p>
<p>因此当数据量特别大的时候，数据库用<strong>顺序查找</strong>的方式进行数据查找几乎是不可接受的。</p>
<p>在众多的用于查找的数据结构中，<strong>平衡的树形结构</strong>是十分合适被用来进行查找，其查找的时间复杂度可以降到<code>O(logN)</code>，当然某些<strong>数据库索引</strong>便是采用树形结构来组织的。</p>
<p>到现在，我们总结了为什么要使用数据库索引的原因，并且我们总结了数据库索引可以使用树形数据结构来加快数据的查询。下面给出<a href="https://en.wikipedia.org/wiki/Database_index">维基百科</a>的定义:</p>
<blockquote>
<p>数据库索引是一种花费额外存储空间以加快数据库数据检索的数据结构。</p>
</blockquote>
<p>我们知道我们可以采用<strong>平衡二叉排序树</strong>来组织数据库索引，每个节点存储关键字和其对应的数据（或者数据所在的磁盘地址）。这样在进行查询的时候，我们可以将时间复杂度降低到我们需要的<code>O(logN)</code>。但是实际上数据库索引并不是采用这种二叉树的数据结构，而是采用<code>B-Tree</code>来实现数据库索引以加快数据查询。关于为什么不使用二叉搜索树的原因以及<code>B-Tree</code>是什么，2.1.2会进行总结。</p>
<h3 id="2-1-2-B-Tree"><a href="#2-1-2-B-Tree" class="headerlink" title="2.1.2 B-Tree"></a>2.1.2 B-Tree</h3><p><img src="http://img.blog.csdn.net/20161215230141403?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveW9uZ2hlbmdfMTk5OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>
<p>上图为磁盘的某个盘面的解剖示意图，由于一次寻道操作很慢，为了数据读取的有效性，磁盘是按扇区为单位存储和访问数据的。关于磁盘的工作原理，参见这篇<a href="http://blog.csdn.net/yongheng_1999/article/details/53678814">博文</a>。</p>
<ol>
<li>如果我们用二叉搜索树组织<code>10000</code>个关键字，那么我们的树的高度约为：14。因此如果我们要查询叶节点上的关键字则需要14次磁盘访问，大约耗时:<code>8ms*14=112ms</code>。虽然这个结果对于顺序查找好了不少，但实际上为了降低磁盘访问次数，我们可以进一步将树变得矮一点便可以<strong>降低磁盘访问次数</strong>，从而提高查询速度。</li>
<li>为了降低树的高度，我们将二叉树中的每个节点最多<strong>俩孩子变为多个孩子</strong>，便可以将树的高度大大降低。</li>
</ol>
<p><img src="https://techdifferences.com/wp-content/uploads/2017/10/Untitled-7.jpg"></p>
<p>而这种平衡的、每个节点多与2个孩子节点的树形数据结构便是<code>B-Tree</code>。上图是一个简单的对比图，从图中我们可以看出<code>B Tree</code>相比二叉树，其每一个结点里面含有<strong>多个关键字</strong>，从而大大降低了树的高度。当每个结点允许存放100个关键字的时候，<code>10000</code>个关键字的B  Tree树高大约为2，因此仅需要2次磁盘访问便可以访问到数据，大约耗时<code>8ms*2=16ms</code>，相比于前面的二叉树来讲，性能又提升了不少。<code>B Tree</code>的结点的大小通常被设置为一个扇区的大小（假如说是<code>4KB</code>），这样一次磁盘访问便可以读取到该节点所有关键字。</p>
<p>简单总结一下：<strong>由于数据存储在磁盘上，考虑到磁盘的特性，因此通过将结点的大小增加到一个扇区的大小，从而降低查找树的高度以减少耗时的磁盘访问次数，这就是<code>B Tree</code>适合用来查找基于外部存储数据的主要原因。</strong></p>
<p>到这里我们总结了数据库索引为什么不采用二叉搜索树实现的原因。接下来我们稍微简单的总结下<code>B Tree</code>相关的内容。</p>
<p>来自<a href="https://en.wikipedia.org/wiki/B-tree">维基</a>的定义：</p>
<blockquote>
<p>在计算机科学中，<code>B</code>树是一棵自平衡树，它允许在<code>logN</code>的时间内完成查找、顺序访问、插入和删除。B树是一种泛化的二叉搜索树，其结点可以拥有超过2个孩子结点。</p>
</blockquote>
<p>一棵5阶的B树大概长这样（5阶指的是孩子节点数量最多为5）：</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/65/B-tree.svg/600px-B-tree.svg.png"></p>
<p>B树中的结点通常分为<strong>三类</strong>：</p>
<ul>
<li>根结点：包含关键字，包含关键字的个数<strong>有上界无下界</strong>，有孩子结点，包含指向孩子结点的指针</li>
<li>内部结点：包含关键字，且包含关键字的个数<strong>有上下界</strong>，有孩子结点，包含指向孩子结点的指针</li>
<li>叶子结点：包含关键字，且包含关键字的个数<strong>有上下界</strong>，没有孩子结点，不包含指向孩子结点的指针</li>
</ul>
<p>关于B树的性质的描写有很多种，以下是从《算法导论》总结出来的：</p>
<p><code>B</code>树应该满足的性质：</p>
<ol>
<li>每个叶结点具有相同的深度，即树的高度<code>h</code></li>
<li>每个结点所包含的关键字个数都有个下界（根节点没有下界）和上界，上下界通过一个被称为<strong>B树的最小度数</strong>的<code>t&gt;=2</code>来表示<ul>
<li>除了根节点以外，每个结点至少含有<code>t-1</code>个关键字；因此除了根节点以外的每个内部结点至少含有<code>t</code>个孩子。如果树非空，根节点至少能含有1个关键字以保证树的最小度<code>t&gt;=2</code></li>
<li>每个结点最多包含<code>2t-1</code>个关键字。因此一个内部结点最多有<code>2t</code>个孩子，当一个结点恰好有<code>2t-1</code>个关键字的时候，称该结点是<strong>满的</strong></li>
</ul>
</li>
</ol>
<p>另外，有的地方存在<strong>阶</strong>的概念，指的是B树允许非叶子结点的最大孩子结点个数，关于<code>B Tree</code>的基本操作<code>Search</code>、<code>Insertion</code>、<code>Delete</code>等将在下一篇博文介绍，这里不做介绍。</p>
<p>数据库索引中的<code>B</code>树中，每个结点包含如下内容：</p>
<ul>
<li>存储代表被索引数据库列的关键字</li>
<li>指向孩子结点的指针</li>
<li>指向数据库记录的指针</li>
</ul>
<p><code>B Tree</code>虽然能很好的帮助我们改善诸如<code>WHERE userName = &#39;A&#39;</code>之类的查询，但是<code>B</code>树还存在以下两个缺点：</p>
<ol>
<li>但是对于一些常见的<strong>范围查询</strong>，例如<code>WHERE age &gt; 10</code>等，我们就需要中序遍历<code>B</code>树，这会增加缓存miss率，从而增加我们的磁盘访问次数。</li>
<li>与此同时，由于我们在结点中不仅仅存储了指向孩子结点的指针，而且还存储了指向数据库记录的指针，因此每个结点的<strong>大小就会较大</strong>，又由于扇区的大小通常是固定的，因此每个结点包含的关键字的个数就会<strong>减少</strong>，也就是说<code>B</code>的阶会<strong>降低</strong>（树会变高）。</li>
</ol>
<p>因此为避免上述两个缺点，<code>B</code>树的变体<code>B+</code>树便应运而生。</p>
<h3 id="2-1-3-B-树"><a href="#2-1-3-B-树" class="headerlink" title="2.1.3 B+树"></a>2.1.3 B+树</h3><p>同B树不同，B+树主要有如下不同：</p>
<ul>
<li>B+树中关键字和指向数据记录的指针仅仅存放在<strong>叶子结点</strong>；</li>
<li>B+树中<strong>同一关键字可能出现在多个结点中</strong>，但是仅仅叶子结点还有指向数据记录的指正；而B树<strong>同一关键字仅仅可能出现在一个结点中</strong>；</li>
<li>由于B+树的关键字和数据记录的信息仅仅保存在叶子结点中，因此无论查找是否成功，都会深入到B+树的叶子结点，因此<strong>查询时间基本上是稳定</strong>的；而B树的查询时间和关键字在树中的位置有关，因此<strong>查询时间不是稳定的</strong>；</li>
</ul>
<p>除此之外，<strong>B+树将叶结点通过链表的形式连接起来</strong>，这样避免了<strong>范围查询</strong>或者<strong>全表扫描</strong>的时候，对B树的中序遍历。</p>
<p>下图是B树和B+树的对比图：</p>
<p><img src="https://i.stack.imgur.com/l6UyF.png"></p>
<h2 id="2-2-数据库索引的类型"><a href="#2-2-数据库索引的类型" class="headerlink" title="2.2 数据库索引的类型"></a>2.2 数据库索引的类型</h2><p>由于不同数据库提供的索引分类不同，因此很多时候索引分类是混乱的。但是常见的数据库索引主要有如下几种：</p>
<ol>
<li><strong>聚集索引（Clustered Index）</strong>：数据表中的记录的物理顺序和索引关键字的逻辑顺序是一致的。由于这个特性，聚集索引能够大大加快类似顺序检索、反序检索和范围查询。由于聚集索引的逻辑顺序和记录的物理顺序是一致的，显然一张数据表聚集索引<strong>只能有一个</strong>，<strong>通常建立在主键上</strong>。</li>
<li><strong>非聚集索引（Non-Clustered Index）</strong>：和聚集索引相反，记录的物理顺序和索引关键字的逻辑顺序不是一致的。因此一个数据表可以有<strong>0个或者多个</strong>非聚集索引。</li>
<li><strong>唯一索引（Unique Index）</strong>：唯一索引是不允许其中任何两行具有相同索引值的索引。</li>
<li><strong>非唯一索引（Non-Unique Index）</strong>：允许任何两行具有相同索引值的索引，仅仅是用来加快查询。</li>
<li><strong>主键索引（Primary Index）</strong>：建立在主键上的索引，由于主键具有<strong>唯一性</strong>，因此从某种意义上来讲，<strong>主键索引</strong>也是<strong>唯一索引</strong>，又因为主键列具有<strong>不经常修改</strong>等特性，因此主键索引通常也设置为<strong>聚集索引</strong>。由于主键索引的特殊性，大多数数据库都会默认在主键上自动创建主键索引。</li>
</ol>
<h1 id="3-创建数据库索引"><a href="#3-创建数据库索引" class="headerlink" title="3. 创建数据库索引"></a>3. 创建数据库索引</h1><p>虽然索引会加快数据的查询，但是维护索引需要<strong>额外的空间和时间</strong>。因此需要在<strong>合适的列上创建合适的索引</strong>的，否则只会盲目的创建索引只会适得其反。</p>
<p><strong>适合创建索引</strong>的列具有如下特点：</p>
<ul>
<li>对于经常处于WHERE、JOIN、OrderBy字句中的列应该创建索引，以加快查询</li>
<li>对于需要<strong>保持唯一性</strong>的列，需要在创建<strong>唯一索引</strong></li>
<li>主键列默认是创建<strong>主键索引</strong></li>
<li><strong>聚集索引</strong>应该创建在<strong>很少修改</strong>的列</li>
</ul>
<p><strong>不适合创建索引</strong>的列具有如下特点：</p>
<ul>
<li><p>查询中很少使用或者参考的列不应该创建索引；</p>
</li>
<li><p>对于取值很少的列，例如性别列没必要创建索引；</p>
</li>
<li><p>定义为text、image、bit的列不适和创建索引；</p>
</li>
<li><p>频繁修改的列不适合创建索引，维护索引的代价会很大；</p>
<p>​</p>
</li>
</ul>
<p>因为物理顺序和逻辑顺序是一致的，如果被索引的列频繁更新，为了维护逻辑顺序很物理顺序的一致性，会付出很大的代价，因此聚集索引应该建立在<strong>很少和不更新的列</strong>上面，</p>
<h1 id="4-References"><a href="#4-References" class="headerlink" title="4. References"></a>4. References</h1><ol>
<li><a href="https://stackoverflow.com/questions/1108/how-does-database-indexing-work">https://stackoverflow.com/questions/1108/how-does-database-indexing-work</a></li>
<li><a href="https://stackoverflow.com/questions/107132/what-columns-generally-make-good-indexes/8937872#8937872">https://stackoverflow.com/questions/107132/what-columns-generally-make-good-indexes/8937872#8937872</a></li>
<li><a href="https://stackoverflow.com/questions/870218/differences-between-b-trees-and-b-trees">https://stackoverflow.com/questions/870218/differences-between-b-trees-and-b-trees</a></li>
<li><a href="http://blog.csdn.net/yongheng_1999/article/details/53678814">http://blog.csdn.net/yongheng_1999&#x2F;article&#x2F;details&#x2F;53678814</a></li>
<li><a href="http://blog.csdn.net/kennyrose/article/details/7532032">http://blog.csdn.net/kennyrose/article/details/7532032</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://spground.github.io/2018/01/04/Isolation%20level%20in%20MySQL%20transactions/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Spground">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spground Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Spground Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/01/04/Isolation%20level%20in%20MySQL%20transactions/" class="post-title-link" itemprop="url">数据库事务隔离级别</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-01-04 00:00:00" itemprop="dateCreated datePublished" datetime="2018-01-04T00:00:00+08:00">2018-01-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-24 22:30:21" itemprop="dateModified" datetime="2025-09-24T22:30:21+08:00">2025-09-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-数据库事务"><a href="#1-数据库事务" class="headerlink" title="1.数据库事务"></a>1.数据库事务</h2><blockquote>
<p>事务是用户定义的一个数据库操作系列，这些操作要么全做要么全不做，是一个不可分割的工作单位。</p>
</blockquote>
<p>事务是数据库中重要的概念，通常以<code>BEGIN TRANSACTION</code>开始，以<code>COMMIT</code>或者<code>ROLLBACK</code>结束。数据库事务具有四个著名的特性：<code>ACID</code>。</p>
<ul>
<li><p>Automatic</p>
<p>原子性：即事务中的操作要么都做，要么都不做。</p>
</li>
<li><p>Consistency</p>
<p>一致性：事务的执行的结果必须是使数据库从一个<code>一致性状态</code>到另一个<code>一致性状态</code>。这里的一致性状态指的是物理和逻辑上的数据库一致性状态。</p>
<p>比如一个银行系统内部各个用户直接互相转账，无论如何转账，系统内部的金额的总数总是恒定不变的。</p>
</li>
<li><p>Isolation</p>
<p>隔离性：一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对其他并发事务是隔离的，并发执行的各个事务之间不能相互干扰。</p>
</li>
<li><p>Duration</p>
<p>持久性：一个事务一旦提交，它对数据库中数据的改变就该是永久性的。</p>
<p>事务的<code>ACID</code>特性需要数据库管理系统保证，同时事务也是数据库管理系统<strong>恢复</strong>和<strong>并发控制</strong>的基本单位。</p>
</li>
</ul>
<h2 id="2-数据库并发控制"><a href="#2-数据库并发控制" class="headerlink" title="2. 数据库并发控制"></a>2. 数据库并发控制</h2><h3 id="2-1-数据不一致性"><a href="#2-1-数据不一致性" class="headerlink" title="2.1 数据不一致性"></a>2.1 数据不一致性</h3><p>第1节提到了事务是并发控制的基本单位，由于并发控制可能会导致事务的<code>ACID</code>特性遭到破坏，从而带来了数据库的数据不一致性。具体来讲，由于并发操作，多个事务的并发执行会带来如下四个典型的数据不一致性问题，而这几种问题主要是由于并发操作破坏了事务的<strong>隔离性</strong>（<code>Isolation</code>）导致的，第3节会介绍<code>MySQL</code>数据库中并发控制机制下不同的事务隔离级别。</p>
<ol>
<li><p><strong>丢失修改</strong></p>
<p>这种问题是最直观，最不应该发生的，例如两个事务<code>T1</code>和<code>T2</code>都读入同一数据进行修改，这样<code>T1</code>提交修改结果后，随即<code>T2</code>也提交了结果。这样，<code>T2</code>便将<code>T1</code>对数据的修改给覆盖了，这样就出现了丢失修改的问题了。</p>
<p>这种问题发生的最主要原因是：<strong>两个或多个事务都在对同一数据项进行写操作</strong>。</p>
</li>
<li><p><strong>不可重复读</strong></p>
<p>不可重复读指的是：事务<code>T1</code>读取了某个数据项<code>A</code>，在事务<code>T1</code>运行期间又有其他事务例如<code>T2</code>对数据项<code>A</code>进行了修改并提交了，这样事务<code>T1</code>再次读取数据项<code>A</code>的时候，发现结果不一致了。</p>
<p>这种问题发生的最主要原因是：<strong>一个事务在对某一个数据项进行读操作，而另外的其他事务对该数据项进行了写操作。</strong></p>
</li>
<li><p><strong>读脏数据</strong></p>
<p>读脏数据指的是：事务<code>T1</code>正在修改某个数据项<code>A</code>，事务还未提交，而事务<code>T2</code>读取了数据项<code>A</code>，但是随后事务<code>T1</code>由于某种原因回滚了事务（并未提交事务），此时事务<code>T2</code>读取到的数据项<code>A</code>的值和数据库中的值是不一致的，称事务<code>T2</code>读了脏数据（<code>Read Dirty</code>）。</p>
<p>这种问题发生的最主要原因是：<strong>一个事务在对某一个数据项进行写操作，而另外的其他事务对该数据项进行了读操作。</strong></p>
</li>
<li><p><strong>幻读</strong></p>
<p>幻读指的是：事务<code>T1</code>按照某些条件从数据库中查询了一些数据记录，但是在事务<code>T1</code>执行过程中，事务<code>T2</code>插入或者删除了某些数据记录，这样当事务<code>T1</code>再一次按照同样的条件从数据库查询的时候，发现多了或者少了某些记录。<strong>幻读本质上属于不可重复读</strong>，这里为了和第3节的隔离级别作对照，所以将其单独划出来作为幻读。</p>
<p>产生的原因同不可重复读类似：<strong>由于事务<code>T1</code>按条件对数据表中的很多数据项查询的时候，这时候其他事务<code>T2</code>对数据表进行了其他数据项的写操作（插入、修改或者删除）。</strong></p>
<p>为解决并发带来的一系列问题，主要有<strong>封锁、时间戳和乐观控制法</strong>来进行并发机制的设计。而<strong>封锁</strong>是最常用的数据库管理系统并发机制采用的方法。</p>
</li>
</ol>
<h3 id="2-2-封锁和并发度"><a href="#2-2-封锁和并发度" class="headerlink" title="2.2 封锁和并发度"></a>2.2 封锁和并发度</h3><p>   封锁是实现并发控制的一个非常重要的技术。所谓封锁就是在事务对某个数据对象例如表、记录等进行操作的时候（读或写），先向系统请求对其加锁，成功加锁后，该事务才可以继续对其进行操作；否则，只能等待直到加锁成功。</p>
<p>   具体来说：基本的锁分为两种：</p>
<ul>
<li>排他锁（Exclusive Locks）又称写锁，X锁；</li>
<li>共享锁（Share Locks）又称读锁，S锁；</li>
</ul>
<p>   采用封锁确实能来保证并发下的数据库事务的特性，但是封锁带来了额外的系统开销，进而影响到系统的并发度。</p>
<p>   例如1：当事务<code>T1</code>对某个数据项<code>A</code>进行写操作的时候，为避免<strong>读脏数据</strong>， 那么所有的其他向对数据项<code>A</code>进行读取的事务都得进行等待，那么系统此刻的并发度就大大降低了。</p>
<p>   例如2：为避免<strong>幻读</strong>的产生，当事务<code>T1</code>对某一表<code>Table</code>中的某几行记录进项查询的时候，由于封锁了整个表<code>Table</code>，此时所有其他想对该表<code>Table</code>进项增加删除记录的事务都得进行等待，由于封锁的<strong>数据对象粒度太大</strong>，导致并发度大大降低。</p>
<p>   综上可以看出：<strong>封锁和并发度本来就是一种矛盾，一方面我们想要尽可能的保证事务的隔离性进而避免2.1节中的问题；另一方面我们有希望系统的并发度不要下降。</strong></p>
<p>   既然是矛盾，那就只能妥协，为了充分满足不同的应用场景，<code>MySQL</code>数据库<code>InnoDB</code>支持4种不同的事务隔离级别。</p>
<p>   第3节将结合两种不同的封锁类型来理解这四种不同的事务隔离级别。</p>
<h2 id="3-事务隔离级别"><a href="#3-事务隔离级别" class="headerlink" title="3. 事务隔离级别"></a>3. 事务隔离级别</h2><p>考虑到封锁和并发度的权衡，<code>MySQL</code>为用户提供了四种不同的事务隔离性级别。并发度从低到高（数据一致性强度从高到低）分别是：</p>
<ul>
<li>SERIALIZABLE（可串行化）可避免脏读、不可重复读、幻读情况的发生。</li>
<li>REPEATABLE READ（可重复读）可避免脏读、不可重复读情况的发生。</li>
<li>READ COMMITTED（读已提交）可避免脏读情况发生。</li>
<li>READ UNCOMMITTED（读未提交）最低级别，以上情况均无法保证。</li>
</ul>
<p>通过2.1节我们知道了几种数据不一致产生的主要原因，即写写和读写同时发生在多个事务对同一数据对象的情况下，另外还介绍了两种锁类型：X锁和S锁。</p>
<p>两个事务的X锁和S锁可以构成一个相容矩阵：如下：</p>
<table>
<thead>
<tr>
<th><strong>T1 &#x2F;  T2</strong></th>
<th><strong>X锁</strong></th>
<th><strong>S锁</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>X锁</strong></td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td><strong>S锁</strong></td>
<td>No</td>
<td>Yes</td>
</tr>
</tbody></table>
<p>含义就是：<code>T1</code>对数据项加了<code>X</code>锁，则<code>T2</code>不能对其加<code>S</code>和<code>X</code>锁，<code>T2</code>对数据项加了<code>S</code>锁，则<code>T1</code>可以对其加<code>S</code>锁而不能加<code>X</code>锁。（<strong>相容矩阵的加锁顺序都是是T1先加锁，T2后加锁</strong>）</p>
<ul>
<li>**READ UNCOMMITTED（读未提交）**最低级别，以上情况均无法保证。</li>
</ul>
<p>官网给出建议：该隔离级别仅仅能做查询</p>
<blockquote>
<p>The <strong>isolation level</strong> that provides the least amount of protection between transactions. Queries employ a <strong>locking</strong> strategy that allows them to proceed in situations where they would normally wait for another transaction. However, this extra performance comes at the cost of less reliable results, including data that has been changed by other transactions and not committed yet (known as <strong>dirty read</strong>). Use this isolation level with great caution, and be aware that the results might not be consistent or reproducible, depending on what other transactions are doing at the same time. Typically, transactions with this isolation level only do queries, not insert, update, or delete operations.</p>
</blockquote>
<p>由于其不能保证<strong>读脏数据</strong>，因此S锁和X是相容的；因此可能如下：</p>
<table>
<thead>
<tr>
<th>T1 &#x2F; T2</th>
<th>X锁</th>
<th>S锁</th>
</tr>
</thead>
<tbody><tr>
<td><strong>X锁</strong></td>
<td>No(?待考证)</td>
<td>Yes</td>
</tr>
<tr>
<td><strong>S锁</strong></td>
<td>Yes</td>
<td>Yes</td>
</tr>
</tbody></table>
<ul>
<li>**READ COMMITTED（读已提交）**可避免脏读情况发生。</li>
</ul>
<p>读已提交，避免脏读，但是不能保证可重复读；说明<code>T1</code>的<code>X</code>锁和<code>T2</code>的<code>S</code>锁不相容；而<code>S</code>锁和<code>X</code>锁相容的。<strong>也就是保证了某个事务在写数据项的时候，其他事务是不能读写该数据项的。</strong></p>
<table>
<thead>
<tr>
<th>T1 &#x2F; T2</th>
<th>X锁</th>
<th>S锁</th>
</tr>
</thead>
<tbody><tr>
<td><strong>X锁</strong></td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td><strong>S锁</strong></td>
<td>Yes</td>
<td>Yes</td>
</tr>
</tbody></table>
<ul>
<li>**REPEATABLE READ（可重复读）**可避免脏读、不可重复读情况的发生。</li>
</ul>
<p>可重复读，避免了脏读和不可重复读；说明<code>T1</code>的<code>X</code>锁和<code>T2</code>的<code>S</code>锁、<code>T1</code>的<code>S</code>锁和<code>T2</code>的<code>X</code>锁都不相容。<strong>也就是保证了某个事务在写某个数据项的时候，其他事务不能读写该数据项；且在读某个数据项时，其他事务只能读该数据项。</strong></p>
<table>
<thead>
<tr>
<th>T1 &#x2F;  T2</th>
<th>X锁</th>
<th>S锁</th>
</tr>
</thead>
<tbody><tr>
<td>X锁</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>S锁</td>
<td>No</td>
<td>Yes</td>
</tr>
</tbody></table>
<ul>
<li>**SERIALIZABLE（可串行化）**可避免脏读、不可重复读、幻读情况的发生。</li>
</ul>
<p>为了避免幻读、不可重复读、脏读、丢失修改等产生，将并发事务的<strong>事务调度策略</strong>设置为为<strong>可串行化调度</strong>，这能保证该事务调度策略的运行结果同<strong>某一种串行调度</strong>结果一致，但是这会极大的降低并发度；同时，这也是<code>MySQL</code>的<code>InnoDB</code>提供的最高的事务隔离级别，这里的相容矩阵同3。</p>
<blockquote>
<p>The <strong>isolation level</strong> that uses the most conservative locking strategy, to prevent any other <strong>transactions</strong> from inserting or changing data that was read by this transaction, until it is finished. This way, the same query can be run over and over within a transaction, and be certain to retrieve the same set of results each time. Any attempt to change data that was committed by another transaction since the start of the current transaction, cause the current transaction to wait.</p>
<p>This is the default isolation level specified by the SQL standard. In practice, this degree of strictness is rarely needed, so the default isolation level for <code>InnoDB</code> is the next most strict, <strong>REPEATABLE READ</strong>.</p>
</blockquote>
<h2 id="4-References"><a href="#4-References" class="headerlink" title="4. References"></a>4. References</h2><p><a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_isolation_level">https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_isolation_level</a></p>
<p><a href="http://www.cnblogs.com/xdp-gacl/p/3984001.html">http://www.cnblogs.com/xdp-gacl/p/3984001.html</a></p>
<p><a href="">《数据库系统概论》王珊，萨师煊</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://spground.github.io/2017/12/30/HashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Spground">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spground Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Spground Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/12/30/HashMap/" class="post-title-link" itemprop="url">HashMap工作原理和扩容机制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-12-30 00:00:00" itemprop="dateCreated datePublished" datetime="2017-12-30T00:00:00+08:00">2017-12-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-24 22:30:21" itemprop="dateModified" datetime="2025-09-24T22:30:21+08:00">2025-09-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java%E6%BA%90%E7%A0%81/" itemprop="url" rel="index"><span itemprop="name">Java源码</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-HashMap工作原理"><a href="#1-HashMap工作原理" class="headerlink" title="1. HashMap工作原理"></a>1. HashMap工作原理</h2><p><code>HashMap</code>作为优秀的<code>Java</code>集合框架中的一个重要的成员，在很多编程场景下为我们所用。<code>HashMap</code>作为数据结构散列表的一种实现，就其工作原理来讲单独列出一篇博客来讲都是不过分的。由于本文主要是简单总结其扩容机制，因此对于<code>HashMap</code>的实现原理仅做简单的概述。</p>
<p><code>HashMap</code>内部实现是一个<strong>桶数组</strong>，每个桶中存放着一个<strong>单链表</strong>的头结点。其中每个结点存储的是一个<strong>键值对</strong>整体（<code>Entry</code>），<code>HashMap</code>采用<strong>拉链法</strong>解决<strong>哈希冲突</strong>（关于哈希冲突后面会介绍）。</p>
<p><em>由于<code>Java8</code>对<code>HashMap</code>的某些地方进行了优化，以下的总结和源码分析都是基于<code>Java7</code>。</em></p>
<p>示意图如下：</p>
<p><img src="/images/hashmap.png"></p>
<p><code>HashMap</code>提供两个重要的基本操作，<code>put(K, V)</code>和<code>get(K)</code>。</p>
<ul>
<li>当调用<code>put</code>操作时，<code>HashMap</code>计算键值K的哈希值，然后将其对应到<code>HashMap</code>的某一个桶(<code>bucket</code>)上；此时找到以这个桶为头结点的一个单链表，然后顺序遍历该单链表找到某个节点的<code>Entry</code>中的<code>Key</code>是<strong>等于</strong>给定的参数K；若找到，则将其的<code>old V</code>替换为参数指定的<code>V</code>；否则直接在链表尾部插入一个新的<code>Entry</code>节点。</li>
<li>对于<code>get(K)</code>操作类似于<code>put</code>操作，<code>HashMap</code>通过计算键的哈希值，先找到对应的桶，然后遍历桶存放的单链表通过比照<code>Entry</code>的键来找到对应的值。</li>
</ul>
<p>以上就是<code>HashMap</code>的基本工作原理，但是问题总是比我们看到的要复杂。由于哈希是一种压缩映射，换句话说就是每一个<code>Entry</code>节点无法对应到一个<strong>只属于</strong>自己的桶，那么必然会存在多个<code>Entry</code>共用一个桶，拉成一条链表的情况，这种情况叫做<strong>哈希冲突</strong>。当哈希冲突产生严重的情况，某一个桶后面挂着的链表就会特别长，我们知道<strong>查找</strong>最怕看见的就是顺序查找，那几乎就是无脑查找。</p>
<p><strong>哈希冲突</strong>无法完全避免，因此为了提高<code>HashMap</code>的性能，<code>HashMap</code>不得尽量<strong>缓解</strong>哈希冲突以<strong>缩短</strong>每个桶的外挂链表长度。</p>
<p>频繁产生哈希冲突最重要的原因就像是<strong>要存储的Entry太多，而桶不够</strong>，这和供不应求的矛盾类似。因此，当<code>HashMap</code>中的存储的<code>Entry</code>较多的时候，我们就要考虑<strong>增加桶的数量</strong>，这样对于后续要存储的<code>Entry</code>来讲，就会大大缓解哈希冲突。</p>
<p>因此就涉及到<code>HashMap</code>的扩容，上面算是回答了为什么扩容，那么什么时候扩容？扩容多少？怎么扩容？便是第二部分要总结的了。</p>
<h2 id="2-HashMap扩容"><a href="#2-HashMap扩容" class="headerlink" title="2. HashMap扩容"></a>2. HashMap扩容</h2><h3 id="2-1-HashMap的扩容时机"><a href="#2-1-HashMap的扩容时机" class="headerlink" title="2.1 HashMap的扩容时机"></a>2.1 HashMap的扩容时机</h3><p>在使用<code>HashMap</code>的过程中，我们经常会遇到这样一个带参数的构造方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> ;</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个参数：初始容量，指明初始的桶的个数；相当于桶数组的大小。</li>
<li>第二个参数：装载因子，是一个0-1之间的系数，根据它来确定需要扩容的阈值，默认值是0.75。</li>
</ul>
<p>现在开始通过源码来寻找扩容的时机：</p>
<p><code>put(K, V)</code>操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);<span class="comment">//计算键的hash值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(hash, table.length);<span class="comment">//通过hash值对应到桶位置</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="literal">null</span>; e = e.next) &#123;<span class="comment">//顺序遍历桶外挂的单链表</span></span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;<span class="comment">//注意这里的键的比较方式== 或者 equals()</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(<span class="built_in">this</span>);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        addEntry(hash, key, value, i);<span class="comment">//遍历单链表完毕，没有找到与键相对的Entry，需要新建一个Entry换句话说就是桶i是一个空桶；</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>既然找到一个空桶，那么新建的<code>Entry</code>必然会是这个桶外挂单链表的第一个结点。通过<code>addEntry</code>，找到了扩容的时机。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds a new entry with the specified key, value and hash code to</span></span><br><span class="line"><span class="comment"> * the specified bucket.  It is the responsibility of this</span></span><br><span class="line"><span class="comment"> * method to resize the table if appropriate.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Subclass overrides this to alter the behavior of put method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="literal">null</span> != table[bucketIndex])) &#123;<span class="comment">//当size大于等于某一个阈值thresholdde时候且该桶并不是一个空桶；</span></span><br><span class="line">      <span class="comment">/*这个这样说明比较好理解：因为size 已经大于等于阈值了，说明Entry数量较多，哈希冲突严重，那么若该Entry对应的桶不是一个空桶，这个Entry的加入必然会把原来的链表拉得更长，因此需要扩容；若对应的桶是一个空桶，那么此时没有必要扩容。*/</span></span><br><span class="line">        resize(<span class="number">2</span> * table.length);<span class="comment">//将容量扩容为原来的2倍</span></span><br><span class="line">        hash = (<span class="literal">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);<span class="comment">//扩容后的，该hash值对应的新的桶位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);<span class="comment">//在指定的桶位置上，创建一个新的Entry</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Like addEntry except that this version is used when creating entries</span></span><br><span class="line"><span class="comment"> * as part of Map construction or &quot;pseudo-construction&quot; (cloning,</span></span><br><span class="line"><span class="comment"> * deserialization).  This version needn&#x27;t worry about resizing the table.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Subclass overrides this to alter the behavior of HashMap(Map),</span></span><br><span class="line"><span class="comment"> * clone, and readObject.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(hash, key, value, e);<span class="comment">//链表的头插法插入新建的Entry</span></span><br><span class="line">    size++;<span class="comment">//更新size</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面有几个重要成员变量：</p>
<ul>
<li>size</li>
<li>threshold</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The number of key-value mappings contained in this map.</span></span><br><span class="line"><span class="comment">  */</span>    </span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The next size value at which to resize (capacity * load factor).</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="type">int</span> threshold;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The load factor for the hash table.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br></pre></td></tr></table></figure>

<p>由注释可以知道：</p>
<ul>
<li><p>size记录的是map中包含的Entry的数量</p>
</li>
<li><p>而threshold记录的是需要resize的阈值 且 <code>threshold = loadFactor * capacity</code></p>
</li>
<li><p>capacity 其实就是桶的长度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threshold = (<span class="type">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>因此现在总结出扩容的时机：</p>
<p><strong>当<code>map</code>中包含的<code>Entry</code>的数量大于等于<code>threshold = loadFactor * capacity</code>的时候，且新建的<code>Entry</code>刚好落在一个非空的桶上，此刻触发扩容机制，将其容量扩大为2倍。</strong>（为什么2倍，而不是1.5倍，3倍，10倍；解释见最后的补充）</p>
<p>当<code>size</code>大于等于<code>threshold</code>的时候，并不一定会触发扩容机制，但是会很可能就触发扩容机制，只要有一个新建的<code>Entry</code>出现哈希冲突，则立刻<code>resize</code>。</p>
<p>  直到这里我们回答了什么时候扩容和扩容多少的问题，那么下面回答如何扩容的问题。</p>
<h3 id="2-2-HashMap的扩容过程"><a href="#2-2-HashMap的扩容过程" class="headerlink" title="2.2 HashMap的扩容过程"></a>2.2 HashMap的扩容过程</h3><p>上面有一个很重要的方法，包含了几乎属于的扩容过程，这就是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resize()</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Rehashes the contents of this map into a new array with a</span></span><br><span class="line"><span class="comment"> * larger capacity.  This method is called automatically when the</span></span><br><span class="line"><span class="comment"> * number of keys in this map reaches its threshold.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If current capacity is MAXIMUM_CAPACITY, this method does not</span></span><br><span class="line"><span class="comment"> * resize the map, but sets threshold to Integer.MAX_VALUE.</span></span><br><span class="line"><span class="comment"> * This has the effect of preventing future calls.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newCapacity the new capacity, MUST be a power of two;</span></span><br><span class="line"><span class="comment"> *        must be greater than current capacity unless current</span></span><br><span class="line"><span class="comment"> *        capacity is MAXIMUM_CAPACITY (in which case value</span></span><br><span class="line"><span class="comment"> *        is irrelevant).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> newCapacity)</span> &#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;<span class="comment">//最大容量为 1 &lt;&lt; 30</span></span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> <span class="title class_">Entry</span>[newCapacity];<span class="comment">//新建一个新表</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">oldAltHashing</span> <span class="operator">=</span> useAltHashing;</span><br><span class="line">    useAltHashing |= sun.misc.VM.isBooted() &amp;&amp;</span><br><span class="line">            (newCapacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">rehash</span> <span class="operator">=</span> oldAltHashing ^ useAltHashing;<span class="comment">//是否再hash</span></span><br><span class="line">    transfer(newTable, rehash);<span class="comment">//完成旧表到新表的转移</span></span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="type">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Transfers all entries from current table to newTable.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable, <span class="type">boolean</span> rehash)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;<span class="comment">//遍历同桶数组中的每一个桶</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">null</span> != e) &#123;<span class="comment">//顺序遍历某个桶的外挂链表</span></span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;<span class="comment">//引用next</span></span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="literal">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity);<span class="comment">//找到新表的桶位置;原桶数组中的某个桶上的同一链表中的Entry此刻可能被分散到不同的桶中去了，有效的缓解了哈希冲突。</span></span><br><span class="line">            e.next = newTable[i];<span class="comment">//头插法插入新表中</span></span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于<code>resize</code>的过程，相对来讲是比较简单清晰易于理解的。<strong>旧桶数组中的某个桶的外挂单链表是通过头插法插入新桶数组中的，并且原链表中的Entry结点并不一定仍然在新桶数组的同一链表</strong>。</p>
<p>示意图如下：</p>
<p><img src="http://tech.meituan.com/img/java-hashmap/jdk1.8%20hashMap%E6%89%A9%E5%AE%B9%E4%BE%8B%E5%9B%BE.png"></p>
<p>这里很容易就想到多线程情况下，隐约感觉这个<code>transfer</code>方法在多线程环境下会乱套。事实上也是这样的，由于<strong>缺乏同步机制</strong>，当多个线程同时<code>resize</code>的时候，某个线程<code>t</code>所持有的引用<code>next</code>（参考上面代码<code>next</code>指向原桶数组中某个桶外挂单链表的下一个需要转移的<code>Entry</code>），可能已经被转移到了新桶数组中，那么最后该线程<code>t</code>实际上在对新的桶数组进行<code>transfer</code>操作。</p>
<p>如果有更多的线程出现这种情况，那很可能出现大量线程都在对<strong>新桶数组</strong>进行<code>transfer</code>，那么就会出现多个线程对同一链表<strong>无限进行链表反转</strong>的操作，极易造成死循环，数据丢失等等，因此<code>HashMap</code>不是线程安全的，考虑在多线程环境下使用并发工具包下的<code>ConcurrentHashMap</code>。</p>
<h2 id="3-补充"><a href="#3-补充" class="headerlink" title="3. 补充"></a>3. 补充</h2><h3 id="3-1-容量必须是2的幂"><a href="#3-1-容量必须是2的幂" class="headerlink" title="3.1 容量必须是2的幂"></a>3.1 容量必须是2的幂</h3><p>在<code>resize()</code>，为什么容量需要时2倍这样扩张，而不是1.5倍，3倍，10倍，另外在<code>HashMap</code>中有如下的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The default initial capacity - MUST be a power of two.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find a power of 2 &gt;= initialCapacity 找到一个大于等于初始容量的且是2的幂的数作为实际容量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (capacity &lt; initialCapacity)</span><br><span class="line">            capacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">        threshold = (<span class="type">int</span>)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">        table = <span class="keyword">new</span> <span class="title class_">Entry</span>[capacity];</span><br><span class="line">        useAltHashing = sun.misc.VM.isBooted() &amp;&amp;</span><br><span class="line">                (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>通过以上我们知道<code>HashMap</code>的容量必须是2的幂，那么为什么要这么设计呢？答案当然是为了性能。在<code>HashMap</code>通过键的哈希值进行定位桶位置的时候，调用了一个<code>indexFor(hash, table.length);</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns index for hash code h.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">indexFor</span><span class="params">(<span class="type">int</span> h, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里是将哈希值<code>h</code>与桶数组的<code>length-1</code>（实际上也是<code>map</code>的容量-1）进行了一个与操作得出了对应的桶的位置，<code>h &amp; (length-1)</code>。</p>
<p>但是为什么不采用<code>h % length</code>这种计算方式呢？</p>
<p><a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=4631373">https://bugs.java.com/bugdatabase/view_bug.do?bug_id&#x3D;4631373</a>中提出<code>Java</code>的<code>%</code>、<code>/</code>操作比<code>&amp;</code>慢10倍左右，因此采用<code>&amp;</code>运算会提高性能。</p>
<p>**通过限制<code>length</code>是一个<code>2的幂</code>数，<code>h &amp; (length-1)</code>和<code>h % length</code>结果是一致的。**这就是为什么要限制容量必须是一个<code>2</code>的幂的原因。</p>
<p>举个简单的例子说明这两个操作的结果一致性：</p>
<p>假设有个<code>hashcode</code>是311，对应的二进制是(1 0011 0111)</p>
<p><code>length</code>为16，对应的二进制位(1 0000)</p>
<ul>
<li><p><code>%</code>操作：311 &#x3D; 16*19 + 7；所以结果为7，二进制位(0111)；</p>
</li>
<li><p><code>&amp;</code>操作：(1 0011 0111) &amp; (0111) &#x3D; 0111 &#x3D; 7, 二进制位(0111)</p>
<p> 1 0011 0111 &#x3D; (1 0011 0000) + (0111) &#x3D; (1*2^4 + 1* 2^5 + 0*2^6 + 0*2^7 + 1*2^8 ) + 7 &#x3D; <strong>2^4</strong>*(1 + 2 + 0 + 0 + 16) + 7 &#x3D; <strong>16</strong> * 19 + 7; 和<code>%</code>操作一致。</p>
<p>如果<code>length</code>是一个2的幂的数，那么<code>length-1</code>就会变成一个<code>mask</code>, 它会将<code>hashcode</code>低位取出来，<code>hashcode</code>的<strong>低位实际就是余数</strong>，和取余操作相比，与操作会将性能提升很多。</p>
</li>
</ul>
<h3 id="3-2-rehash"><a href="#3-2-rehash" class="headerlink" title="3.2 rehash"></a>3.2 rehash</h3><p>通过上面的分析可以看出，不同的键的的<code>hashcode</code>仅仅只能通过<strong>低位</strong>来区分。<strong>高位的信息</strong>没有被充分利用，举个例子：</p>
<p>假设容量为为<code>16</code>，  二进制位(<code>10000</code>)。</p>
<p><code>key1</code>的<code>hashcode</code>为<code>11111 10101</code>，另一个<code>key2</code>的<code>hashcode</code>为<code>00000 10101</code>，很明显这两个<code>hashcode</code>不是一样的，甚至连相似性（例如海明距离）也是很远的。但是直接进行<code>&amp;</code>操作得出的桶位置是同一个桶，这直接就产生了<strong>哈希冲突</strong>。</p>
<p>由于键的<code>hashCode</code>是<code>HashMap</code>的使用者来设计的，主要也就是我们这群程序员，由于设计一个良好的<code>hashcode</code>分布，是比较困难的，因此会容易出现分布质量差的<code>hashcode</code>分布，<strong>极端情况就是：所有的<code>hashCode</code>低位全相等，而高位不相等</strong>，这大大加大了哈希冲突，降低了<code>HashMap</code>的性能。</p>
<p>为了防止这种情况的出现，<code>HashMap</code>它使用一个<strong>supplemental hash function</strong>对键的<code>hashCode</code>再进行了一个<strong>supplemental hash</strong> ，将最终的<code>hash</code>值作为键的<code>hash</code>值来进行桶的位置映射（也就是说<code>JDK</code>团队在为我们这群程序员加性能保险<code>Orz</code>）。这个过程叫做再哈希(<code>rehash</code>)。</p>
<p>经过一个<strong>supplemental hash</strong>过程后，能保证<strong>海明距离为常数</strong>的不同的<code>hashcode</code>有一个<strong>哈希冲突次数上界</strong>（装载因子为0.75的时候，大约是8次）。</p>
<p>参见下段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Retrieve object hash code and applies a supplemental hash function to the</span></span><br><span class="line"><span class="comment">    * result hash, which defends against poor quality hash functions.  This is</span></span><br><span class="line"><span class="comment">    * critical because HashMap uses power-of-two length hash tables, that</span></span><br><span class="line"><span class="comment">    * otherwise encounter collisions for hashCodes that do not differ</span></span><br><span class="line"><span class="comment">    * in lower bits. Note: Null keys always map to hash 0, thus index 0.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object k)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span> (useAltHashing) &#123;</span><br><span class="line">           <span class="keyword">if</span> (k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">               <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">           &#125;</span><br><span class="line">           h = hashSeed;</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       h ^= k.hashCode();</span><br><span class="line">   </span><br><span class="line">       <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">       <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">       <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line">       h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">       <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-References"><a href="#4-References" class="headerlink" title="4 References"></a>4 References</h2><ol>
<li><a href="http://www.javarticles.com/2012/11/hashmap-faq.html">http://www.javarticles.com/2012/11/hashmap-faq.html</a></li>
<li><a href="http://blog.csdn.net/u014532901/article/details/78573740">http://blog.csdn.net/u014532901/article/details/78573740</a></li>
<li><a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=4631373">https://bugs.java.com/bugdatabase/view_bug.do?bug_id&#x3D;4631373</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://spground.github.io/2017/12/16/Java%20Array%20to%20Collection%20and%20Vise%20Verse/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Spground">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spground Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Spground Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/12/16/Java%20Array%20to%20Collection%20and%20Vise%20Verse/" class="post-title-link" itemprop="url">Java Array、List、Set互相转化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-12-16 00:00:00" itemprop="dateCreated datePublished" datetime="2017-12-16T00:00:00+08:00">2017-12-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-24 22:30:21" itemprop="dateModified" datetime="2025-09-24T22:30:21+08:00">2025-09-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Java-Array、List、Set互相转化"><a href="#Java-Array、List、Set互相转化" class="headerlink" title="Java Array、List、Set互相转化"></a>Java Array、List、Set互相转化</h2><h3 id="1-Array、List、Set互转实例"><a href="#1-Array、List、Set互转实例" class="headerlink" title="1. Array、List、Set互转实例"></a>1. Array、List、Set互转实例</h3><h4 id="1-1-Array、List互转"><a href="#1-1-Array、List互转" class="headerlink" title="1.1 Array、List互转"></a>1.1 Array、List互转</h4><ul>
<li><p><code>Array</code>转<code>List</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] s = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>,<span class="string">&quot;E&quot;</span>&#125;;</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(s);</span><br></pre></td></tr></table></figure>

<p>注意这里<code>list</code>里面的元素直接是<code>s</code>里面的元素( list backed by the specified array)，换句话就是说：<strong>对<code>s</code>的修改，直接影响<code>list</code>。</strong></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s[<span class="number">0</span>] =<span class="string">&quot;AA&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;list: &quot;</span> + list);</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list: [AA, B, C, D, E]</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>List</code>转<code>Array</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] dest = list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);<span class="comment">//new String[0]是指定返回数组的类型</span></span><br><span class="line">System.out.println(<span class="string">&quot;dest: &quot;</span> + Arrays.toString(dest));</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dest: [AA, B, C, D, E]</span><br></pre></td></tr></table></figure>

<p>注意这里的<code>dest</code>里面的元素不是<code>list</code>里面的元素，换句话就是说：<strong>对<code>list</code>中关于元素的修改，不会影响<code>dest</code></strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list.set(<span class="number">0</span>, <span class="string">&quot;Z&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;modified list: &quot;</span> + list);</span><br><span class="line">System.out.println(<span class="string">&quot;dest: &quot;</span> + Arrays.toString(dest));</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">modified list: [Z, B, C, D, E]</span><br><span class="line">dest: [AA, B, C, D, E]</span><br></pre></td></tr></table></figure>

<p>可以看到<code>list</code>虽然被修改了，但是<code>dest</code>数组没有没修改。</p>
</li>
</ul>
<h4 id="1-2-List、Set互转"><a href="#1-2-List、Set互转" class="headerlink" title="1.2 List、Set互转"></a>1.2 List、Set互转</h4><p>因为<code>List</code>和<code>Set</code>都实现了<code>Collection</code>接口，且<code>addAll(Collection&lt;? extends E&gt; c);</code>方法，因此可以采用<code>addAll()</code>方法将<code>List</code>和<code>Set</code>互相转换；另外，<code>List</code>和<code>Set</code>也提供了<code>Collection&lt;? extends E&gt; c</code>作为参数的构造函数，因此通常采用构造函数的形式完成互相转化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//List转Set</span></span><br><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(list);</span><br><span class="line">System.out.println(<span class="string">&quot;set: &quot;</span> + set);</span><br><span class="line"><span class="comment">//Set转List</span></span><br><span class="line">List&lt;String&gt; list_1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(set);</span><br><span class="line">System.out.println(<span class="string">&quot;list_1: &quot;</span> + list_1);</span><br></pre></td></tr></table></figure>

<p>和<code>toArray()</code>一样，被转换的<code>List</code>(<code>Set</code>)的修改不会对被转化后的<code>Set</code>（<code>List</code>）造成影响。</p>
<h4 id="1-3-Array、Set互转"><a href="#1-3-Array、Set互转" class="headerlink" title="1.3 Array、Set互转"></a>1.3 Array、Set互转</h4><p>由<code>1.1</code> <code> 1.2</code>可完成Array和Set的互转</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//array转set</span></span><br><span class="line">s = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>,<span class="string">&quot;E&quot;</span>&#125;;</span><br><span class="line">set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(Arrays.asList(s));</span><br><span class="line">System.out.println(<span class="string">&quot;set: &quot;</span> + set);</span><br><span class="line"><span class="comment">//set转array</span></span><br><span class="line">dest = set.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);</span><br><span class="line">System.out.println(<span class="string">&quot;dest: &quot;</span> + Arrays.toString(dest));</span><br></pre></td></tr></table></figure>
<p>  ​</p>
<h3 id="2-Arrays-asList-和-Collection-toArray"><a href="#2-Arrays-asList-和-Collection-toArray" class="headerlink" title="2. Arrays.asList() 和 Collection.toArray()"></a>2.<code> Arrays.asList()</code> 和 <code>Collection.toArray()</code></h3><p>上述列出的互相转换离不开<code>Arrays.asList()</code>和<code>Collection.toArray()</code>两个重要的方法；</p>
<blockquote>
<p> This method acts as bridge between array-based and collection-based APIs, in combination with <code>Collection.toArray</code>.  The returned list is serializable and implements <code>RandomAccess</code>. </p>
</blockquote>
<ul>
<li><p><code>Arrays.asList()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SafeVarargs</span></span><br><span class="line">   <span class="meta">@SuppressWarnings(&quot;varargs&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">asList</span><span class="params">(T... a)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(a);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这里出现的<code>ArrayList&lt;&gt;</code>并不是我们通常使用的<code>java.util.ArrayList</code>，因为<code>java.util.ArrayList</code>没有数组作为参数的构造函数。查看对应的源码发现，其实<code>Arrays</code>类的静态内部类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@serial</span> include</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">     <span class="keyword">implements</span> <span class="title class_">RandomAccess</span>, java.io.Serializable</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">2764017481108945198L</span>;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> E[] a;</span><br><span class="line"></span><br><span class="line">     ArrayList(E[] array) &#123;</span><br><span class="line">         a = Objects.requireNonNull(array);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> a.length;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">         <span class="keyword">return</span> a.clone();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">     <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">         <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> size();</span><br><span class="line">         <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">             <span class="keyword">return</span> Arrays.copyOf(<span class="built_in">this</span>.a, size,</span><br><span class="line">                                  (Class&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>[]&gt;) a.getClass());</span><br><span class="line">         System.arraycopy(<span class="built_in">this</span>.a, <span class="number">0</span>, a, <span class="number">0</span>, size);</span><br><span class="line">         <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">             a[size] = <span class="literal">null</span>;</span><br><span class="line">         <span class="keyword">return</span> a;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> a[index];</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">         <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> a[index];</span><br><span class="line">         a[index] = element;</span><br><span class="line">         <span class="keyword">return</span> oldValue;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">         E[] a = <span class="built_in">this</span>.a;</span><br><span class="line">         <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">             <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++)</span><br><span class="line">                 <span class="keyword">if</span> (a[i] == <span class="literal">null</span>)</span><br><span class="line">                     <span class="keyword">return</span> i;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++)</span><br><span class="line">                 <span class="keyword">if</span> (o.equals(a[i]))</span><br><span class="line">                     <span class="keyword">return</span> i;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> indexOf(o) != -<span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> Spliterator&lt;E&gt; <span class="title function_">spliterator</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> Spliterators.spliterator(a, Spliterator.ORDERED);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> E&gt; action)</span> &#123;</span><br><span class="line">         Objects.requireNonNull(action);</span><br><span class="line">         <span class="keyword">for</span> (E e : a) &#123;</span><br><span class="line">             action.accept(e);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">replaceAll</span><span class="params">(UnaryOperator&lt;E&gt; operator)</span> &#123;</span><br><span class="line">         Objects.requireNonNull(operator);</span><br><span class="line">         E[] a = <span class="built_in">this</span>.a;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">             a[i] = operator.apply(a[i]);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> E&gt; c)</span> &#123;</span><br><span class="line">         Arrays.sort(a, c);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


<p> 可以看到，这个由<code>Arrays</code>类实现的另一个<code>Arrays$ArrayList</code>，对于<code>java.util.ArrayList</code>类来讲，是比较简单粗糙的类。</p>
<ul>
<li><p>没有扩容机制；</p>
</li>
<li><p>无法在指定位置<code>add(int index, E element)</code>，调用该方法会抛异常；</p>
<p>  这些不同让这个<code>ArrayList</code>看起来实际上就是一个**<code>List-View</code>的数组**。</p>
</li>
</ul>
</li>
<li><p><code>Collection.toArray()</code></p>
</li>
</ul>
<p>虽然<code>List</code>、<code>Set</code>的具体实现类都对<code>Collection.toArray()</code>方法进行了不同程度的重写，但是大致都差不多。</p>
<p>这里选<code>AbstractCollection.toArray()</code>的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">        <span class="comment">// Estimate size of array; be prepared to see more or fewer elements</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> size();</span><br><span class="line">        T[] r = a.length &gt;= size ? a :</span><br><span class="line">                  (T[])java.lang.reflect.Array</span><br><span class="line">                  .newInstance(a.getClass().getComponentType(), size);<span class="comment">//如果给定的参数T[] a的长度足够存放当前collection(list or set)的元素，则采用该参数来存放元素；否则则根据参数给定的类型反射生成一个数组；</span></span><br><span class="line">  <span class="comment">//因此这里的参数T[] a有俩作用；第一：可能用作存放元素；第二：为返回数组提供类型</span></span><br><span class="line">        Iterator&lt;E&gt; it = iterator();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; r.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (! it.hasNext()) &#123; <span class="comment">// fewer elements than expected 集合的size少于给定的参数数组的长度</span></span><br><span class="line">                <span class="keyword">if</span> (a == r) &#123;</span><br><span class="line">                    r[i] = <span class="literal">null</span>; <span class="comment">// null-terminate 最后一个元素被设置为null，表明collection元素结束；</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a.length &lt; i) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Arrays.copyOf(r, i);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.arraycopy(r, <span class="number">0</span>, a, <span class="number">0</span>, i);</span><br><span class="line">                    <span class="keyword">if</span> (a.length &gt; i) &#123;</span><br><span class="line">                        a[i] = <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> a;</span><br><span class="line">            &#125;</span><br><span class="line">            r[i] = (T)it.next();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// more elements than expected</span></span><br><span class="line">        <span class="keyword">return</span> it.hasNext() ? finishToArray(r, it) : r;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Spground</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
