<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"spground.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Spground Blog">
<meta property="og:url" content="https://spground.github.io/page/4/index.html">
<meta property="og:site_name" content="Spground Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Spground">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://spground.github.io/page/4/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/4/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Spground Blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Spground Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">77</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">11</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">41</span></a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Spground</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">41</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">77</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://spground.github.io/2016/12/31/NO_DELAY%20option%20in%20TCP%20protocal/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Spground">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spground Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Spground Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2016/12/31/NO_DELAY%20option%20in%20TCP%20protocal/" class="post-title-link" itemprop="url">TCP中的NO_DELAY</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2016-12-31 00:00:00" itemprop="dateCreated datePublished" datetime="2016-12-31T00:00:00+08:00">2016-12-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-24 22:30:21" itemprop="dateModified" datetime="2025-09-24T22:30:21+08:00">2025-09-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-TCP网络优化的两种机制"><a href="#1-TCP网络优化的两种机制" class="headerlink" title="1. TCP网络优化的两种机制"></a>1. TCP网络优化的两种机制</h2><blockquote>
<p>TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、全双工、基于字节流的传输层通信协议，由IETF的RFC 793定义。</p>
</blockquote>
<p>TCP协议是网络编程中最重要的协议之一，TCP协议将上层的数据附上TCP报头等信息，封装成一个个报文段（<code>segment</code>），然后交由下层网络层去处理。TCP协议定义了TCP报文段的结构，如下图所示：</p>
<p><img src="http://img.blog.csdn.net/20171119111209901?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDUzMjkwMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>可以看出，TCP每个报文段的首部大小至少是20字节的数据，因此若用户数据为1字节，再加上网络层IP包头20字节，则整个IP数据包的大小为41字节，那么整个IP数据包的负荷率为<code>1 / 41</code>。这显然是不划算的，会降低网络的传输效率，当网络都充斥着这种IP数据包的时候，可想而知整个网络几乎都在传输一些无用的包头信息，这种问题被称为<strong>小包问题</strong>。特别是在Telnet协议中，当用户远程登录到一个主机，他的每一次键盘敲击实际上都会产生一个携带用户数据量小的数据包，这是典型的<strong>小包问题</strong>。</p>
<p>为了解决这种问题，出现了**<a href="https://en.wikipedia.org/wiki/Nagle's_algorithm"><code>Nagle&#39;s Algorithms</code></a>**，这个算法是<code> John Nagle</code>为解决实际过程中出现的小包问题而发明的。它的思想很朴素，就是将多个即将发送的小段的用户数据，缓存并合并成一个大段数据时，一次性一并发送出去。特别的是，只要当发送者还没有收到前一次发送TCP报文段的的ACK（即连接中还存在未回执ACK的TCP报文段）时，发送方就应该一直缓存数据直到数据达到可以发送的大小，然后再统一合并到一起发送出去，如果收到上一次发送的TCP报文段的ACK则立马将缓存的数据发送出去。</p>
<p>以下是<code>Nigle</code>算法的伪代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if there is new data to send</span><br><span class="line">  if the window size &gt;= MSS and available data is &gt;= MSS</span><br><span class="line">    send complete MSS segment now</span><br><span class="line">  else</span><br><span class="line">    if there is unconfirmed data still in the pipe</span><br><span class="line">      enqueue data in the buffer until an acknowledge is received</span><br><span class="line">    else</span><br><span class="line">      send data immediately</span><br><span class="line">    end if</span><br><span class="line">  end if</span><br><span class="line">end if</span><br></pre></td></tr></table></figure>
<p>MSS &#x3D; maximum segment size</p>
<p>与之相呼应的还有一个网络优化的机制叫做<a href="https://en.wikipedia.org/wiki/TCP_delayed_acknowledgment"><strong>TCP延迟确认</strong></a>，这个是针对接收方来讲的机制，由于ACK包属于有效数据比较少的小包，因此<strong>延迟确认机制</strong>就会导致接收方将多个收到数据包的ACK打包成一个回复包返回给发送方。这样就可以避免导致只包含ACK的TCP报文段过多导致网络额外的开销（前面提到的小包问题）。<strong>延迟确认机制</strong>有一个超时机制，就是当收到每一个TCP报文段后，如果该TCP报文段的ACK超过一定时间还未发送就启动超时机制，立刻将该ACK发送出去。因此<strong>延迟确认机制</strong>会可能会带来500ms的ACK延迟确认时间。</p>
<p><strong>延迟确认机制</strong>和<strong>Nigle算法</strong>几乎是在同一时期提出来的，但是是由不同的组提出的。这两种机制在某种程度上的确对网络传输进行了优化，在通常的协议栈实现中，这两种机制是默认开启的。</p>
<p>但是，这两种机制结合起来的时候会产生一些负面的影响，可能会导致应用程序的性能下降。</p>
<h2 id="2-write-write-read模式带来的问题"><a href="#2-write-write-read模式带来的问题" class="headerlink" title="2. write-write-read模式带来的问题"></a>2. write-write-read模式带来的问题</h2><p>考虑这么一种情况，</p>
<p>1.假设发送方A启用了<strong>Nigle算法</strong>，接收方B启用了<strong>延迟确认机制</strong>，则当发送方A向TCP连接进行了两次write操作，每次write操作都之写入了少量的数据(少于MSS),假设写入的数据片段为w1,w2，然后紧接着调用了阻塞式的read操作。</p>
<p>2.因为连接中没有未收到ACK的TCP报文段，发送方A的第一次写入的w1会立马发送出去；</p>
<p>3.则在接收方来B来看，它会首先收到包含w1数据段的TCP报文段，但是由于<strong>延迟确认机制</strong>，接收方B会延迟发送该TCP报文段的ACK直到超时。</p>
<p>4.而对于发送方A来说，根据<strong>Nigle算法</strong>，由于连接中上一个TCP报文段未收到ACK，并且第二次写入的w2数据段过于小(小于MSS)，则发送方A会将w2入队列缓存起来，不会立即发送。</p>
<p>5.然而不幸的是，发送方A此时并不继续发送数据，因此依靠发送方A将缓存填满来把w2数据段发送出是不可能的了，现在只能傻傻的等待接收方B因为超时而返回w1的ACK了。</p>
<p>6.这样当接收方B因为超时而返回ACK后，发送方A就会立即发送包含w2数据段的TCP报文段。</p>
<p>自此，w1、w2数据段才被完整的发送给接收方B，如果忽略传输时间等其他因素，这额外增加的数据传输延迟就是接收方B启用的<strong>延迟确认机制</strong>中的超时的值。<br>因此当<strong>延迟确认机制</strong>和<strong>Nigle算法</strong>都启用的时候，正好碰上了这种write-write-read模式的数据传输，就会出现这种问题，因此wiki上就有这些建议：</p>
<blockquote>
<p>The user-level solution is to avoid write-write-read sequences on sockets. write-read-write-read is fine. write-write-write is fine. But write-write-read is a killer. So, if you can, buffer up your little writes to TCP and send them all at once. Using the standard UNIX I&#x2F;O package and flushing write before each read usually works.</p>
</blockquote>
<p><strong>Nigle算法</strong>在一次性写入比较大的数据段时会出现延迟的现象，特别是对于<code>Request-Response</code>模式的程序来讲，通常一个请求的数据会大于<code>MMS</code>，这样一个请求就会跨越多个TCP报文段,因此<strong>Nigle算法</strong>会导致最后一个TCP报文段被<code>Hold</code>住，出现延时；同样的一个回复的数据也会大于<code>MMS</code>，因此也会出现这种延时。</p>
<p><strong>Nigle算法</strong>通常是用来防止那些写得不太好的程序，防止这些程序随意的发小包降低网络传输效率；而对于一些精心编写的程序，<strong>Nigle算法</strong>几乎没什么用，应用程序编写者应该合理的把握、判断好每次写入的数据的大小，进而采取适当的策略进行发送，要么将小包合并到<code>MMS</code>大小，然后一次性写入并发送；要么禁用<strong>Nigle算法</strong>。</p>
<p>当然以上只是一种解决方案，通常的协议栈会预留接口来禁用<strong>Nigle算法</strong>，即设置<strong>TCP_NODELAY</strong>选项。</p>
<h2 id="3-TCP-NO-DELAY选项"><a href="#3-TCP-NO-DELAY选项" class="headerlink" title="3. TCP NO_DELAY选项"></a>3. TCP NO_DELAY选项</h2><p>Socket编程模型会有一个预留接口来禁用<strong>Nigle算法</strong>，这个接口就是<strong>TCP NODELAY</strong>。<br>这是网上的用Java写的一个关于是否启用<strong>TCP NODELAY</strong>的<a href="http://babyhe.blog.51cto.com/1104064/1393725?utm_source=tuicool&utm_medium=referral">实验</a></p>
<p>需要说明的是这个实验在同一台windows上是不成功的，在windows上的loopback地址的处理可能和Linux不太一样。在windows下实验，开启TCP NODELAY与否都不会出现延迟的情况。奇怪的是我选一台windows做Client，一台Max机器做Server，实验仍然失败，不知道Windows对于Nagle算法是否是否是默认的开启。但是我选windows机器做Server，Mac机器做Client，实验结果显而易见。</p>
<p><strong>Server端代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="type">ServerSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9989</span>);</span><br><span class="line">			System.out.println(<span class="string">&quot;绑定端口&quot;</span>);</span><br><span class="line">			<span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">				<span class="type">Socket</span> <span class="variable">con</span>  <span class="operator">=</span> socket.accept();</span><br><span class="line">				<span class="keyword">new</span> <span class="title class_">Thread</span>(	<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">					</span><br><span class="line">					<span class="meta">@Override</span></span><br><span class="line">					<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">						<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> con.getInputStream();</span><br><span class="line">							<span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> con.getOutputStream();</span><br><span class="line">							<span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(in));</span><br><span class="line">							<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">								<span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> reader.readLine();</span><br><span class="line">								<span class="keyword">if</span>(!con.isClosed())</span><br><span class="line">									out.write((line + <span class="string">&quot;\r\n&quot;</span>).getBytes());</span><br><span class="line">							&#125;</span><br><span class="line">						&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">							<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">							e.printStackTrace();</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;).start();</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Client端</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;192.168.31.235&quot;</span>, <span class="number">9989</span>);</span><br><span class="line">			s.setTcpNoDelay(<span class="literal">true</span>);</span><br><span class="line">			<span class="type">OutputStream</span> <span class="variable">ops</span> <span class="operator">=</span> s.getOutputStream();</span><br><span class="line">			<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> s.getInputStream();</span><br><span class="line">			<span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(in)); </span><br><span class="line">			</span><br><span class="line">			<span class="comment">// write-write-read</span></span><br><span class="line">			<span class="type">String</span> <span class="variable">head</span> <span class="operator">=</span> <span class="string">&quot;h&quot;</span>;</span><br><span class="line">			<span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> <span class="string">&quot;w\r\n&quot;</span>;</span><br><span class="line">			</span><br><span class="line">			<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">while</span> ( i-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="type">long</span> <span class="variable">label</span> <span class="operator">=</span> System.currentTimeMillis(); </span><br><span class="line">				ops.write(head.getBytes());</span><br><span class="line">				ops.write(body.getBytes());<span class="comment">// 会有延迟吧应该，有可能不会阻塞</span></span><br><span class="line">				<span class="type">InputStream</span> <span class="variable">ips</span> <span class="operator">=</span> s.getInputStream();</span><br><span class="line">				<span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> reader.readLine();  </span><br><span class="line">				System.out.println(<span class="string">&quot;RTT:&quot;</span> + (System.currentTimeMillis() - label) + <span class="string">&quot;, receive: &quot;</span> + line);</span><br><span class="line">			&#125;</span><br><span class="line">			s.close();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中Server代码跑在Windows上，Client代码跑在Mac上</p>
<ul>
<li>未开启TCP NODELAY,write-write-read模式</li>
</ul>
<p><img src="http://img.blog.csdn.net/20171119110953218?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDUzMjkwMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<ul>
<li>开启TCP NODELAY,write-write-read模式</li>
</ul>
<p><img src="http://img.blog.csdn.net/20171119111012746?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDUzMjkwMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<ul>
<li>未开启TCP NODELAY, write-read模式</li>
</ul>
<p><img src="http://img.blog.csdn.net/20171119111023881?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDUzMjkwMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<ul>
<li>开启TCP NODELAY, write-read模式</li>
</ul>
<p><img src="http://img.blog.csdn.net/20171119111034119?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDUzMjkwMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>可以明显的看出，当采用write-write-read模式，且未开启<strong>TCP NODELAY</strong>选项时（未禁用<strong>Nagle算法</strong>）时，延迟产生了，大约<strong>200ms</strong>。</p>
<h2 id="4-TCP-CORK选项"><a href="#4-TCP-CORK选项" class="headerlink" title="4. TCP CORK选项"></a>4. TCP CORK选项</h2><p><strong>TCP CORK</strong></p>
<p>TCP_CORK是另一种关于TCP的选项，他与TCP——NODELAY的详细区别此处不做介绍，相关资料见：</p>
<p><a href="https://linux.die.net/man/7/tcp">https://linux.die.net/man/7/tcp</a><br/><br><a href="http://baus.net/on-tcp_cork">http://baus.net/on-tcp_cork</a><br/><br><a href="http://stackoverflow.com/questions/22124098/is-there-any-significant-difference-between-tcp-cork-and-tcp-nodelay-in-this-use">http://stackoverflow.com/questions/22124098/is-there-any-significant-difference-between-tcp-cork-and-tcp-nodelay-in-this-use</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://spground.github.io/2016/12/15/Some%20usecaes%20of%20bit%20operation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Spground">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spground Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Spground Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2016/12/15/Some%20usecaes%20of%20bit%20operation/" class="post-title-link" itemprop="url">位运算的一些用例</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2016-12-15 00:00:00" itemprop="dateCreated datePublished" datetime="2016-12-15T00:00:00+08:00">2016-12-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-24 22:30:21" itemprop="dateModified" datetime="2025-09-24T22:30:21+08:00">2025-09-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">编程基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>几乎每种编程语言都为我们提供一种运算，它直接操作二进制数据，这种运算叫做<strong>位运算</strong>。</p>
<p>位运算分为移位、取反、与、或、异或、非，其中移位又包括左移位、右移位、左无符号移位、右无符号移位。</p>
<table>
<thead>
<tr>
<th>含义</th>
<th>Java写法</th>
</tr>
</thead>
<tbody><tr>
<td>与</td>
<td>a &amp; b</td>
</tr>
<tr>
<td>或</td>
<td>a | b</td>
</tr>
<tr>
<td>异或</td>
<td>a ^ b</td>
</tr>
<tr>
<td>非（取反）</td>
<td>~a</td>
</tr>
<tr>
<td>左移</td>
<td>a&lt;&lt;b</td>
</tr>
<tr>
<td>右移</td>
<td>a&gt;&gt;b</td>
</tr>
<tr>
<td>无符号左移</td>
<td>a &lt;&lt;&lt; b</td>
</tr>
<tr>
<td>无符号右移</td>
<td>a&gt;&gt;&gt;b</td>
</tr>
</tbody></table>
<p>可能大多数时候觉得，这些位运算除了平时刷题用到，好像并没有什么用。当时当我们去看一些源代码的时候，比如JDK、Android SDK等源代码的时候，我们会发现有很多地方都会看见一些位运算的影子。这些使用位运算的例子都会有某个命令为mask的变量，这个mask就是用来存储某几种状态的信息。</p>
<p>那么什么是位掩码呢？根据维基百科的定义：</p>
<blockquote>
<p>In computer science, a mask is data that is used for bitwise operations, particularly in a bit field.</p>
</blockquote>
<p>位掩码是一种用来方便进行位运算的数据，可以帮助我们在读取或者修改某个特定的位上的值，而不会修改其他位的值。</p>
<h2 id="位运算的用例一—权限控制"><a href="#位运算的用例一—权限控制" class="headerlink" title="位运算的用例一—权限控制"></a>位运算的用例一—权限控制</h2><p>假设有这么一个场景，需要对某个文件设置权限，假设有三种权限需要设置：读、写、执行。那么通常的做法可能就是采用三个布尔值来存储当前的权限。<br>那么写法通常可能是这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Permission</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">is_allowed_read</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">is_allowed_write</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">is_allowed_execution</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Permission</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Permission</span><span class="params">(<span class="type">boolean</span> is_allowed_read, <span class="type">boolean</span> is_allowed_write, <span class="type">boolean</span> is_allowed_execution)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.is_allowed_read = is_allowed_read;</span><br><span class="line">        <span class="built_in">this</span>.is_allowed_write = is_allowed_write;</span><br><span class="line">        <span class="built_in">this</span>.is_allowed_execution = is_allowed_execution;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setIsAllowedRead</span><span class="params">(<span class="type">boolean</span> is_allowed_read)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.is_allowed_read = is_allowed_read;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">getIsAllowedRead</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.is_allowed_read;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setIsAllowedWrite</span><span class="params">(<span class="type">boolean</span> is_allowed_write)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.is_allowed_write = is_allowed_write;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">getIsAllowedWrite</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.is_allowed_write;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setIsAllowedExecution</span><span class="params">(<span class="type">boolean</span> is_allowed_execution)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.is_allowed_execution = is_allowed_execution;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">getIsAllowedExecution</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.is_allowed_execution;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>上面这种写法可能是比较常见的，比较符合我们的思维习惯，但是使用位运算中掩码的概念来改写这个例子，会使得更加简洁、高效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Permission</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">byte</span> <span class="variable">Allowe_Read</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">0</span>;<span class="comment">//00000001</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">byte</span> <span class="variable">Allowe_Write</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">1</span>;<span class="comment">//00000010</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">byte</span> <span class="variable">Allow_Execution</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">2</span>;<span class="comment">//00000100</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span> <span class="variable">permissionMask</span> <span class="operator">=</span> <span class="number">0x00</span>;<span class="comment">//默认没有任何权限</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Permission</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Permission</span><span class="params">(<span class="type">byte</span> permission)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.permissionMask = permission;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//增加一项或者多项权限</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enable</span><span class="params">(<span class="type">byte</span> permission)</span> &#123;</span><br><span class="line">         <span class="built_in">this</span>.permissionMask |= permission;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//禁用一项或多项的权限</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">disable</span><span class="params">(<span class="type">byte</span> permission)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.permissionMask &amp;= ~permission;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//查询一项或多项权限是否被启用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAllowed</span><span class="params">(<span class="type">byte</span> permission)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.permissionMask &amp; permission == permission;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//查询一项或多项权限是否被禁用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDisAllowed</span><span class="params">(<span class="type">byte</span> permission)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.permissionMask &amp; permission == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>这种写法明显表达的信息量要多于第一种写法，举个例子：现在要同时启用三种权限，那么第一种写法就是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">setIsAllowedRead(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">setIsAllowedWrite(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">setIsAllowedExecution(<span class="literal">true</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>而第二种写法就是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">enable(Permission.ALLOW_READ | Permission.ALLOW_WRITE | Permission.ALLOW_EXECUTION);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这种写法对于使用<code>Permission</code>类的时候来说，方便许多。在<code>Linux</code>系统中设置权限时通常会用到</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 777 file</span><br></pre></td></tr></table></figure>

<p> 其中<code>777</code>就是<code>1111111 | 1111111 | 1111111</code>，可见<code>Linux</code>里面也是采用位运算中的掩码来设置文件权限的。</p>
<p> 用位运算的方式来实现这个权限控制的优点是：高效，位运算比较接近与机器的运算方式；简洁，无论试编写还是使用都比较方便简洁。<br> 缺点：代码不够直观，可读性差，当维护这段代码的时候可能比较恼火， 不如第一种写法一目了然。</p>
<p> 通常如果需要维护<code>n</code>个开关变量（二值变量）的时候，只需要<code>n</code>位二进制的整数和数个<code>mask</code>即可，完成状态的保存和查询。这种写法在<code>Android SDK</code>里面是非常常见的。<br> 可以加以推广，如果需要保存<code>n</code>个具有<code>m</code>种状态的变量，那么需要一个<code>n</code>位<code>m</code>进制的数即可完成。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://spground.github.io/2016/12/13/Java%20long%20double%20vaiables%20atomic%20problem/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Spground">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spground Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Spground Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2016/12/13/Java%20long%20double%20vaiables%20atomic%20problem/" class="post-title-link" itemprop="url">Java的long、double类型的原子性读取问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2016-12-13 00:00:00" itemprop="dateCreated datePublished" datetime="2016-12-13T00:00:00+08:00">2016-12-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-24 22:30:21" itemprop="dateModified" datetime="2025-09-24T22:30:21+08:00">2025-09-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>In programming, an atomic action is one that effectively happens all at once. An atomic action cannot stop in the middle: it either happens completely, or it doesn’t happen at all. No side effects of an atomic action are visible until the action is complete.</p>
</blockquote>
<p>以上是关于原子性的操作的相关描述。</p>
<p>在Java中，以下的操作可以认为是原子操作</p>
<ol>
<li>对于引用变量、大多数的原始类型变量的读、写（所有的类型除了<code>long</code>和<code>double</code>）都是原子性的（这个只有才32位的JVM成立）</li>
<li>所有申明为<code>volatile</code>的变量（包括<code>long</code>和<code>double</code>变量）的读、写都是原子性的</li>
</ol>
<p>在Java中，自增、自减操作都不是原子性操作，很容易理解。但是<code>long</code>和<code>duoble</code>的读写却不是原子性的问题，却不太好理解。</p>
<h2 id="检验"><a href="#检验" class="headerlink" title="检验"></a>检验</h2><p>在32位JVM上，通过两个线程对同一个成员变量进行读写，来测试<code>long</code>和<code>double</code>类型变量的读写不是原子性操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnatomicLongDemo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">test</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> val;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">UnatomicLongDemo</span><span class="params">(<span class="type">long</span> val)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.val = val;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">			test = val;<span class="comment">//两个线程同时断写test变量，如果test变量的读写操作是原子性的，那么test只能是-1或者0</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">UnatomicLongDemo</span>(-<span class="number">1</span>));</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">UnatomicLongDemo</span>(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">		System.out.println(Long.toBinaryString(-<span class="number">1</span>));</span><br><span class="line">		System.out.println(pad(Long.toBinaryString(<span class="number">0</span>), <span class="number">64</span>));</span><br><span class="line"></span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line"></span><br><span class="line">		<span class="type">long</span> switchVal;</span><br><span class="line">		<span class="keyword">while</span> ((switchVal = test) == -<span class="number">1</span> || switchVal == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">//如果test、switchVal的操作是原子性的,那么就应该是死循环，否则就会跳出该循环</span></span><br><span class="line">			System.out.println(<span class="string">&quot;testing...&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		System.out.println(pad(Long.toBinaryString(switchVal), <span class="number">64</span>));</span><br><span class="line">		System.out.println(switchVal);</span><br><span class="line"></span><br><span class="line">		t1.interrupt();</span><br><span class="line">		t2.interrupt();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将0补齐到固定长度</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">pad</span><span class="params">(String s, <span class="type">int</span> targetLength)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> targetLength - s.length();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; n; x++) &#123;</span><br><span class="line">			s = <span class="string">&quot;0&quot;</span> + s;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>测试结果为</p>
<p><img src="http://img.blog.csdn.net/20171119174224137?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDUzMjkwMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>通过这个例子可以看出</p>
<ol>
<li><p>在32位JVM上，对<code>long</code>型变量<code>test</code>的读取或者对<code>long</code>型变量<code>switchVal</code>的写入不是原子性的。</p>
</li>
<li><p>非原子性的读、写只是造成<code>long</code>、<code>double</code>类型变量的高、低32位数据不一致</p>
</li>
</ol>
<p>这是由于在32位JVM中对64位的数据的读、写分两步，每一步读或者写32位的数据，这样就会造成两个线程对同一个变量的读写出现一个线程写高32位、另一个线程写入低32位数据。这样此变量的数据就出现不一致的情况。这时候<code>volatile</code>关键字可以防止这种现象发生，因为java的内存模型保证了<code>valotile</code>修饰的<code>long</code>、<code>double</code>变量的读写是原子性的。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://spground.github.io/2016/12/13/Java%20singleton%20design%20pattern/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Spground">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spground Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Spground Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2016/12/13/Java%20singleton%20design%20pattern/" class="post-title-link" itemprop="url">java中单例的几种写法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2016-12-13 00:00:00" itemprop="dateCreated datePublished" datetime="2016-12-13T00:00:00+08:00">2016-12-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-24 22:30:21" itemprop="dateModified" datetime="2025-09-24T22:30:21+08:00">2025-09-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>单例模式是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中一个类只有一个实例。</p>
</blockquote>
<p>单例通常有很多种写法，但是性能和效果却是差距挺大。下面列举了几种常见的写法。</p>
<h2 id="一、单例模式常见的写法"><a href="#一、单例模式常见的写法" class="headerlink" title="一、单例模式常见的写法"></a>一、单例模式常见的写法</h2><ol>
<li>懒汉式（线程不安全）<br>  ​</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singlton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="literal">null</span>)</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>这种写法，在多线程的时候，由于并发访问instance，会导致创建多个instance，从而使得单例模式失效。</p>
<ol start="2">
<li>懒汉式（线程安全1）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singlton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="literal">null</span>)</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这种写法的优点是保证了线程安全，缺点是效率低下，因为<code>instance</code>一旦创建，大部分时间都是多线程在访问<code>instance</code>,因此把同步加在方法上会导致多个线程等待。</p>
<ol start="3">
<li>懒汉式（线程安全2）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singlton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这种写法有效的避免了第2种写法的缺点，当instance被创建成功后，大部分时间多线程访问instance的时候都无需同步；而只有当需要创建instance的时候才需要同步创建instance的代码块。看似这种写法比较完美，但是这种写法有有一个致命的缺点就是，当线程A判断instance等于null的时候，这时线程A被挂起，线程B判断instance为null，同时获取到锁进入了同步代码块，然后成功的创建了instance，最后释放了锁退出了同步代码块。恰好此时线程A成功的获取到锁进入同步代码块继续执行，它也会创建一个instance，这样instance就被创建不止一次，系统中就存在多个instance。</p>
<ol start="4">
<li>双重检验式（Double Check Lock）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">          instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">          <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>另一种类似的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">          instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">          <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双重校验可以避免第3种方法的缺点，当线程获得锁后进入同步代码块后，再进一步确认instance是否为null。通常双重校验锁这种形式会比较好的达到正常的单例的效果。</p>
<ol start="5">
<li>饿汉式</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式利用ClassLoader的机制保证了单例类只在被类加载器第一次加载的时候，创建一个instance，避免了多线程的同步问题。优点是没有同步代码块，效率高；缺点是Singleton可能会因为多种原因被加载，因此没有实现懒加载。</p>
<ol start="6">
<li>饿汉式（静态内部类）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式相对于第5种方式，虽然由于某种原因导致Singleton类被类加载器加载，但是由于<code>SingletonHolder</code>没有被显示的加载，因此instance还是没有被创建。因此这种形式在某种程度上来说，相对于第5种写法来说延迟了instance的创建。</p>
<p><strong>当单例类由不同的类加载器加载或者能被序列化和反序列化或者可以通过反射来调用私有构造函数的时候，上述的几种方式都不能很好的实现单例的效果，这个需要再进一步讨论。</strong></p>
<h2 id="二、枚举类型实现单例模式"><a href="#二、枚举类型实现单例模式" class="headerlink" title="二、枚举类型实现单例模式"></a>二、枚举类型实现单例模式</h2><p>从<code>JDK1.5</code>以后，可以通过枚举类型来实现线程安全的、防止序列化和反序列化的、代码简洁的单例模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> a,b,c;</span><br><span class="line">    <span class="comment">//构造函数只能为私有的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">     </span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">     </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>采用这种方式实现的单例模式是十分推荐的，天然线程安全，天然解决了序列化和反序列化之后、反射调用私有构造函数出现多个对象的问题。同时这也是<em>Effective Java</em>推荐的写法。</p>
<h2 id="三-、References"><a href="#三-、References" class="headerlink" title="三 、References"></a>三 、References</h2><p><a href="https://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html">https://www.cs.umd.edu/~pugh&#x2F;java&#x2F;memoryModel&#x2F;DoubleCheckedLocking.html</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://spground.github.io/2016/10/23/Collections%20Rotate/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Spground">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spground Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Spground Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2016/10/23/Collections%20Rotate/" class="post-title-link" itemprop="url">Collections类中常用算法之Rotate</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2016-10-23 14:26:00" itemprop="dateCreated datePublished" datetime="2016-10-23T14:26:00+08:00">2016-10-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-24 22:30:21" itemprop="dateModified" datetime="2025-09-24T22:30:21+08:00">2025-09-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Collections类简介"><a href="#Collections类简介" class="headerlink" title="Collections类简介"></a>Collections类简介</h2><p><code>Collections</code>类是java集合框架的一个类，其主要是一些通用的作用于<code>Collection</code>的 算法，如排序，求极值，混淆(shuffle)等。<br>引用<a href="http://docs.oracle.com/javase/tutorial/collections/algorithms/index.html">Java官方文档</a>的介绍</p>
<blockquote>
<p>The polymorphic algorithms described here are pieces of reusable functionality provided by the Java platform. All of them come from the Collections class, and all take the form of static methods whose first argument is the collection on which the operation is to be performed. The great majority of the algorithms provided by the Java platform operate on List instances, but a few of them operate on arbitrary Collection instances. </p>
</blockquote>
<p><code>Collections</code>类的方法都是静态方法，每一种方法都对应一种集合算法的实现，且每一种实现都有两种，一种是适用于实现了<code>RandomAccess</code>接口的集合类（例如<code>ArrayList</code>），另一种是适用于序列存储的，例如（<code>LinkedList</code>）。</p>
<p><code>Collections</code>类包含的算法实现大致如下：</p>
<ul>
<li>排序<br> 排序采用归并排序，所以排序算法是稳定的，时间复杂度是确定的。</li>
<li>混淆</li>
<li>常规的集合数据操作（适用于<code>List</code>）<br>包括<code>reverse</code>、<code>fill</code>、<code>copy</code>、<code>swap</code>、<code>addAll</code>等</li>
<li>搜索（适用于<code>List</code>）<br>  <code>binarySearch</code></li>
<li>极值<br>求集合的最大元素、最小元素</li>
</ul>
<p><code>Collections</code>中的大多数算法都只是适用于<code>List</code>，接下来讨论的<code>Rotate</code>方法就是只适用于<code>List</code>的。<br>使用与<code>List</code>的算法主要有：</p>
<ul>
<li>sort</li>
<li>shuffle</li>
<li>reverse</li>
<li>rotate</li>
<li>swap</li>
<li>replaceAll</li>
<li>fill</li>
<li>copy</li>
<li>binarySearch</li>
<li>indexOfSubList</li>
<li>lastIndexofSubList</li>
</ul>
<h2 id="Rotate方法使用"><a href="#Rotate方法使用" class="headerlink" title="Rotate方法使用"></a>Rotate方法使用</h2><p><code>Rotate</code>方法需要一个参数<code>distance</code>，该方法将一个<code>List</code>旋转多少长度为<code>distance</code>。假如有个序列列<code>list</code>是<code>[a,b,c,d]</code>，调用方法<code>Collections.rotate(list, 1)</code>后，得到的<code>list</code>就变为了<code>[d,a,b,c]</code>。<br>调用此方法后，位置<code>i</code>上的元素将变为位置<code>(i - distance) mod list.size()</code>的元素，<code>0 &lt;= i &lt; list.size()</code>。<code>distance</code>可以为正数、0、负数。正数代表向前（下标值变大的方向）旋转，负数代表向后旋转。调用方法<code>Collections.rotate(list, -1)</code>后，得到的<code>list</code>就变为了<code>[b,c,d,a]</code>。</p>
<p>这个方法常常和<code>List</code>的<code>subList</code>方法结合使用，用于将一个<code>list</code>的某个或多个元素进行移动，而不破坏其余元素的顺序。例如为了将某个<code>list</code>的位置<code>j</code>的元素向前移动到<code>k</code>的位置。（设移动的距离为<code>d</code>（<code>d &gt;= 0</code>），<code>k = j + d + 1</code>）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.rotate(list.subList(j, k+<span class="number">1</span>), -<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>举个栗子，例如<code>[a,b,c,d,e]</code>，将<code>b</code>元素向前移动三个位置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.rotate(list.subList(<span class="number">1</span>, <span class="number">5</span>), -<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>调用后得到<code>list</code>为<code>[a,c,d,e,b]</code>。</p>
<h2 id="Rotate方法源码分析"><a href="#Rotate方法源码分析" class="headerlink" title="Rotate方法源码分析"></a>Rotate方法源码分析</h2><p><code>Rotate</code>方法的方法原型为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(List&lt;?&gt; list, <span class="type">int</span> distance)</span> </span><br></pre></td></tr></table></figure>
<p><code>Rotate</code>方法有两种实现，一种适用于实现了<code>RandomAccess</code>接口的<code>List</code>（类似数组的随机访问性质）或者<code>size</code>小于阈值的序列存储的<code>List</code>，另一种是<code>size</code>大于阈值的序列存储（通常是指链表的形式存储的）的<code>List</code>。  </p>
<p>关于该方法的源码为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(List&lt;?&gt; list, <span class="type">int</span> distance)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (list <span class="keyword">instanceof</span> RandomAccess || list.size() &lt; ROTATE_THRESHOLD)</span><br><span class="line">          rotate1(list, distance);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          rotate2(list, distance);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>rotate1</code>对应于第一种的实现，<code>rotate2</code>对应于第二种的实现。  </p>
<p>对于<code>rotate1</code>的实现具体的做法是，将序列的第一个元素交换至正确的位置<code>i</code>，此时原来在位置<code>i</code>的元素就是一个错误放置的元素<code>displaced</code>，然后计算该元素正确放置的位置<code>i</code>，并将其放置到位置<code>i</code>，此时又得到一个错误放置的元素<code>displaced</code>，重复此过程直到错误放置的元素<code>displaced</code>被放置到了第一个位置。（即<code>i == 0</code>）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">rotate1</span><span class="params">(List&lt;T&gt; list, <span class="type">int</span> distance)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> list.size();</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    distance = distance % size;</span><br><span class="line">    <span class="keyword">if</span> (distance &lt; <span class="number">0</span>)</span><br><span class="line">        distance += size;<span class="comment">//将distance化为到范围为0到size - 1的区间</span></span><br><span class="line">    <span class="keyword">if</span> (distance == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">cycleStart</span> <span class="operator">=</span> <span class="number">0</span>, nMoved = <span class="number">0</span>; nMoved != size; cycleStart++) &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">displaced</span> <span class="operator">=</span> list.get(cycleStart);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cycleStart;</span><br><span class="line">        <span class="comment">//从cycleStart开始，迭代式的将错误放置的元素放置到正确的位置，直到某个元素被放置到了cycleStart</span></span><br><span class="line">        <span class="comment">//此时，应该结束do...while循环，因为如果继续循环得到的结果就是啥也没干，因为上一轮的循环已经</span></span><br><span class="line">        <span class="comment">//将此次循环访问到的位置的元素放正确了，此时应该换下一个位置作为起点cycleStart，继续执行直到</span></span><br><span class="line">        <span class="comment">//被正确放置的元素的个数nMoved达到了size个</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            i += distance;</span><br><span class="line">          <span class="comment">//此处i的范围是 0 ~ 2*size</span></span><br><span class="line">          <span class="comment">//当i大于size且小于2 * size的时候，此时i= i mod size 等价于 i = i - size</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">                i -= size;</span><br><span class="line">            <span class="comment">//此时i的范围为0 ~ size - 1</span></span><br><span class="line">            displaced = list.set(i, displaced);</span><br><span class="line">            nMoved ++;<span class="comment">//记录已经被正确放置的元素的个数</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (i != cycleStart);<span class="comment">//当i回到起点后，退出本次循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于<code>rotate2</code>的实现与上面的实现完全不一样，因为考虑到<code>rotate2</code>适用于的是类似于采用链表存储的<code>List</code>，因此不具有随机访问的特性。因此该实现采用的是将原<code>list</code>在<code>-distance mod size</code>处使用<code>subList</code>方法拆分为两个子列表<code>s1</code>，<code>s2</code>，并分别反转俩链表<code>revese(s1)</code>，<code>reverse(s2)</code>，最后再将整个链表反转，<code>reverse(list)</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">rotate2</span><span class="params">(List&lt;?&gt; list, <span class="type">int</span> distance)</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> list.size();</span><br><span class="line">      <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span>  -distance % size;</span><br><span class="line">      <span class="keyword">if</span> (mid &lt; <span class="number">0</span>)</span><br><span class="line">          mid += size;<span class="comment">//确保mid位于0 ~ size的区间</span></span><br><span class="line">      <span class="keyword">if</span> (mid == <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">//分别反转两个子链表</span></span><br><span class="line">      reverse(list.subList(<span class="number">0</span>, mid));</span><br><span class="line">      reverse(list.subList(mid, size));</span><br><span class="line">      <span class="comment">//最后反转整个链表 两次反转确保俩子链表的元素的的相对位置不变</span></span><br><span class="line">      reverse(list);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20161023141425837" alt="示意图">  </p>
<p>示意图中<code>(1) (2) (3)</code>分别对应三次链表反转。由示意图中大致可以看出，前两次反转子链表的目的是为了将原链表的首末连在一起，并将<code>mid</code>指向的的元素和其逆时针方向的旁边的元素断开。最后整个链表的反转是为了恢复俩子链表的元素的原始相对顺序。</p>
<p>链表的反转通常采用<code>头插法</code>反转。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li><code>rotate</code>方法是将链表旋转一定的<code>distance</code>，该方法常常与<code>subList</code>方法结合用户在<code>List</code>中移动某个元素到指定的位置，而不影响其他元素的顺序</li>
<li><code>rotate</code>有两种实现，一种针对于随机存取的，另一种针对链表式存取的。</li>
<li>两种实现的思想也不一样，一种是通过迭代式的交换，另一种是通过链表的反转实现的。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://spground.github.io/2016/09/30/Common%20Sort%20Algorithm%20merge%20sort%20and%20quick%20sort/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Spground">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spground Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Spground Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2016/09/30/Common%20Sort%20Algorithm%20merge%20sort%20and%20quick%20sort/" class="post-title-link" itemprop="url">常用排序算法——合并排序和快速排序</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2016-09-30 16:42:00" itemprop="dateCreated datePublished" datetime="2016-09-30T16:42:00+08:00">2016-09-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-24 22:30:21" itemprop="dateModified" datetime="2025-09-24T22:30:21+08:00">2025-09-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h2><p><strong>分治</strong><code>(Divide and Conquer)</code>是一场常见的算法策略。分治策略的基本思想就是对于一个问题规模为<code>N</code>的问题，将其划分为规模足够小的<code>K</code>个子问题，子问题由于规模足够小可以直接求解，最后将规模足够小的<code>K</code>的问题的解合并得出原问题的解。<br>分治策略的问题的求解过程的一般套路就是：  </p>
<ol>
<li>判断问题规模，足够小进入步骤2，否者进入步骤3</li>
<li>直接对问题进行求解，返回问题的解。</li>
<li>将问题拆分成<code>K</code>个小规模的问题，进入步骤2。并将解合并，得到原问题的解。</li>
</ol>
<p>由于分治策略的步骤描述自带递归属性，因此分治策略的算法实现常采用递归来实现。递归的算法通常会含有三部分，第一部分是个基准情况<code>(Base Case)</code>，第二部分是问题拆分，并调用自身，第三部分是合并并返回结果。</p>
<p>分治策略中主要有两个关键过程：</p>
<ul>
<li>将原问题拆分<code>Division</code></li>
<li>将各子问题合并<code>Combination</code></li>
</ul>
<p>分治策略的主要时间开销发生在这两个过程，通常分治策略有两类  </p>
<ol>
<li>拆分容易，合并困难</li>
<li>拆分困难，合并简单</li>
</ol>
<p>下文中的<strong>合并排序</strong>和<strong>快速排序</strong>分别属于上面的第1和第2类。</p>
<h2 id="合并排序和快速排序"><a href="#合并排序和快速排序" class="headerlink" title="合并排序和快速排序"></a>合并排序和快速排序</h2><p>在常见排序算法中，合并排序和快速排序是<strong>典型的分治算法</strong>，其时间复杂度的平均性能均为<code>nlgn</code>。合并排序的最坏时间复杂度也能保持<code>nlgn</code>，而快速排序的最坏时间复杂度却为<code>n*n</code>。<strong>合并排序是稳定的，而快速排序不是稳定的。</strong></p>
<p><strong>另外合并排序是拆分容易，合并困难，而快速排序则是拆分困难，合并容易。</strong></p>
<ol>
<li><p><strong>合并排序又称归并排序，主要的思想是：将待排序列拆分至数个足够小的子序列，然后将相邻子序列合并为一个有序子序列，重复合并相邻有序子序列直到整个序列有序。</strong></p>
</li>
<li><p><strong>快速排序的主要思想则是，选取一个枢纽（<code>pivot</code>）， 将待排序列拆分为左右两个子序列A,B，使得子序列A的元素都不大于<code>pivot</code>， 子序列B的元素都大于<code>pivot</code>。这样使得子序列A的元素都不大于子序列B，然后对子序列A，B递归进行这种拆分，直到待拆分的序列足够小，最后整个序列变成有序。</strong></p>
</li>
</ol>
<p>由于合并排序和快速排序每次元素的移动都不只移动了一个位置，因此每次元素的比较都<strong>不只消除了一个逆序对</strong>，因此对于插入排序这种每次比较只移动一个位置的算法，时间复杂度会得到改善。</p>
<h2 id="快速排序的递归实现"><a href="#快速排序的递归实现" class="headerlink" title="快速排序的递归实现"></a>快速排序的递归实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> l, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">    <span class="type">int</span> pivot = a[l];</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    i = l - <span class="number">1</span>;</span><br><span class="line">    j = h + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(a[--j] &gt; pivot);</span><br><span class="line">        <span class="keyword">while</span>(a[++i] &lt; pivot)</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= h)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//i 、j cross</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt;= j)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> tmp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    a[j] = pivot;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> l, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= h)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> p = partition(a, l, h);</span><br><span class="line">    quickSort(a, l, p);</span><br><span class="line">    quickSort(a, p+<span class="number">1</span>, h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="合并排序的递归实现"><a href="#合并排序的递归实现" class="headerlink" title="合并排序的递归实现"></a>合并排序的递归实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> l, <span class="type">int</span> m, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(l == h)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* b = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * (h - l + <span class="number">1</span>));</span><br><span class="line">    <span class="type">int</span> i = l, j = m + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= m &amp;&amp; j &lt;= h)</span><br><span class="line">        b[k++] = a[i] &gt; a[j] ? a[j++] : a[i++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i &lt;= m)</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= m)</span><br><span class="line">            b[k++] = a[i++];</span><br><span class="line">    <span class="keyword">if</span>(j &lt;= h)</span><br><span class="line">        <span class="keyword">while</span>(j &lt;= h)</span><br><span class="line">            b[k++] = a[j++];</span><br><span class="line">    <span class="comment">//回写</span></span><br><span class="line">    i = l;</span><br><span class="line">    k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(; i &lt;= h;)</span><br><span class="line">        a[i++] = b[k++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> l, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= h)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> m = (h + l) / <span class="number">2</span>;</span><br><span class="line">    mergeSort(a, l, m);</span><br><span class="line">    mergeSort(a, m+<span class="number">1</span>, h);</span><br><span class="line">    merge(a, l, m, h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="合并排序的非递归实现"><a href="#合并排序的非递归实现" class="headerlink" title="合并排序的非递归实现"></a>合并排序的非递归实现</h2><p>由于递归会导致函数调用栈的暴增，会引入额外的时间开销，例如现场保护和恢复之类的。通递归版本的算法都可以改写为迭代版本的算法。递归算法的优点是实现简单直观，易于理解，缺点是如果有时候调用深度过深，会带来栈内存溢出和额外的运行时间开销。迭代算法的有点是不会有额外的函数调用栈的增长， 缺点是难于理解且难于实现。</p>
<p>合并排序的迭代版本的实现相对来讲是比较简单直观的，大致思路就是：第1轮，待排序列S中相邻的长度为1的子序列进行合并，第2轮，序列S中相邻的长度为2的子序列进行合并，第<code>i</code>轮，待排序列S中相邻的长度为<code>2的i-1次方</code>的子序列进行合并。直到待合并的子序列数为1。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> l, <span class="type">int</span> m, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(l == h)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* b = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * (h - l + <span class="number">1</span>));</span><br><span class="line">    <span class="type">int</span> i = l, j = m + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= m &amp;&amp; j &lt;= h)</span><br><span class="line">        b[k++] = a[i] &gt; a[j] ? a[j++] : a[i++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i &lt;= m)</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= m)</span><br><span class="line">            b[k++] = a[i++];</span><br><span class="line">    <span class="keyword">if</span>(j &lt;= h)</span><br><span class="line">        <span class="keyword">while</span>(j &lt;= h)</span><br><span class="line">            b[k++] = a[j++];</span><br><span class="line">    <span class="comment">//回写</span></span><br><span class="line">    i = l;</span><br><span class="line">    k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(; i &lt;= h;)</span><br><span class="line">        a[i++] = b[k++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非递归版本</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mergeIteation</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> offset = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(offset &lt;= n) &#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i &lt; n;) &#123;</span><br><span class="line">            merge(a,i, i+offset<span class="number">-1</span>,i+offset*<span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">            i = i + offset * <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(n - <span class="number">1</span> - i &lt; offset)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        offset *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://spground.github.io/2016/09/23/Common%20Sort%20Algorithm%20improvement%20of%20bubble%20sort%20and%20time%20complexity%20analysis%20of%20insertion%20sort%20/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Spground">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spground Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Spground Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2016/09/23/Common%20Sort%20Algorithm%20improvement%20of%20bubble%20sort%20and%20time%20complexity%20analysis%20of%20insertion%20sort%20/" class="post-title-link" itemprop="url">常用排序算法--冒泡排序及改进和插入排序时间复杂度分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2016-09-23 19:27:00" itemprop="dateCreated datePublished" datetime="2016-09-23T19:27:00+08:00">2016-09-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-24 22:30:21" itemprop="dateModified" datetime="2025-09-24T22:30:21+08:00">2025-09-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="排序及常见排序算法"><a href="#排序及常见排序算法" class="headerlink" title="排序及常见排序算法"></a>排序及常见排序算法</h1><blockquote>
<p>排序是计算机内经常进行的一种操作，其目的是将一组“无序”的记录序列调整为“有序”的记录序列。分内部排序和外部排序。若整个排序过程不需要访问外存便能完成，则称此类排序问题为内部排序。反之，若参加排序的记录数量很大，整个序列的排序过程不可能在内存中完成，则称此类排序问题为外部排序。内部排序的过程是一个逐步扩大记录的有序序列长度的过程。</p>
</blockquote>
<p>上面是关于排序的一些介绍，排序按是否使用外在存储来分分为<strong>内部排序（locally sort）<strong>和</strong>外部排序（external sort）</strong>。下文分析的是内部排序的两种常见的、简单易实现的排序算法，虽然两者的排序算法的时间复杂度在众多内部排序算法中属于下等，但是对于理解内部排序（特别是采用比较排序）的一些机制是十分有用的。  </p>
<p>常见的内部排序算法及其时间复杂度主要如下：</p>
<ul>
<li><strong>冒泡排序</strong>  冒泡排序通过两两相邻元素比较，每一趟将本趟中最大的元素放在数组尾部合适的位置。由于每一趟只正确放置一个元素，因此时间复杂度为<code>O(n*n)</code>  </li>
<li><strong>插入排序</strong> 插入排序是通过将当前第<code>i</code>个待排元素<code>i</code>与数组中前<code>i-1</code>个已经有序的元素<code>j</code> 进行两两比较，如果元素 <code>i</code> 小于 <code>j</code>，便交换。直到遇到比<code>i</code>小的元素或者到达数组头。由于每一个元素的插入都会最多比较<code>i - 1</code>次，因此最坏的时间复杂度为 <code>1 + 2 + 3 + ... + n - 1 = n * (n - 1) / 2</code> ， 因此时间复杂度也为<code>O(n*n)</code>。  </li>
<li><strong>希尔排序</strong> 插入排序的一种改进，具有优良的时间复杂度，时间复杂度为<code>O(n*n)</code></li>
<li><strong>快速排序</strong> 基于分治的策略排序，时间复杂度为<code>O(nlgn)</code>，由于待排数据如果是逆序，其时间复杂度会变为<code>O(n*n)</code>，因此常用的方法是在排序前先随机化待排数据。</li>
<li><strong>归并排序</strong> 基于分治的策略排序，时间复杂度为<code>O(nlgn)</code>，需要额外的存储空间</li>
<li><strong>堆排序</strong> 采用二叉树的性质进行排序，不需要额外的内存空间，时间复杂度为<code>O(nlgn)</code></li>
<li><strong>计数排序</strong> 非比较排序，要求输入的数据的范围为<code>0 ~ K</code>，时间复杂度为<code>O(n)</code></li>
<li><strong>基数排序</strong> 非比较排序，是计算排序的一种变种，对输入数据的要求降低到了数据的的位数为<code>d</code>，每一位的范围为<code>0~k</code>。</li>
</ul>
<h1 id="插入排序时间复杂度分析"><a href="#插入排序时间复杂度分析" class="headerlink" title="插入排序时间复杂度分析"></a>插入排序时间复杂度分析</h1><p>上文中介绍的除了计数排序和基数排序外，其余均为内排序中的比较排序，即通过两元素的比较，来确定元素正确放置的位置。  </p>
<p><strong>插入排序算是一种比较经典的比较类排序算法</strong>，可以分析其时间复杂度，然后确定其<strong>最坏和平均时间复杂度</strong>，从而来确定时间复杂度的最低边界。  </p>
<p>由于没有比较，就不会有元素的交换，因此元素的交换次数是小于等于</p>
<ol>
<li>最坏时间复杂度分析：若输入的<code>n</code>个数据是逆序的，那么对第<code>i</code>个元素的插入，需要比较<code>i-1</code>次，因此总的时间复杂度为为<code>n*(n - 1) / 2</code></li>
<li>平均时间复杂度分析：对于第<code>i</code>个元素的插入，该元素有<code>i + 1</code>个位置可以插入，平均来看，插入每一个位置的概率都相同为<code>1 / (i + 1)</code>；对于每一个位置比较的次数分别为<code>1, 2, 3, 4, 5 ... i, i</code>，因为当<code>i</code>元素为最小和次小的时候，比较次数都为<code>i</code>次，（当比较<code>i</code>次后，便可以知道该元素是最小还是次小了），所以插入第<code>i</code>个元素的比较次数为<code>1 / (i + 1) * (1 + 2 +3 + ... + i) + i / (1 + i)</code>，那么对于<code>n</code>各元素的<code>n-1</code>次插入来看，总的比较次数近似于<code>n * n / 4</code>。所以插入排序的时间复杂度为<code>n * n / 4</code></li>
</ol>
<p>对于一个待排序列S，S(i)元素表示位置应该在i的元素。那么如果S(i) &lt; S(j)，i &gt; j，称（S(i)，S(j))为逆序对（inversion），对于每一个n个元素的输入，最多有<code>n * (n - 1) / 2</code>个逆序对，如果比较排序算法每一次比较最多消除一个逆序对，那么比较排序算法的最坏时间复杂度至少为 <strong><code>n * (n - 1) / 2</code></strong>。</p>
<p>考虑待排序列的转置(transpose) 序列T，转置序列T和序列S的元素顺序是颠倒的。显然一个逆序对(inversion)不是在序列S中，就是在其转置序列T中，因此两个序列的逆序对数量之后等于<code>n * (n - 1) / 2</code>，每个序列逆序对数量平均为<code>n * (n - 1) / 4</code> 约为<code>n*n/4</code>。</p>
<p>以上分析可以得出下面的理论</p>
<blockquote>
<p>对于含有<code>n</code>个元素的待排输入，任何通过比较来排序的算法，若其每一次比较至多消除一个逆序对的话，其在最坏情况下至少得比较<code>n(n-1)/2</code>次，在平均情况下至少得比较<code>n(n-1)/4</code></p>
</blockquote>
<p>由于插入排序的最坏和平均情况下比较的次数都接近上述分析给出的数值，考虑那些只比较交换相邻元素的算法，插入排序可以算是最好的算法了。如果想要显著的改善此类排序算法的性能，我们必须在一次将元素移动超过一个位置。（或是一次消除多个逆序对）。这种想法给性能较好的快速排序和希尔排序等带来新的思路。</p>
<p>下面是插入排序的代码示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insertSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(j = i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j] &lt; a[j<span class="number">-1</span>])</span><br><span class="line">                swap(&amp;a[j], &amp;a[j<span class="number">-1</span>]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>冒泡排序得名于其简单，易用的排序风格。冒泡排序通过每一趟相邻元素的的两两比较确定某一个元素的正确的位置，这样进行<code>n</code>趟就确定了<code>n</code>个元素的位置了。冒泡排序的代码示例如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j] &gt; a[j+<span class="number">1</span>])</span><br><span class="line">                swap(&amp;a[j], &amp;a[j+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最常见的冒泡排序如上所示。</p>
<h1 id="冒泡排序的改进"><a href="#冒泡排序的改进" class="headerlink" title="冒泡排序的改进"></a>冒泡排序的改进</h1><h2 id="改进版本1"><a href="#改进版本1" class="headerlink" title="改进版本1"></a>改进版本1</h2><p>如果输入的待排序列的尾部是部分有序的，那么内部循环的<code>j</code>就没有必要增加到<code>n-i</code>了，直接在上一趟最后发生元素交换的位置<code>lastSwapIndex</code>，这样就可以减少没有必要的的比较了。例如序列<code>7,8,5,6,9,10,11</code>，第一趟比较，<code>7,5,6,8,9,10,11</code> 后的结果为最后交换的位置为元素<code>6</code>的位置（<code>8</code>与<code>6</code>交换)，因此下一趟比较的时候，<code>j</code>就没有必要增加到元素<code>10</code>的位置了，因为上一趟最后发生交换的位置<code>lastSwapIndex</code>代表了此位置以后的元素都已经完排序了，不需进行没必要的比较了。</p>
<p>因此改进后的冒泡排序如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bubbleSort1</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> lastSwapIndex = n - i;</span><br><span class="line">    <span class="type">int</span> q = n - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//n趟</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; q; j++)</span><br><span class="line">            <span class="keyword">if</span>(a[j] &gt; a[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                swap(&amp;a[j], &amp;a[j+<span class="number">1</span>]);</span><br><span class="line">                lastSwapIndex = j;<span class="comment">//记录每一趟最后交换的位置</span></span><br><span class="line">            &#125;</span><br><span class="line">        q = lastSwapIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过记录上一趟待排序列尾部中最后一次进行元素交换的位置，为下一趟省去了不必要的比较次数，从而改进了冒泡排序。  </p>
<h2 id="改进版本2"><a href="#改进版本2" class="headerlink" title="改进版本2"></a>改进版本2</h2><p>同样的思路，如果待排序列的开始已经是部分有序了，那么内部循环的<code>j</code>也没有必要每一趟都从<code>0</code>开始了。例如待排序列<code>1,2,3,4,9,7,8,6</code>第一趟首次发生交换的位置为元素<code>9</code>的位置，那么下一趟<code>j</code>就没有必要从<code>0</code>开始了，而是从元素<code>9</code>的位置<code>beginSwapIndex</code>的前一个位置（记为<code>beginSwapIndex - 1</code>）开始，进行比较。因为上一趟的首次发生交换的位置<code>beginSwapIndex</code>表明此位置<code>beginSwapIndex - 1</code>的元素都是有序的了，下一趟的比较就从位置<code>eginSwapIndex - 1</code>开始，为什么是<code>beginSwapIndex - 1</code>? 而不是<code>beginSwapIndex</code>呢？是因为上一趟首次发生交换后，被交换到位置<code>beginSwapIndex</code>元素无法确定是否大于位置<code>beginSwapIndex - 1</code>的元素，因此需要从<code>beginSwapIndex - 1</code>的元素继续开始比较。</p>
<p>下面是改进版本2的代码示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//改进版1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bubbleSort1</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> lastSwapIndex = n - i;</span><br><span class="line">    <span class="type">int</span> q = n - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//n趟</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; q; j++)</span><br><span class="line">            <span class="keyword">if</span>(a[j] &gt; a[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                swap(&amp;a[j], &amp;a[j+<span class="number">1</span>]);</span><br><span class="line">                lastSwapIndex = j;<span class="comment">//记录每一趟最后交换的位置</span></span><br><span class="line">            &#125;</span><br><span class="line">        q = lastSwapIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//改进版2</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bubbleSort2</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> lastSwapIndex = n - i;</span><br><span class="line">    <span class="type">int</span> beginSwapIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> q = n - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> p = beginSwapIndex;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> firstFlag = <span class="number">1</span>;<span class="comment">//是否为首次发生交换的flag</span></span><br><span class="line">    <span class="comment">//n趟</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = p; j &lt; q; j++)</span><br><span class="line">            <span class="keyword">if</span>(a[j] &gt; a[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                swap(&amp;a[j], &amp;a[j+<span class="number">1</span>]);</span><br><span class="line">                lastSwapIndex = j;<span class="comment">//记录每一趟最后交换的位置</span></span><br><span class="line">                <span class="keyword">if</span>(firstFlag) &#123;<span class="comment">//记录每一趟开始交换的位置</span></span><br><span class="line">                    beginSwapIndex = j == <span class="number">0</span> ? <span class="number">0</span> : j - <span class="number">1</span>;</span><br><span class="line">                    firstFlag = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        q = lastSwapIndex;</span><br><span class="line">        firstFlag = <span class="number">1</span>;</span><br><span class="line">        p = beginSwapIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过分析比较排序中经典的插入排序，引入了<strong>逆序对</strong>和<strong>转置</strong>的概念，对所有比较排序的算法的平均和最坏时间复杂度进行了最坏的边界分析，从而得到了对于每一次比较最多消除一个逆序对的算法平均时间复杂度的边界上边界，和最坏的时间复杂度的上边界。这些分析给如何改良排序算法提供了途径。通过每一次比较，将元素移动<strong>超过不止</strong>一个位置（这样就可以消除不止一个逆序对），这样就可以将比较类排序算法显著的改善。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://spground.github.io/2016/09/16/Common%20Data%20Structure%20Graph's%20Application%20TopSort/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Spground">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spground Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Spground Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2016/09/16/Common%20Data%20Structure%20Graph's%20Application%20TopSort/" class="post-title-link" itemprop="url">常用数据结构图--拓扑排序</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2016-09-16 15:24:00" itemprop="dateCreated datePublished" datetime="2016-09-16T15:24:00+08:00">2016-09-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-24 22:30:21" itemprop="dateModified" datetime="2025-09-24T22:30:21+08:00">2025-09-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="常用数据结构图–拓扑排序"><a href="#常用数据结构图–拓扑排序" class="headerlink" title="常用数据结构图–拓扑排序"></a>常用数据结构图–拓扑排序</h2><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><blockquote>
<p>在数学中，一个图（Graph）是表示物件与物件之间的关系的数学对象，是图论的基本研究对象。</p>
</blockquote>
<p>图是十分重要的数据结构，常常被应用于实际生活的应用之中。生活中常见的问题例如交通路线图、任务指定分配、工期计算、航空网络等，都可以使用图相关的理论来建立模型。</p>
<p>下面是《数据结构与算法分析》对图的若干定义</p>
<blockquote>
<p>一个图（Graph）G &#x3D; （V, E）由顶点（vertex）集和边（Edge）集E组成。每一条边就是一个点对（v，w），其中v，w属于集合V。有时也把边Edge叫做弧（arc）。如果点对是有序的，那么图就叫做是有序的（directed）。有向的图有时候叫做有向图。顶点v和w邻接（adjacent）当且仅当（v，w）属于E。在一个具有边（v，w）从而具有边（w，v）的无向图中，w和v邻接且v和w也邻接。有时候边还具有第三种成分，叫做权（weight）或值（cost）。</p>
</blockquote>
<h2 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h2><p>一种简单存储图的方式时采用一个被称为邻接矩阵的二维数组<code>a[i][j]</code>，数组的大小为<code>n * n</code>，<code>n</code> 为图的顶点个数。其中如果顶点i到顶点j连通，那么<code>a[i][j] = 1</code>，否则<code>a[i][j] = 0</code>。这种存储方式的优点是简单直观，实现方便。缺点也很明显，所需要的存储空间巨大。  </p>
<p>当含有n个顶点的图G中大多数顶点都不是连通，那么意味中<code>n * n</code> 邻接矩阵中有大量的元素为0，即此时邻接矩阵是稀疏矩阵。</p>
<p>另一种常见的存储方式称为邻接表（adjacent list），这种方式是申请一个大小为<code>n</code> 的数组<code>head</code>，数组元素<code>head[i]</code>，存放着由顶点i的所有邻接顶底组成的链表的头地址。此种存储方式的优点显而易见，相比于前一种方式，存储空间的大小明显减小。但是缺点是不直观，编码有难度。</p>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>拓扑排序是对又向无圈图的顶点的一种排序，它使得如果存在一条从<code>Vi</code> 到<code>Vj</code> 的路径，那么在排序中<code>Vj</code> 必须出现在 <code>Vi</code> 的后面。</p>
<p>一种简单的求拓扑排序的算法先是找出任意一个入度为0的顶点。然后我们输出该顶点，并将它和它的边一起冲图中删除。然后，将其邻接的顶点的入度减去1。然后重复上述过程，直达图被完全删除。</p>
<p>不难看出，此种算法首先是外层循环 <code>n</code> 次，其次是内部循环中在选取入度为0 的顶点时候，会内部循环<code>n</code>次。因此总的时间复杂度会达到<code>n * n</code>。</p>
<p>另一种较好的改进方法是，将所有入度为0的顶点压入某个栈，然后每一次输出顶底元素A后，再将A的所有邻接顶点的入度减去1，如果某个邻接顶点的入度此时为0，那么将其继续入栈。重复上诉操作指导栈空。</p>
<p>可以看出，对每一个入度为0的顶点入栈的操作执行了<code>n</code> 次，<code>n</code> 为顶点数。对出栈的元素A，将其邻接顶点的入度减1，然后入栈的操作，最多执行了 <code>m</code> 次， <code>m</code> 为图边的条数。因此总的时间复杂度就会是线性的 <code>O(n)</code></p>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">int</span> indegree;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化邻接表</span></span><br><span class="line"><span class="keyword">struct</span> Node* <span class="title function_">initAdjList</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">headers</span>;</span></span><br><span class="line">    headers = (<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node) * n);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i; i &lt; n; i++) &#123;</span><br><span class="line">        headers[i].next = <span class="literal">NULL</span>;</span><br><span class="line">        headers[i].value = <span class="number">0</span>;</span><br><span class="line">        headers[i].indegree = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> headers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">addAdj</span><span class="params">(<span class="keyword">struct</span> Node* header, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">p</span> =</span> &amp;header[m];</span><br><span class="line">    p-&gt;value++;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    p-&gt;next = (<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">    p-&gt;next-&gt;value = n;</span><br><span class="line">    p-&gt;next-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印邻接表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printAdjList</span><span class="params">(<span class="keyword">struct</span> Node* header, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">p</span> =</span> &amp;header[i];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Number of %d&#x27; adj : %d\t&quot;</span>, i, p-&gt;value);</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next!= <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d ---&gt;%d\t&quot;</span>, i, p-&gt;next-&gt;value);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拓扑排序</span></span><br><span class="line"><span class="type">int</span>* <span class="title function_">topSort</span><span class="params">(<span class="keyword">struct</span> Node* headers, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span>* zeroStack = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">    <span class="type">int</span>* result = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> pIndex = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">p</span> =</span> &amp;headers[i];</span><br><span class="line">        <span class="comment">//入度为0，直接进栈</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;indegree == <span class="number">0</span>)</span><br><span class="line">            zeroStack[++pIndex] = i;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//从top里面出栈一个Node Index</span></span><br><span class="line">        <span class="type">int</span> zeroIndex = zeroStack[pIndex--];</span><br><span class="line">        result[count++]  = zeroIndex;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">zeroNode</span> =</span> &amp;headers[zeroIndex];</span><br><span class="line">        <span class="comment">//将zeroNode的连接点，对应的头结点的值减一</span></span><br><span class="line">        <span class="keyword">while</span>(zeroNode-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">q</span> =</span> &amp;headers[zeroNode-&gt;next-&gt;value];</span><br><span class="line">            <span class="keyword">if</span>(--q-&gt;indegree == <span class="number">0</span>)</span><br><span class="line">                zeroStack[++pIndex] = zeroNode-&gt;next-&gt;value;</span><br><span class="line">            zeroNode = zeroNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//栈空</span></span><br><span class="line">        <span class="keyword">if</span>(pIndex &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">7</span>][<span class="number">7</span>] = &#123; &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">                    &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">                    &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,</span><br><span class="line">                    &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,</span><br><span class="line">                    &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,</span><br><span class="line">                    &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">                    &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;</span><br><span class="line">                    &#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">7</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">headers</span> =</span> initAdjList(n);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i][j] == <span class="number">1</span>)</span><br><span class="line">                addAdj(headers, i, j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成各节点indegree</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">p</span> =</span> &amp;headers[i];</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            headers[p-&gt;next-&gt;value].indegree++;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* q = topSort(headers, n);</span><br><span class="line">    printAdjList(headers, n);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d \n&quot;</span>, *q++ + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://spground.github.io/2016/09/13/Common%20Data%20Structure%20Stack's%20Applocation-Evaluate%20expression/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Spground">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spground Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Spground Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2016/09/13/Common%20Data%20Structure%20Stack's%20Applocation-Evaluate%20expression/" class="post-title-link" itemprop="url">常用数据结构栈的应用----表达式求值</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2016-09-13 11:53:00" itemprop="dateCreated datePublished" datetime="2016-09-13T11:53:00+08:00">2016-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-24 22:30:21" itemprop="dateModified" datetime="2025-09-24T22:30:21+08:00">2025-09-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="常用数据结构栈的应用—-表达式求值"><a href="#常用数据结构栈的应用—-表达式求值" class="headerlink" title="常用数据结构栈的应用—-表达式求值"></a>常用数据结构栈的应用—-表达式求值</h2><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><blockquote>
<p>栈是常用的数据结构，栈又称堆栈，是一种受限的线性表。其限制是允许在表中的一端进行插入和删除元素。栈中的元素符合后进先出（FILO）的性质。允许插入和删除元素的一端被称为栈顶，另一端被称为栈底。<br>栈有两种关键的操作，分别为出栈和压栈。</p>
</blockquote>
<p> 栈有两种关键的操作，分别为出栈和压栈。</p>
<ul>
<li>出栈(pop)：它是把栈顶的元素E删除，使E的下一个元素称为新的栈顶，并返回元素E</li>
<li>压栈（push）:它是将元素E插入栈顶，使得新插入的元素E称为新的栈顶。</li>
</ul>
<p>栈的常见的应用主要有：编译器中语法分析的符号匹配、表达式求值、程序的函数调用等。<br>例如：操作系统中的进程的上下文切换，里面被切换下CPU的进程的现场信息例如寄存器等信息，被保存在堆栈中，等到CPU轮转到该进程时，使用堆栈恢复现场。</p>
<h1 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h1><p>表达式求值是栈的一个重要的应用。例如计算器中的加减乘除表达式的计算，都会使用栈来进行求值。<br>表达式的表示方法主要有中缀表示法和后缀表示法。</p>
<ul>
<li><p>中缀表示法：操作符号处于两个操作数的中间例如3+4，中缀表达式是符合人们思维的算术表达式方法，中缀表达式通常包含圆括号和方括号。中缀表达式不容易被计算机所理解，因此不太方便使用其进行表达式求值。</p>
<blockquote>
<p>中缀表示的例子 1 + 3 * （4 + 5）</p>
</blockquote>
</li>
<li><p>后缀表达式：不包含括号，运算符号放在两个运算对象的后面，所有的计算按运算符号出现的顺序，严格的从左向右进行运算（不再需要考虑运算符号的优先规则）。</p>
<blockquote>
<p>后缀表达式的例子21+3* 对应中缀表达式为（2+1）*3</p>
</blockquote>
</li>
</ul>
<h1 id="后缀表达式求值"><a href="#后缀表达式求值" class="headerlink" title="后缀表达式求值"></a>后缀表达式求值</h1><p>使用后缀表达式进行求值的时候，不需要考虑括号和运算符号的优先规则，只需要从左到右进行计算求值即可。</p>
<p>后缀表达式的求值过程为：</p>
<pre><code>1. 读入操作数，压入栈中直到读取到操作符
2. 如果读取到为操作符，则将栈顶的前两元素出栈，使用该操作符进行运算，得到计算结果
3. 将计算结果压入栈中
4. 重复1、2、3直到表达式末尾
</code></pre>
<p>最后栈中只有一个元素，变为最后的计算结果。将其出栈即可。</p>
<p>例如：<br>中缀表达式<code>（2+1）*3</code><br>对应的后缀表达式为<code>21+3*</code></p>
<ul>
<li>初始化栈S</li>
<li>读取2和1压入S，此时S为<code>1,2</code></li>
<li>读取到操作符+,出栈栈顶两元素得到<code>1,2</code>，此时栈为空</li>
<li>使用操作符计算两操作数，得到<code>3（1 + 2 = 3）</code>,将<code>3</code>压入栈S，此时栈S为<code>3</code></li>
<li>读入<code>3</code>,压入栈S，此时栈为<code>3,3</code></li>
<li>读取到操作符*,出栈栈顶两元素得到<code>3，3</code> 此时栈S为空</li>
<li>使用操作符*，对两元素进行运算得到<code>9</code>，将<code>9</code>压入栈S</li>
<li>读取到表达式尾部</li>
</ul>
<p>出栈栈顶元素得到<code>9</code>即为计算结果</p>
<p>计算机通常使用后缀表达式进行表达式求值，但是人们通常输入计算的表达式是中缀表达式，因此在进行表达式求值的时候，应该先将中缀表达式转为后缀表达式，然后使用后缀表达式求出表达式值。后缀表达式求值的过程很简单，已经上面分析过了。现在关键的一步就是中缀表达式转为后缀表达式。</p>
<h1 id="中缀表达式转后缀表达式"><a href="#中缀表达式转后缀表达式" class="headerlink" title="中缀表达式转后缀表达式"></a>中缀表达式转后缀表达式</h1><p>中缀表达式转后缀表达式是表达式求值关键的一步，其过程如下：<br>输入中缀表达式IEXP，<br>输出后缀表达式SEXP<br>依次读入中缀表达式IEXP，初始化一个栈S用来存放操作符OP。</p>
<pre><code>1. 如果读取的是操作数，直接输出到SEXP。如果为操作符OP，进入step2，如果为空，证明读取到IEXP尾部，则进入step5
2. 判断OP，若为`(`，无任何输出，直接压栈`(`到S，进入step1；若为`)`，则出栈S的元素输出到SEXP中直到遇见元素`(`，且`(`不输出到SEXP中，然后进入step1；若OP不为`(`和`)`，则执行step3
3. 判断栈S的栈顶元素是否为`(`，若为`（`，则直接将OP压栈到S中；若不为`(`，则将栈S的元素出栈输出到SEXP中，直到栈顶元素的优先级小于OP或者栈空，最后进入step4
4. 将OP压入栈S中，进入step1
5. 将栈所有元素输出到SEXP中
</code></pre>
<p>例如<br> IEXP为<code>（2+1）*3</code>，<br> 初始化一个空栈S.</p>
<ol>
<li>读取到操作符<code>(</code>，直接压入栈S，此时栈S为<code>（、</code>。</li>
<li>读取到操作数<code>2</code>，则直接输出到SEXP，此时S仍为<code>（</code>，SEXP为 <code>2</code></li>
<li>读取到操作符号<code>+</code>，由于栈S栈顶元素为<code>(</code>，因此直接将<code>+</code>，压入栈S中，此时SEXP为<code>2</code>，栈S为<code>（、+</code></li>
<li>读取到操作数<code>1</code>，直接输出，此时SEXP为<code>21</code>， 栈S为<code>（、+</code>  。</li>
<li>读取到操作符<code>)</code>，则出栈S的元素直到碰见<code>(</code>，不输出<code>(</code>和<code>)</code>,则SEXP为<code>21+</code>，栈S为空</li>
<li>读取到操作符号<code>*&#39;</code>压栈到S，此时SEXP仍为<code>21+</code>,栈S为<code>*</code></li>
<li>读取到操作数<code>3</code>，直接输出到SEXP中，SEXP为<code>21+3</code>，栈S为<code>*</code></li>
<li>读取到文件尾，则出栈S知道栈空，SEXP为<code>21+3*</code></li>
</ol>
<p> 最后得到后缀表达式<code>21+3*</code></p>
<p> 可见，中缀转后缀的关键点在于读取到的操作符为括号的case，栈中的<code>(</code>保留直到遇见操作符<code>)</code>，否则是不会出栈的。</p>
<h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//int栈</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCREMENT 20</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stack_</span>&#123;</span></span><br><span class="line">    <span class="type">int</span>* a;</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop_</span><span class="params">(<span class="keyword">struct</span> Stack_* <span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">stack</span>-&gt;size &lt;= <span class="number">0</span> || <span class="built_in">stack</span>-&gt;top &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;size--;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;a[<span class="built_in">stack</span>-&gt;top--];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push_</span><span class="params">(<span class="keyword">struct</span> Stack_* <span class="built_in">stack</span>, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="comment">//扩容</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">stack</span>-&gt;size &lt;= <span class="built_in">stack</span>-&gt;capacity) &#123;</span><br><span class="line">        <span class="built_in">stack</span>-&gt;capacity += INCREMENT;</span><br><span class="line">        <span class="type">int</span>* p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * ( <span class="built_in">stack</span>-&gt;capacity));</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">int</span>* q;</span><br><span class="line">        q = p;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="built_in">stack</span>-&gt;size; i++) &#123;</span><br><span class="line">            *(q++) = *(<span class="built_in">stack</span>-&gt;a++);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">stack</span>-&gt;a = p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//压栈</span></span><br><span class="line">    <span class="built_in">stack</span>-&gt;size++;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;top++;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;a[<span class="built_in">stack</span>-&gt;top] = c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Stack_* <span class="title function_">initStack_</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stack_</span>* <span class="title">stack</span> =</span> (<span class="keyword">struct</span> Stack_*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Stack_));</span><br><span class="line">    <span class="type">int</span>* a = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * capacity);</span><br><span class="line">    <span class="built_in">stack</span>-&gt;size = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;top = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;a = a;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试是否字符数组是否存在test字符</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">in</span><span class="params">(<span class="type">char</span>* a, <span class="type">int</span> n, <span class="type">char</span> test)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] == test)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//优先级比较</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">char</span> a, <span class="type">char</span> b)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(a == b)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(a == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="string">&#x27;*&#x27;</span> || b == <span class="string">&#x27;(&#x27;</span> || b == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(a == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> +<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="string">&#x27;(&#x27;</span> || b == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中缀表达式转为后缀表达式</span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">infix2Suffix</span><span class="params">(<span class="type">char</span>* infix, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>* <span class="title">stack</span> =</span> initStack(n);</span><br><span class="line">    <span class="type">char</span> add = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">    <span class="type">char</span> mult = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">    <span class="type">char</span> left = <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">    <span class="type">char</span> right = <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">    <span class="type">char</span> op[<span class="number">4</span>] = &#123;<span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;)&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> *result = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * n);</span><br><span class="line">    <span class="type">char</span> top;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">char</span> c = infix[i];</span><br><span class="line">        <span class="comment">//如果读取的字符不为操纵符，为操作数</span></span><br><span class="line">        <span class="comment">//直接放入输出字符数组中</span></span><br><span class="line">        <span class="keyword">if</span>(!in(op, <span class="number">4</span>, c))</span><br><span class="line">            result[j++] = c;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//开始将操作符压栈</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">stack</span>-&gt;size == <span class="number">0</span>)</span><br><span class="line">                push(<span class="built_in">stack</span>, c);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="keyword">if</span>(c != <span class="string">&#x27;(&#x27;</span> &amp;&amp; c != <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">                        top =  pop(<span class="built_in">stack</span>);</span><br><span class="line">                        <span class="keyword">if</span>(top == <span class="literal">NULL</span>)</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">if</span>(top == <span class="string">&#x27;(&#x27;</span> || compare(c, top) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            push(<span class="built_in">stack</span>, top);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (compare(c, top) &lt;= <span class="number">0</span>)</span><br><span class="line">                            result[j++] = top;</span><br><span class="line">                    &#125;</span><br><span class="line">                    push(<span class="built_in">stack</span>, c);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                    push(<span class="built_in">stack</span>, c);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(c == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">                        top =  pop(<span class="built_in">stack</span>);</span><br><span class="line">                        <span class="keyword">if</span>(top != <span class="literal">NULL</span> &amp;&amp; top != <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                            result[j++] = top;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出栈中剩余的内容</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        top = pop(<span class="built_in">stack</span>);</span><br><span class="line">        <span class="keyword">if</span>(top == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        result[j++] = top;</span><br><span class="line">    &#125;</span><br><span class="line">    result[j++] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中缀表达式求值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">evaluate</span><span class="params">(<span class="type">char</span>* infix, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *suffix = infix2Suffix(infix, n);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stack_</span>* <span class="title">stack</span> =</span> initStack_(n);</span><br><span class="line">    <span class="type">char</span> op[<span class="number">4</span>] = &#123;<span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;)&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> opnum1, opnum2;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((c = suffix[i++]) != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!in(op, <span class="number">4</span>, c))</span><br><span class="line">            push_(<span class="built_in">stack</span>, (<span class="type">int</span>)c - (<span class="type">int</span>)<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(in(op, <span class="number">4</span>, c))&#123;</span><br><span class="line">            <span class="type">int</span> opnum1 = pop_(<span class="built_in">stack</span>);</span><br><span class="line">            <span class="type">int</span> opnum2 = pop_(<span class="built_in">stack</span>);</span><br><span class="line">            <span class="type">int</span> tmp;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">                tmp = opnum1 + opnum2;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                tmp = opnum1 * opnum2;</span><br><span class="line">            push_(<span class="built_in">stack</span>, tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pop_(<span class="built_in">stack</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> infixExp[<span class="number">13</span>] = &#123;<span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;7&#x27;</span>,</span><br><span class="line">                        <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">                        <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;)&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">int</span> result = evaluate(infixExp, <span class="number">13</span>);</span><br><span class="line">    <span class="type">char</span> *suffixExp = infix2Suffix(infixExp, <span class="number">13</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(*suffixExp!= <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, *suffixExp++);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n%d&quot;</span>, result);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://spground.github.io/2016/08/20/Virtual%20IP%20ad%20ARP%20protocal/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Spground">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spground Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Spground Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2016/08/20/Virtual%20IP%20ad%20ARP%20protocal/" class="post-title-link" itemprop="url">虚拟IP与ARP协议</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2016-08-20 10:47:00" itemprop="dateCreated datePublished" datetime="2016-08-20T10:47:00+08:00">2016-08-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-24 22:30:21" itemprop="dateModified" datetime="2025-09-24T22:30:21+08:00">2025-09-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-虚拟IP"><a href="#1-虚拟IP" class="headerlink" title="1. 虚拟IP"></a>1. 虚拟IP</h2><p><strong>虚拟IP（Virtual IP Address），是一种不与特定计算机或者特定计算机网卡相对应的IP地址。所有发往这个IP地址的数据包最后都会经过真实的网卡到达目的主机的目的进程。</strong></p>
<p>引用<a href="https://en.wikipedia.org/wiki/Virtual_IP_address">维基</a>上面的定义：</p>
<blockquote>
<p>A virtual IP address (VIP or VIPA) is an IP address that doesn’t correspond to an actual physical network interface (port). Uses for VIPs include network address translation (especially, one-to-many NAT), fault-tolerance, and mobility.</p>
</blockquote>
<p>虚拟IP主要是用来网络地址转换，网络容错和可移动性。</p>
<p>虚拟IP比较常见的一个用例就是在**系统高可用性（High Availability HA）**方面的应用，通常一个系统会因为日常维护或者非计划外的情况而发生宕机，为了提高系统对外服务的高可用性，就会采用主备模式进行高可用性的配置。</p>
<p>当提供服务的主机<code>M</code>宕机后，服务会切换到备用主机<code>S</code>继续对外提供服务。而这一切用户是感觉不到的，在这种情况下系统对客户端提供服务的<code>IP</code>地址就会是一个<code>虚拟IP</code>，当主机<code>M</code>宕机后，<code>虚拟IP</code>便会漂浮到备机上，继续提供服务。<br>​<br> 在这种情况下，<strong><code>虚拟IP</code>就不是与特定计算主机或者特定某个物理网卡对应</strong>，而是一种逻辑的概念。它是可以自由移动（自由漂浮）的，这样既对外屏蔽了系统内部的细节，又为系统内部的<strong>可维护性和扩展性</strong>提供了方便。</p>
<h2 id="2-ARP协议"><a href="#2-ARP协议" class="headerlink" title="2. ARP协议"></a>2. ARP协议</h2><h3 id="2-1-ARP协议"><a href="#2-1-ARP协议" class="headerlink" title="2.1  ARP协议"></a>2.1  ARP协议</h3><p> <code>ARP</code>协议属于<code>TCP/IP</code>协议族里一种将<code>IP</code>地址解析为<code>MAC</code>地址的协议，位于<code>TCP/IP</code>五层模型中的<strong>网络层</strong>。该协议是用来在局域网内<strong>解析<code>IP地址</code>对应的物理地址</strong>。</p>
<p><img src="http://img.blog.csdn.net/20171118164743381?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDUzMjkwMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>通常一个主机<code>A</code>给另一个主机<code>B</code>通过网络发送一个<code>IP</code>数据报的时候，首先会发送到主机<code>A</code>所在网络的的<strong>路由器</strong>上面，然后<strong>路由器</strong>会判断目的地址是否在本网络内，是则直接转发到本网络内的目的主机；否则会继续传递到下一个路由，直到到达指定的网络的<strong>路由器</strong>，指定网络的路由器会将此数据报发送到<strong>目的主机</strong>。</p>
<p>整个过程最后都会涉及到由某一个网络的<strong>路由器（或者网关）<strong>将数据发送到网内某一主机的过程。这个过程通常是由</strong>路由器</strong>发送一个<strong>ARP广播请求</strong>，请求<code>IP</code>地址和数据包目的<code>IP</code>地址一致的主机将它自己的<code>MAC</code>地址返回给<strong>路由器</strong>，因为<strong>数据链路层的数据传输是通过物理地址传输的</strong>。</p>
<p><strong>ARP请求</strong>会广播到所有局域网内的主机，网内其他主机收到这个<strong>ARP请求</strong>后</p>
<ol>
<li><p>检查发送<strong>ARP请求</strong>的主机的<strong>IP地址</strong></p>
</li>
<li><p>将该<strong>IP地址</strong>和其对应的<strong>MAC</strong>地址存放在<strong>ARP缓存</strong>中</p>
</li>
<li><p>检查这个ARP请求中请求的<code>IP</code>地址是否为自己的<code>IP</code>地址，是则发送一个<code>ARP</code>应答，应答包含自己的<code>IP地址</code>和对应的<code>MAC</code>地址。</p>
</li>
</ol>
<p>当网络内的路由器得到了<strong>MAC</strong>地址后，便可以通过数据链路层将数据包正确传输到目的主机上了。</p>
<h3 id="2-2-ARP缓存"><a href="#2-2-ARP缓存" class="headerlink" title="2.2 ARP缓存"></a>2.2 ARP缓存</h3><p> <strong>ARP</strong>协议中比较重要的内容之一就是<strong>ARP缓存</strong>，主机操作系统会将<strong>IP地址</strong>与<strong>MAC地址</strong>的映射关系存放在主机的一片高速缓存中。</p>
<ul>
<li><p>缓存失效：该缓存会在一定时间内失效，失效后，请求该IP地址时需要广播<code>arp</code>请求重新获取<code>IP</code>地址对应的<code>MAC</code>地址</p>
</li>
<li><p>缓存更新：当收到<code>ARP</code>请求时，会将发送<code>ARP</code>请求的主机<code>IP</code>地址与<code>MAC</code>地址记录下来，然后去更新本机<code>ARP</code>缓存中对应的记录</p>
</li>
</ul>
<h2 id="3-虚拟IP与ARP协议"><a href="#3-虚拟IP与ARP协议" class="headerlink" title="3. 虚拟IP与ARP协议"></a>3. 虚拟IP与ARP协议</h2><p>虚拟IP常用于系统高可用性的场景，那么虚拟IP实现的原理是什么?虚拟能够自由漂浮的原理是什么？</p>
<p>从前文介绍arp协议里面来看，主机与主机的通信过程都会涉及到一个ip地址转换mac地址的过程，那么虚拟IP的通信也不会例外。因此，IP地址在主机通信的过程中其实就是一个逻辑地址。</p>
<p>我们知道，每一个主机都存放着网络内一些主机的逻辑地址与物理地址（MAC地址）的映射，那么问题来了：</p>
<p>当虚拟<code>IP</code>（简称<code>VIP</code>）在主机A上时，主机<code>A</code>的<code>MAC</code>地址为<code>MAC_A</code>，某主机<code>M</code>的<code>arp缓存</code>中存放着一个映射关系：<strong>VIP &lt;–&gt; MAC_A</strong>；当主机<code>A</code>宕机后, <code>VIP</code>漂浮到了主机<code>B</code>，主机<code>B</code>的<code>MAC</code>地址为<code>MAC_B</code>，那么此时主机<code>M</code>想与虚拟<code>IP</code>通信时，是做不到的；因为它的<code>arp</code>高速缓存中的<code>VIP</code>的映射还指向主机<code>A</code>的<code>MAC</code>地址。这个问题解决的思路就是当<code>虚拟IP</code>漂浮后，刷新所有其他主机的<code>arp缓存</code>。</p>
<p>那么虚拟IP是如何实现漂浮后，是如何刷新所有其他主机的<strong>ARP缓存</strong>的呢？</p>
<p> 这里就会引入另一个概念，<strong>GARP(简称无端ARP或者免费ARP)</strong>，主要是用来当某一个主机<code>C</code>开机时，用来确认自己的<code>IP</code>地址没有被人占用而做的一个检测。广播发送这个<code>arp</code>，请求得到本机<code>IP</code>地址的<code>MAC</code>地址，主机<code>C</code>并不希望此次<code>arp</code>请求会有<code>arp</code>应答，<strong>因为应答意味着IP地址冲突了</strong>。<strong>当其他主机收到这个arp请求后，会刷新关于这个arp请求源的主机IP地址的映射。</strong></p>
<p><code>GARP</code>的作用主要有两个:</p>
<ol>
<li>检测IP地址是否有冲突</li>
<li>刷新其他主机关于本次IP地址的映射关系</li>
</ol>
<p>集群管理软件<strong>Pacemaker</strong>里面的资源代理<code>ocf:heartbeat:IPaddr2</code>中，在<code>虚拟IP</code>漂浮后，会向网络内广播发送<code>garp</code>请求，以此来刷新其他主机的<code>arp</code>缓存。</p>
<p>在配置<strong>OpenStack</strong>控制节点高可用性的时候，出现过虚拟IP切换时，某一个主机不能通信的问题，后来发现是arp缓存没有刷新，有时候由于网络的原因，某些主机没有接收到此<code>garp</code>请求，因此<code>ocf:heartbeat:IPaddr2</code>资源代理中可以配置发送<code>garp</code>的次数，这里建议次数配置得多一点，这样可以保证其他主机成功刷新<code>arp</code>缓存。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Spground</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
